(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{971:function(n,e,t){"use strict";window.xbrz_process_function_string='return async function(image_data, scale) {\n\n    const redMask = 0xff0000\n    const greenMask = 0x00ff00\n    const blueMask = 0x0000ff\n  \n    function blendComponent (mask, n, m, inPixel, setPixel) {\n      const inChan = inPixel & mask\n      const setChan = setPixel & mask\n      const blend = setChan * n + inChan * (m - n)\n      return mask & (blend / m)\n    }\n  \n    function alphaBlend (n, m, dstPtr, col) {\n      // assert n < 256 : "possible overflow of (col & redMask) * N";\n      // assert m < 256 : "possible overflow of (col & redMask) * N + (dst & redMask) * (M - N)";\n      // assert 0 < n && n < m : "0 < N && N < M";\n  \n      const dst = dstPtr.get()\n      const redComponent = blendComponent(redMask, n, m, dst, col)\n      const greenComponent = blendComponent(greenMask, n, m, dst, col)\n      const blueComponent = blendComponent(blueMask, n, m, dst, col)\n      const blend = (redComponent | greenComponent | blueComponent)\n      dstPtr.set(blend | 0xff000000)\n    }\n  \n  \n    class Scaler2x {\n      constructor () {\n        this.scale = 2\n      }\n  \n      scale () {\n        return this.scale\n      }\n  \n      blendLineShallow (col, out) {\n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n      }\n  \n      blendLineSteep (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(1, 0), col)\n        alphaBlend(1, 4, out.ref(0, 1), col)\n        alphaBlend(5, 6, out.ref(1, 1), col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(1, 1), col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(21, 100, out.ref(1, 1), col)\n      }\n    }\n  \n  \n    class Scaler3x extends Scaler2x{\n      constructor () {\n        super()\n        this.scale = 3\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(2, 0), col)\n        alphaBlend(1, 4, out.ref(0, 2), col)\n  \n        alphaBlend(3, 4, out.ref(2, 1), col)\n        alphaBlend(3, 4, out.ref(1, 2), col)\n  \n        out.ref(2, 2).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 8, out.ref(1, 2), col)\n        alphaBlend(1, 8, out.ref(2, 1), col)\n        alphaBlend(7, 8, out.ref(2, 2), col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(45, 100, out.ref(2, 2), col)\n      }\n    }\n  \n  \n    class Scaler4x extends Scaler3x {\n      constructor () {\n        super()\n        this.scale = 4\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n  \n        // out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n  \n        // out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(3, 4, out.ref(3, 1), col)\n        alphaBlend(3, 4, out.ref(1, 3), col)\n        alphaBlend(1, 4, out.ref(3, 0), col)\n        alphaBlend(1, 4, out.ref(0, 3), col)\n  \n        alphaBlend(1, 3, out.ref(2, 2), col)\n  \n        out.ref(3, 3).set(col)\n        out.ref(3, 2).set(col)\n        out.ref(2, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 2, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        out.ref(this.scale - 1, this.scale - 1).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(68, 100, out.ref(3, 3), col)\n        alphaBlend(9, 100, out.ref(3, 2), col)\n        alphaBlend(9, 100, out.ref(2, 3), col)\n      }\n    }\n  \n    class Scaler5x extends Scaler4x{\n      constructor () {\n        super()\n        this.scale = 5\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // **\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(1, 4, out.ref(this.scale - 3, 4), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n        // out.ref(this.scale - 1, 2).set(col)\n        // out.ref(this.scale - 1, 3).set(col)\n        out.ref(this.scale - 1, 4).set(col)\n        out.ref(this.scale - 2, 4).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(1, 4, out.ref(4, this.scale - 3), col)\n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n        // out.ref(2, this.scale - 1).set(col)\n        // out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n        out.ref(4, this.scale - 2).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n  \n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(2, 3, out.ref(3, 3), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        // **\n        alphaBlend(1, 8, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 8, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        alphaBlend(1, 8, out.ref(this.scale - 3, this.scale / 2 + 2), col)\n        alphaBlend(7, 8, out.ref(4, 3), col)\n        alphaBlend(7, 8, out.ref(3, 4), col)\n        out.ref(4, 4).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(86, 100, out.ref(4, 4), col)\n        alphaBlend(23, 100, out.ref(4, 3), col)\n        alphaBlend(23, 100, out.ref(3, 4), col)\n      }\n    }\n  \n    class Scaler6x extends Scaler5x {\n      constructor () {\n        super()\n        this.scale = 6\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 3, 4), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n        alphaBlend(3, 4, out.ref(this.scale - 3, 5), col)\n  \n        // out.ref(this.scale - 1, 2).set(col)\n        // out.ref(this.scale - 1, 3).set(col)\n        // out.ref(this.scale - 1, 4).set(col)\n        out.ref(this.scale - 1, 5).set(col)\n  \n        // out.ref(this.scale - 2, 4).set(col)\n        out.ref(this.scale - 2, 5).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        // alphaBlend(1, 4, out.ref(4, this.scale - 3), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        // alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(5, this.scale - 3), col)\n  \n        // out.ref(2, this.scale - 1).set(col)\n        // out.ref(3, this.scale - 1).set(col)\n        // out.ref(4, this.scale - 1).set(col)\n        out.ref(5, this.scale - 1).set(col)\n  \n        // out.ref(4, this.scale - 2).set(col)\n        out.ref(5, this.scale - 2).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n  \n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n        out.ref(5, this.scale - 1).set(col)\n  \n        out.ref(4, this.scale - 2).set(col)\n        out.ref(5, this.scale - 2).set(col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 2, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        alphaBlend(1, 2, out.ref(this.scale - 3, this.scale / 2 + 2), col)\n  \n        out.ref(this.scale - 2, this.scale - 1).set(col)\n        out.ref(this.scale - 1, this.scale - 1).set(col)\n        out.ref(this.scale - 1, this.scale - 2).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(97, 100, out.ref(5, 5), col)\n        alphaBlend(42, 100, out.ref(4, 5), col)\n        alphaBlend(42, 100, out.ref(5, 4), col)\n        alphaBlend(6, 100, out.ref(5, 3), col)\n        alphaBlend(6, 100, out.ref(3, 5), col)\n      }\n    }\n  \n  \n    class IntPtr {\n      constructor (intArray) {\n        this.arr = intArray\n        this.ptr = 0\n      }\n  \n      position (pos) {\n        this.ptr = pos\n      }\n  \n      get () {\n        return this.arr[this.ptr]\n      }\n  \n      set (val) {\n        this.arr[this.ptr] = val\n      }\n    }\n  \n    class BlendResult {\n      constructor () {\n        this.f = 0\n        this.g = 0\n        this.j = 0\n        this.k = 0\n      }\n  \n      reset () {\n        this.f = 0\n        this.g = 0\n        this.j = 0\n        this.k = 0\n      }\n    }\n  \n    const maxRots = 4\n    const maxScale = 6\n    const maxScaleSq = maxScale * maxScale\n  \n    class OutputMatrix {\n      constructor (scale, out, outWidth) {\n        this.out = new IntPtr(out)\n        this.n = (scale - 2) * (maxRots * maxScaleSq)\n        this.outWidth = outWidth\n        this.outi = 0\n        this.nr = 0\n      }\n  \n      move (rotDeg, outi) {\n        this.nr = this.n + rotDeg * maxScaleSq\n        this.outi = outi\n      }\n  \n      ref (i, j) {\n        i = parseInt(i)\n        j = parseInt(j)\n        const rot = matrixRotation[this.nr + i * maxScale + j]\n        this.out.position(this.outi + rot.J + rot.I * this.outWidth)\n        return this.out\n      }\n    }\n  \n    const Rot = (function () {\n      /*\n      |0|6|8|2|1|3|\n      |7|5|2|0|6|8|\n      |3|8|5|1|4|4|\n      |4|4|5|1|3|7|\n      |6|8|2|0|7|5|\n      |1|3|8|2|0|7|\n       */\n      let arr = []\n      const\n          a = 0, b = 1, c = 2,\n          d = 3, e = 4, f = 5,\n          g = 6, h = 7, i = 8\n  \n      const deg0 = [\n        a, b, c,\n        d, e, f,\n        g, h, i\n      ]\n  \n      const deg90 = [\n        g, d, a,\n        h, e, b,\n        i, f, c\n      ]\n  \n      const deg180 = [\n        i, h, g,\n        f, e, d,\n        c, b, a\n      ]\n  \n      const deg270 = [\n        c, f, i,\n        b, e, h,\n        a, d, g\n      ]\n  \n      const rotation = [\n        deg0, deg90, deg180, deg270\n      ]\n  \n      for (let rotDeg = 0; rotDeg < 4; rotDeg++) {\n        for (let x = 0; x < 9; x++) {\n          arr[(x << 2) + rotDeg] = rotation[rotDeg][x]\n        }\n      }\n      return arr\n    })()\n  \n    const BlendType = {\n      \'BLEND_NONE\': 0,\n      \'BLEND_NORMAL\': 1,\n      \'BLEND_DOMINANT\': 2\n    }\n  \n    const blendResult = new BlendResult()\n  \n    function square (value) {\n      return value * value\n    }\n  \n  // 用指定颜色填充区块\n    function fillBlock (trg, trgi, pitch, col, blockSize) {\n      for (let y = 0; y < blockSize; ++y, trgi += pitch) {\n        for (let x = 0; x < blockSize; ++x) {\n          trg[trgi + x] = col\n        }\n      }\n    }\n  \n    function distYCbCr (pix1, pix2, lumaWeight) {\n      const r_diff = ((pix1 & redMask) - (pix2 & redMask)) >> 16\n      const g_diff = ((pix1 & greenMask) - (pix2 & greenMask)) >> 8\n      const b_diff = ((pix1 & blueMask) - (pix2 & blueMask))\n  \n      const k_b = 0.0722, k_r = 0.2126, k_g = 1 - k_b - k_r\n      const scale_b = 0.5 / (1 - k_b), scale_r = 0.5 / (1 - k_r)\n  \n      const y = k_r * r_diff + k_g * g_diff + k_b * b_diff\n      const c_b = scale_b * (b_diff - y)\n      const c_r = scale_r * (r_diff - y)\n      return square(lumaWeight * y) + square(c_b) + square(c_r)\n    }\n  \n    function colorDist (pix1, pix2, luminanceWeight) {\n      if (pix1 === pix2) {\n        return 0\n      }\n      return distYCbCr(pix1, pix2, luminanceWeight)\n    }\n  \n    let config = {\n      dominantDirectionThreshold: 3.6,\n      luminanceWeight: 1.0,\n      equalColorTolerance: 30.0,\n      steepDirectionThreshold: 2.2\n    }\n  \n    function preProcessCorners_colorDist_ (col1, col2) {\n      col1 = col1 & 0xffffffff\n      col2 = col2 & 0xffffffff\n      return colorDist(col1, col2, config.luminanceWeight)\n    }\n  \n    const eqColorThres = square(config.equalColorTolerance)\n  \n    function scalePixel_colorEq_ (col1, col2) {\n      return colorDist(col1, col2, config.luminanceWeight) < eqColorThres\n    }\n  \n    function scalePixel_colorDist_ (col1, col2) {\n      return colorDist(col1, col2, config.luminanceWeight)\n    }\n  \n    function buildMatrixRotation (rotDeg, I, J, N) {\n      let I_old = 0, J_old = 0\n      if (rotDeg === 0) {\n        I_old = I\n        J_old = J\n      } else {\n        const old = buildMatrixRotation(rotDeg - 1, I, J, N)\n        I_old = N - 1 - old.J\n        J_old = old.I\n      }\n      return { I: I_old, J: J_old }\n    }\n  \n    let matrixRotation = (function () {\n      let matrixRotation = []\n      for (let n = 2; n < maxScale + 1; n++) {\n        for (let r = 0; r < maxRots; r++) {\n          let nr = (n - 2) * (maxRots * maxScaleSq) + r * maxScaleSq\n          for (let i = 0; i < maxScale; i++) {\n            for (let j = 0; j < maxScale; j++) {\n              matrixRotation[nr + i * maxScale + j] = buildMatrixRotation(r, i, j, n)\n            }\n          }\n        }\n      }\n      return matrixRotation\n    })()\n  \n    function preProcessCorners (ker4x4) {\n      blendResult.reset()\n      if ((ker4x4.f === ker4x4.g && ker4x4.j === ker4x4.k) ||\n          (ker4x4.f === ker4x4.j && ker4x4.g === ker4x4.k)) {\n        return\n      }\n  \n      const dist = preProcessCorners_colorDist_\n  \n      const weight = 4\n      const jg =\n          dist(ker4x4.i, ker4x4.f) +\n          dist(ker4x4.f, ker4x4.c) +\n          dist(ker4x4.n, ker4x4.k) +\n          dist(ker4x4.k, ker4x4.h) +\n          weight * dist(ker4x4.j, ker4x4.g)\n      const fk =\n          dist(ker4x4.e, ker4x4.j) +\n          dist(ker4x4.j, ker4x4.o) +\n          dist(ker4x4.b, ker4x4.g) +\n          dist(ker4x4.g, ker4x4.l) +\n          weight * dist(ker4x4.f, ker4x4.k)\n  \n      const dominantGradient = config.dominantDirectionThreshold * jg < fk\n      if (jg < fk) {\n        if (ker4x4.f !== ker4x4.g && ker4x4.f !== ker4x4.j) {\n          blendResult.f = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n        if (ker4x4.k !== ker4x4.g && ker4x4.k !== ker4x4.j) {\n          blendResult.k = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n      } else if (fk < jg) {\n        if (ker4x4.j !== ker4x4.f && ker4x4.j !== ker4x4.k) {\n          blendResult.j = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n        if (ker4x4.g !== ker4x4.f && ker4x4.g !== ker4x4.k) {\n          blendResult.g = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n      }\n    }\n  \n    const BlendInfo = {\n      getTopL (b) {\n        return (b & 0x3) & 0xff\n      },\n      getTopR (b) {\n        return ((b >> 2) & 0x3) & 0xff\n      },\n      getBottomR (b) {\n        return ((b >> 4) & 0x3) & 0xff\n      },\n      getBottomL (b) {\n        return ((b >> 6) & 0x3) & 0xff\n      },\n      setTopL (b, bt) {\n        return (b | bt) & 0xff\n      },\n      setTopR (b, bt) {\n        return (b | bt << 2) & 0xff\n      },\n      setBottomR (b, bt) {\n        return (b | bt << 4) & 0xff\n      },\n      setBottomL (b, bt) {\n        return (b | (bt << 6)) & 0xff\n      },\n      rotate (b, rotDeg) {\n        // assert rotDeg >= 0 && rotDeg < 4 : "RotationDegree enum does not have type: " + rotDeg;\n        const l = rotDeg << 1\n        const r = 8 - l\n        return (b << l | b >> r) & 0xff\n      }\n    }\n  \n    let outputMatrix\n  \n    function scalePixel (scaler, rotDeg, ker3x3, trg, trgi, trgWidth, blendInfo) {\n      const b = ker3x3[Rot[(1 << 2) + rotDeg]]\n      const c = ker3x3[Rot[(2 << 2) + rotDeg]]\n      const d = ker3x3[Rot[(3 << 2) + rotDeg]]\n      const e = ker3x3[Rot[(4 << 2) + rotDeg]]\n      const f = ker3x3[Rot[(5 << 2) + rotDeg]]\n      const g = ker3x3[Rot[(6 << 2) + rotDeg]]\n      const h = ker3x3[Rot[(7 << 2) + rotDeg]]\n      const i = ker3x3[Rot[(8 << 2) + rotDeg]]\n  \n      const blend = BlendInfo.rotate(blendInfo, rotDeg)\n      if (BlendInfo.getBottomR(blend) === BlendType.BLEND_NONE) {\n        return\n      }\n  \n      const eq = scalePixel_colorEq_\n      const dist = scalePixel_colorDist_\n  \n      let doLineBlend\n  \n      if (BlendInfo.getBottomR(blend) >= BlendType.BLEND_DOMINANT) {\n        doLineBlend = true\n      } else if (BlendInfo.getTopR(blend) !== BlendType.BLEND_NONE && !eq(e, g)) {\n        doLineBlend = false\n      } else if (BlendInfo.getBottomL(blend) !== BlendType.BLEND_NONE && !eq(e, c)) {\n        doLineBlend = false\n      } else {\n        doLineBlend = !(eq(g, h) && eq(h, i) && eq(i, f) && eq(f, c) && !eq(e, i))\n      }\n  \n      const px = dist(e, f) <= dist(e, h) ? f : h\n  \n      const out = outputMatrix\n      out.move(rotDeg, trgi)\n  \n      if (!doLineBlend) {\n        scaler.blendCorner(px, out)\n        return\n      }\n  \n      const fg = dist(f, g)\n      const hc = dist(h, c)\n  \n      const haveShallowLine = config.steepDirectionThreshold * fg <= hc && e !== g && d !== g\n      const haveSteepLine = config.steepDirectionThreshold * hc <= fg && e !== c && b !== c\n  \n      if (haveShallowLine) {\n        if (haveSteepLine) {\n          scaler.blendLineSteepAndShallow(px, out)\n        } else {\n          scaler.blendLineShallow(px, out)\n        }\n      } else {\n        if (haveSteepLine) {\n          scaler.blendLineSteep(px, out)\n        } else {\n          scaler.blendLineDiagonal(px, out)\n        }\n      }\n    }\n  \n    function scaleImage (scaleSize, src, trg, srcWidth, srcHeight, yFirst, yLast) {\n      yFirst = Math.max(yFirst, 0)\n      yLast = Math.min(yLast, srcHeight)\n  \n      if (yFirst >= yLast || srcWidth <= 0) {\n        return\n      }\n  \n      const trgWidth = srcWidth * scaleSize\n  \n      let preProcBuffer = []\n      let ker4 = {\n        a: 0, b: 0, c: 0, d: 0,\n        e: 0, f: 0, g: 0, h: 0,\n        i: 0, j: 0, k: 0, l: 0,\n        m: 0, n: 0, o: 0, p: 0,\n      }\n  \n      if (yFirst > 0) {\n        const y = yFirst - 1\n        const s_m1 = srcWidth * Math.max(y - 1, 0)\n        const s_0 = srcWidth * y\n        const s_p1 = srcWidth * Math.min(y + 1, srcHeight - 1)\n        const s_p2 = srcWidth * Math.min(y + 2, srcHeight - 1)\n  \n        for (let x = 0; x < srcWidth; ++x) {\n          const x_m1 = Math.max(x - 1, 0)\n          const x_p1 = Math.min(x + 1, srcWidth - 1)\n          const x_p2 = Math.min(x + 2, srcWidth - 1)\n  \n          ker4.a = src[s_m1 + x_m1]\n          ker4.b = src[s_m1 + x]\n          ker4.c = src[s_m1 + x_p1]\n          ker4.d = src[s_m1 + x_p2]\n  \n          ker4.e = src[s_0 + x_m1]\n          ker4.f = src[s_0 + x]\n          ker4.g = src[s_0 + x_p1]\n          ker4.h = src[s_0 + x_p2]\n  \n          ker4.i = src[s_p1 + x_m1]\n          ker4.j = src[s_p1 + x]\n          ker4.k = src[s_p1 + x_p1]\n          ker4.l = src[s_p1 + x_p2]\n  \n          ker4.m = src[s_p2 + x_m1]\n          ker4.n = src[s_p2 + x]\n          ker4.o = src[s_p2 + x_p1]\n          ker4.p = src[s_p2 + x_p2]\n  \n          preProcessCorners(ker4)\n  \n          preProcBuffer[x] = BlendInfo.setTopR(preProcBuffer[x], blendResult.j)\n          if (x + 1 < srcWidth) {\n            preProcBuffer[x + 1] = BlendInfo.setTopL(preProcBuffer[x + 1] & 0xff, blendResult.k)\n          }\n        }\n      }\n  \n      outputMatrix = new OutputMatrix(scaleSize, trg, trgWidth)\n  \n      let blend_xy = 0\n      let blend_xy1 = 0\n  \n      let ker3 = []\n  \n      for (let y = yFirst; y < yLast; ++y) {\n        let trgi = scaleSize * y * trgWidth\n        const s_m1 = srcWidth * Math.max(y - 1, 0)\n        const s_0 = srcWidth * y\n        const s_p1 = srcWidth * Math.min(y + 1, srcHeight - 1)\n        const s_p2 = srcWidth * Math.min(y + 2, srcHeight - 1)\n  \n        blend_xy1 = 0\n  \n        for (let x = 0; x < srcWidth; ++x, trgi += scaleSize) {\n          const x_m1 = Math.max(x - 1, 0)\n          const x_p1 = Math.min(x + 1, srcWidth - 1)\n          const x_p2 = Math.min(x + 2, srcWidth - 1)\n          {\n            ker4.a = src[s_m1 + x_m1]\n            ker4.b = src[s_m1 + x]\n            ker4.c = src[s_m1 + x_p1]\n            ker4.d = src[s_m1 + x_p2]\n  \n            ker4.e = src[s_0 + x_m1]\n            ker4.f = src[s_0 + x]\n            ker4.g = src[s_0 + x_p1]\n            ker4.h = src[s_0 + x_p2]\n  \n            ker4.i = src[s_p1 + x_m1]\n            ker4.j = src[s_p1 + x]\n            ker4.k = src[s_p1 + x_p1]\n            ker4.l = src[s_p1 + x_p2]\n  \n            ker4.m = src[s_p2 + x_m1]\n            ker4.n = src[s_p2 + x]\n            ker4.o = src[s_p2 + x_p1]\n            ker4.p = src[s_p2 + x_p2]\n            preProcessCorners(ker4)\n  \n            blend_xy = BlendInfo.setBottomR(preProcBuffer[x], blendResult.f)\n            blend_xy1 = BlendInfo.setTopR(blend_xy1, blendResult.j)\n            preProcBuffer[x] = blend_xy1\n  \n            blend_xy1 = BlendInfo.setTopL(0, blendResult.k)\n            if (x + 1 < srcWidth) {\n              preProcBuffer[x + 1] = BlendInfo.setBottomL(preProcBuffer[x + 1], blendResult.g)\n            }\n          }\n  \n          fillBlock(trg, trgi, trgWidth, src[s_0 + x], scaleSize)\n  \n          if (blend_xy === 0) {\n            continue\n          }\n  \n          const a = 0, b = 1, c = 2, d = 3, e = 4, f = 5, g = 6, h = 7, i = 8\n  \n          ker3[a] = src[s_m1 + x_m1]\n          ker3[b] = src[s_m1 + x]\n          ker3[c] = src[s_m1 + x_p1]\n  \n          ker3[d] = src[s_0 + x_m1]\n          ker3[e] = src[s_0 + x]\n          ker3[f] = src[s_0 + x_p1]\n  \n          ker3[g] = src[s_p1 + x_m1]\n          ker3[h] = src[s_p1 + x]\n          ker3[i] = src[s_p1 + x_p1]\n  \n          let scaler\n          switch (scaleSize) {\n            case 2:\n              scaler = new Scaler2x()\n              break\n            case 3:\n              scaler = new Scaler3x()\n              break\n            case 4:\n              scaler = new Scaler4x()\n              break\n            case 5:\n              scaler = new Scaler5x()\n              break\n            case 6:\n              scaler = new Scaler6x()\n              break\n            default:\n              scaler = new Scaler6x()\n              break\n          }\n  \n          scalePixel(scaler, 0, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 1, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 2, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 3, ker3, trg, trgi, trgWidth, blend_xy)\n        }\n      }\n    }\n    \n    const source_buffer = Array.from(image_data.data);\n    let source = [];\n    for (let i = 0, len = source_buffer.length; i < len; i += 4) {\n        const r = source_buffer[i];\n        const g = source_buffer[i + 1];\n        const b = source_buffer[i + 2];\n        const a = source_buffer[i + 3];\n        const pixel = a << 24 | r << 16 | g << 8 | b;\n        source.push(pixel)\n    }\n  \n    let target = new Array(image_data.width * scale * image_data.height * scale);\n    target.fill(0);\n    scaleImage(scale, source, target, image_data.width, image_data.height, 0, image_data.height);\n  \n    let target_buffer = [];\n    for (let i = 0, len = target.length; i < len; ++i) {\n      const pixel = target[i];\n      const a = (pixel >> 24) & 0xff;\n      const r = (pixel >> 16) & 0xff;\n      const g = (pixel >> 8) & 0xff;\n      const b = (pixel) & 0xff;\n      target_buffer.push(r);\n      target_buffer.push(g);\n      target_buffer.push(b);\n      target_buffer.push(a);\n    }\n  \n    const data_array_target = new Uint8ClampedArray(target_buffer);\n    const final_image_data = new ImageData(data_array_target, image_data.width * scale, image_data.height * scale);\n    return final_image_data;\n  }',n.exports={xbrz:function e(t,l,o){var s=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s?s.exec(new Function(window.xbrz_process_function_string)(),[t,l]).catch(function(n){return"Pool terminated"!==n?new Function(window.xbrz_process_function_string)()(t,l):void e(t,l,o,s)}).then(function(n){o(n)}).then(function(){s.terminate()}).timeout(1e4):new Function(window.xbrz_process_function_string)()(t,l).then(function(n){o(n)})}}}}]);