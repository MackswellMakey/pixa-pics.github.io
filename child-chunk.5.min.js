(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{646:function(t,A,n){"use strict";!function(t){var a=n(647),s=n(648),o=n(649);function e(){return Buffer.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function r(t,n){if(e()<n)throw new RangeError("Invalid typed array length");return Buffer.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(n)).__proto__=Buffer.prototype:(t=null===t?new Buffer(n):t).length=n,t}function Buffer(t,n,e){if(!(Buffer.TYPED_ARRAY_SUPPORT||this instanceof Buffer))return new Buffer(t,n,e);if("number"!=typeof t)return i(this,t,n,e);if("string"==typeof n)throw new Error("If encoding is specified then the first argument must be a string");return c(this,t)}function i(t,n,e,i){if("number"==typeof n)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&n instanceof ArrayBuffer?function(t,n,e,i){if(n.byteLength,e<0||n.byteLength<e)throw new RangeError("'offset' is out of bounds");if(n.byteLength<e+(i||0))throw new RangeError("'length' is out of bounds");return n=void 0===e&&void 0===i?new Uint8Array(n):void 0===i?new Uint8Array(n,e):new Uint8Array(n,e,i),Buffer.TYPED_ARRAY_SUPPORT?(t=n).__proto__=Buffer.prototype:t=p(t,n),t}(t,n,e,i):"string"==typeof n?function(t,n,e){if(!Buffer.isEncoding(e="string"!=typeof e||""===e?"utf8":e))throw new TypeError('"encoding" must be a valid string encoding');var i=0|d(n,e),e=(t=r(t,i)).write(n,e);return e!==i?t.slice(0,e):t}(t,n,e):function(t,n){if(Buffer.isBuffer(n)){var e=0|h(n.length);return 0===(t=r(t,e)).length||n.copy(t,0,0,e),t}if(n){if("undefined"!=typeof ArrayBuffer&&n.buffer instanceof ArrayBuffer||"length"in n)return"number"!=typeof n.length||(e=n.length)!=e?r(t,0):p(t,n);if("Buffer"===n.type&&o(n.data))return p(t,n.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,n)}function l(t){if("number"!=typeof t)throw new TypeError('"size" argument must be a number');if(t<0)throw new RangeError('"size" argument must not be negative')}function c(t,n){if(l(n),t=r(t,n<0?0:0|h(n)),!Buffer.TYPED_ARRAY_SUPPORT)for(var e=0;e<n;++e)t[e]=0;return t}function p(t,n){var e=n.length<0?0:0|h(n.length);t=r(t,e);for(var i=0;i<e;i+=1)t[i]=255&n[i];return t}function h(t){if(t>=e())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+e().toString(16)+" bytes");return 0|t}function d(t,n){if(Buffer.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;var e=(t="string"!=typeof t?""+t:t).length;if(0===e)return 0;for(var i=!1;;)switch(n){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":case void 0:return I(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*e;case"hex":return e>>>1;case"base64":return P(t).length;default:if(i)return I(t).length;n=(""+n).toLowerCase(),i=!0}}function u(t,n,e){var i=t[n];t[n]=t[e],t[e]=i}function f(t,n,e,i,r){if(0===t.length)return-1;if("string"==typeof e?(i=e,e=0):2147483647<e?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,(e=(e=isNaN(e)?r?0:t.length-1:e)<0?t.length+e:e)>=t.length){if(r)return-1;e=t.length-1}else if(e<0){if(!r)return-1;e=0}if("string"==typeof n&&(n=Buffer.from(n,i)),Buffer.isBuffer(n))return 0===n.length?-1:x(t,n,e,i,r);if("number"==typeof n)return n&=255,Buffer.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?(r?Uint8Array.prototype.indexOf:Uint8Array.prototype.lastIndexOf).call(t,n,e):x(t,[n],e,i,r);throw new TypeError("val must be string, number or Buffer")}function x(t,n,e,i,r){var s=1,a=t.length,o=n.length;if(void 0!==i&&("ucs2"===(i=String(i).toLowerCase())||"ucs-2"===i||"utf16le"===i||"utf-16le"===i)){if(t.length<2||n.length<2)return-1;a/=s=2,o/=2,e/=2}function l(t,n){return 1===s?t[n]:t.readUInt16BE(n*s)}if(r)for(var c=-1,p=e;p<a;p++)if(l(t,p)===l(n,-1===c?0:p-c)){if(p-(c=-1===c?p:c)+1===o)return c*s}else-1!==c&&(p-=p-c),c=-1;else for(p=e=a<e+o?a-o:e;0<=p;p--){for(var h=!0,d=0;d<o;d++)if(l(t,p+d)!==l(n,d)){h=!1;break}if(h)return p}return-1}function m(t,n,e,i){return q(function(t){for(var n=[],e=0;e<t.length;++e)n.push(255&t.charCodeAt(e));return n}(n),t,e,i)}function g(t,n,e){e=Math.min(t.length,e);for(var i=[],r=n;r<e;){var s,a,o,l,c=t[r],p=null,h=239<c?4:223<c?3:191<c?2:1;if(r+h<=e)switch(h){case 1:c<128&&(p=c);break;case 2:128==(192&(s=t[r+1]))&&127<(l=(31&c)<<6|63&s)&&(p=l);break;case 3:s=t[r+1],a=t[r+2],128==(192&s)&&128==(192&a)&&2047<(l=(15&c)<<12|(63&s)<<6|63&a)&&(l<55296||57343<l)&&(p=l);break;case 4:s=t[r+1],a=t[r+2],o=t[r+3],128==(192&s)&&128==(192&a)&&128==(192&o)&&65535<(l=(15&c)<<18|(63&s)<<12|(63&a)<<6|63&o)&&l<1114112&&(p=l)}null===p?(p=65533,h=1):65535<p&&(p-=65536,i.push(p>>>10&1023|55296),p=56320|1023&p),i.push(p),r+=h}return function(t){var n=t.length;if(n<=y)return String.fromCharCode.apply(String,t);for(var e="",i=0;i<n;)e+=String.fromCharCode.apply(String,t.slice(i,i+=y));return e}(i)}A.Buffer=Buffer,A.SlowBuffer=function(t){return Buffer.alloc(+(t=+t!=t?0:t))},A.INSPECT_MAX_BYTES=50,Buffer.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),A.kMaxLength=e(),Buffer.poolSize=8192,Buffer._augment=function(t){return t.__proto__=Buffer.prototype,t},Buffer.from=function(t,n,e){return i(null,t,n,e)},Buffer.TYPED_ARRAY_SUPPORT&&(Buffer.prototype.__proto__=Uint8Array.prototype,Buffer.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&Buffer[Symbol.species]===Buffer&&Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:!0})),Buffer.alloc=function(t,n,e){return n=n,e=e,l(t=t),t<=0||void 0===n?r(null,t):"string"==typeof e?r(null,t).fill(n,e):r(null,t).fill(n)},Buffer.allocUnsafe=function(t){return c(null,t)},Buffer.allocUnsafeSlow=function(t){return c(null,t)},Buffer.isBuffer=function(t){return!(null==t||!t._isBuffer)},Buffer.compare=function(t,n){if(!Buffer.isBuffer(t)||!Buffer.isBuffer(n))throw new TypeError("Arguments must be Buffers");if(t===n)return 0;for(var e=t.length,i=n.length,r=0,s=Math.min(e,i);r<s;++r)if(t[r]!==n[r]){e=t[r],i=n[r];break}return e<i?-1:i<e?1:0},Buffer.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function(t,n){if(!o(t))throw new TypeError('"list" argument must be an Array of Buffers');if(0===t.length)return Buffer.alloc(0);if(void 0===n)for(r=n=0;r<t.length;++r)n+=t[r].length;for(var e=Buffer.allocUnsafe(n),i=0,r=0;r<t.length;++r){var s=t[r];if(!Buffer.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(e,i),i+=s.length}return e},Buffer.byteLength=d,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var n=0;n<t;n+=2)u(this,n,n+1);return this},Buffer.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var n=0;n<t;n+=4)u(this,n,n+3),u(this,n+1,n+2);return this},Buffer.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var n=0;n<t;n+=8)u(this,n,n+7),u(this,n+1,n+6),u(this,n+2,n+5),u(this,n+3,n+4);return this},Buffer.prototype.toString=function(){var t=0|this.length;return 0==t?"":0===arguments.length?g(this,0,t):function(t,n,e){var i,r,s=!1;if((n=void 0===n||n<0?0:n)>this.length)return"";if((e=void 0===e||e>this.length?this.length:e)<=0)return"";if((e>>>=0)<=(n>>>=0))return"";for(t=t||"utf8";;)switch(t){case"hex":return function(t,n,e){var i=t.length;(!e||e<0||i<e)&&(e=i);for(var r,s="",a=n=!n||n<0?0:n;a<e;++a)s+=(r=t[a])<16?"0"+r.toString(16):r.toString(16);return s}(this,n,e);case"utf8":case"utf-8":return g(this,n,e);case"ascii":return function(t,n,e){var i="";e=Math.min(t.length,e);for(var r=n;r<e;++r)i+=String.fromCharCode(127&t[r]);return i}(this,n,e);case"latin1":case"binary":return function(t,n,e){var i="";e=Math.min(t.length,e);for(var r=n;r<e;++r)i+=String.fromCharCode(t[r]);return i}(this,n,e);case"base64":return r=e,0===(i=n)&&r===this.length?a.fromByteArray(this):a.fromByteArray(this.slice(i,r));case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return function(t,n,e){for(var i=t.slice(n,e),r="",s=0;s<i.length;s+=2)r+=String.fromCharCode(i[s]+256*i[s+1]);return r}(this,n,e);default:if(s)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),s=!0}}.apply(this,arguments)},Buffer.prototype.equals=function(t){if(!Buffer.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===Buffer.compare(this,t)},Buffer.prototype.inspect=function(){var t="",n=A.INSPECT_MAX_BYTES;return 0<this.length&&(t=this.toString("hex",0,n).match(/.{2}/g).join(" "),this.length>n&&(t+=" ... ")),"<Buffer "+t+">"},Buffer.prototype.compare=function(t,n,e,i,r){if(!Buffer.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=t?t.length:0),void 0===i&&(i=0),void 0===r&&(r=this.length),(n=void 0===n?0:n)<0||e>t.length||i<0||r>this.length)throw new RangeError("out of range index");if(r<=i&&e<=n)return 0;if(r<=i)return-1;if(e<=n)return 1;if(this===t)return 0;for(var s=(r>>>=0)-(i>>>=0),a=(e>>>=0)-(n>>>=0),o=Math.min(s,a),l=this.slice(i,r),c=t.slice(n,e),p=0;p<o;++p)if(l[p]!==c[p]){s=l[p],a=c[p];break}return s<a?-1:a<s?1:0},Buffer.prototype.includes=function(t,n,e){return-1!==this.indexOf(t,n,e)},Buffer.prototype.indexOf=function(t,n,e){return f(this,t,n,e,!0)},Buffer.prototype.lastIndexOf=function(t,n,e){return f(this,t,n,e,!1)},Buffer.prototype.write=function(t,o,n,e){if(void 0===o)e="utf8",n=this.length,o=0;else if(void 0===n&&"string"==typeof o)e=o,n=this.length,o=0;else{if(!isFinite(o))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");o|=0,isFinite(n)?(n|=0,void 0===e&&(e="utf8")):(e=n,n=void 0)}var i=this.length-o;if((void 0===n||i<n)&&(n=i),0<t.length&&(n<0||o<0)||o>this.length)throw new RangeError("Attempt to write outside buffer bounds");e=e||"utf8";for(var r,s,a,l,c=!1;;)switch(e){case"hex":return function(t,n,e,i){e=Number(o)||0;var r=t.length-e;(!i||r<(i=Number(i)))&&(i=r);r=n.length;if(r%2!=0)throw new TypeError("Invalid hex string");r/2<i&&(i=r/2);for(var s=0;s<i;++s){var a=parseInt(n.substr(2*s,2),16);if(isNaN(a))return s;t[e+s]=a}return s}(this,t,0,n);case"utf8":case"utf-8":return r=o,s=n,q(I(t,this.length-r),this,r,s);case"ascii":return m(this,t,o,n);case"latin1":case"binary":return m(this,t,o,n);case"base64":return a=o,l=n,q(P(t),this,a,l);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return a=o,l=n,q(function(t,n){for(var e,i,r=[],s=0;s<t.length&&!((n-=2)<0);++s)i=(e=t.charCodeAt(s))>>8,r.push(e%256),r.push(i);return r}(t,this.length-a),this,a,l);default:if(c)throw new TypeError("Unknown encoding: "+e);e=(""+e).toLowerCase(),c=!0}},Buffer.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var y=4096;function b(t,n,e){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(e<t+n)throw new RangeError("Trying to access beyond buffer length")}function v(t,n,e,i,r,s){if(!Buffer.isBuffer(t))throw new TypeError('"buffer" argument must be a Buffer instance');if(r<n||n<s)throw new RangeError('"value" argument is out of bounds');if(e+i>t.length)throw new RangeError("Index out of range")}function w(t,n,e,i){n<0&&(n=65535+n+1);for(var r=0,s=Math.min(t.length-e,2);r<s;++r)t[e+r]=(n&255<<8*(i?r:1-r))>>>8*(i?r:1-r)}function _(t,n,e,i){n<0&&(n=4294967295+n+1);for(var r=0,s=Math.min(t.length-e,4);r<s;++r)t[e+r]=n>>>8*(i?r:3-r)&255}function C(t,n,e,i){if(e+i>t.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function k(t,n,e,i,r){return r||C(t,0,e,4),s.write(t,n,e,i,23,4),e+4}function B(t,n,e,i,r){return r||C(t,0,e,8),s.write(t,n,e,i,52,8),e+8}Buffer.prototype.slice=function(t,n){var e=this.length;if((t=~~t)<0?(t+=e)<0&&(t=0):e<t&&(t=e),(n=void 0===n?e:~~n)<0?(n+=e)<0&&(n=0):e<n&&(n=e),n<t&&(n=t),Buffer.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,n)).__proto__=Buffer.prototype;else for(var i=n-t,r=new Buffer(i,void 0),s=0;s<i;++s)r[s]=this[s+t];return r},Buffer.prototype.readUIntLE=function(t,n,e){t|=0,n|=0,e||b(t,n,this.length);for(var i=this[t],r=1,s=0;++s<n&&(r*=256);)i+=this[t+s]*r;return i},Buffer.prototype.readUIntBE=function(t,n,e){t|=0,n|=0,e||b(t,n,this.length);for(var i=this[t+--n],r=1;0<n&&(r*=256);)i+=this[t+--n]*r;return i},Buffer.prototype.readUInt8=function(t,n){return n||b(t,1,this.length),this[t]},Buffer.prototype.readUInt16LE=function(t,n){return n||b(t,2,this.length),this[t]|this[t+1]<<8},Buffer.prototype.readUInt16BE=function(t,n){return n||b(t,2,this.length),this[t]<<8|this[t+1]},Buffer.prototype.readUInt32LE=function(t,n){return n||b(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},Buffer.prototype.readUInt32BE=function(t,n){return n||b(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},Buffer.prototype.readIntLE=function(t,n,e){t|=0,n|=0,e||b(t,n,this.length);for(var i=this[t],r=1,s=0;++s<n&&(r*=256);)i+=this[t+s]*r;return(r*=128)<=i&&(i-=Math.pow(2,8*n)),i},Buffer.prototype.readIntBE=function(t,n,e){t|=0,n|=0,e||b(t,n,this.length);for(var i=n,r=1,s=this[t+--i];0<i&&(r*=256);)s+=this[t+--i]*r;return(r*=128)<=s&&(s-=Math.pow(2,8*n)),s},Buffer.prototype.readInt8=function(t,n){return n||b(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},Buffer.prototype.readInt16LE=function(t,n){n||b(t,2,this.length);t=this[t]|this[t+1]<<8;return 32768&t?4294901760|t:t},Buffer.prototype.readInt16BE=function(t,n){n||b(t,2,this.length);t=this[t+1]|this[t]<<8;return 32768&t?4294901760|t:t},Buffer.prototype.readInt32LE=function(t,n){return n||b(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},Buffer.prototype.readInt32BE=function(t,n){return n||b(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},Buffer.prototype.readFloatLE=function(t,n){return n||b(t,4,this.length),s.read(this,t,!0,23,4)},Buffer.prototype.readFloatBE=function(t,n){return n||b(t,4,this.length),s.read(this,t,!1,23,4)},Buffer.prototype.readDoubleLE=function(t,n){return n||b(t,8,this.length),s.read(this,t,!0,52,8)},Buffer.prototype.readDoubleBE=function(t,n){return n||b(t,8,this.length),s.read(this,t,!1,52,8)},Buffer.prototype.writeUIntLE=function(t,n,e,i){t=+t,n|=0,e|=0,i||v(this,t,n,e,Math.pow(2,8*e)-1,0);var r=1,s=0;for(this[n]=255&t;++s<e&&(r*=256);)this[n+s]=t/r&255;return n+e},Buffer.prototype.writeUIntBE=function(t,n,e,i){t=+t,n|=0,e|=0,i||v(this,t,n,e,Math.pow(2,8*e)-1,0);var r=e-1,s=1;for(this[n+r]=255&t;0<=--r&&(s*=256);)this[n+r]=t/s&255;return n+e},Buffer.prototype.writeUInt8=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,1,255,0),Buffer.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[n]=255&t,n+1},Buffer.prototype.writeUInt16LE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):w(this,t,n,!0),n+2},Buffer.prototype.writeUInt16BE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):w(this,t,n,!1),n+2},Buffer.prototype.writeUInt32LE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[n+3]=t>>>24,this[n+2]=t>>>16,this[n+1]=t>>>8,this[n]=255&t):_(this,t,n,!0),n+4},Buffer.prototype.writeUInt32BE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):_(this,t,n,!1),n+4},Buffer.prototype.writeIntLE=function(t,n,e,i){t=+t,n|=0,i||v(this,t,n,e,(i=Math.pow(2,8*e-1))-1,-i);var r=0,s=1,a=0;for(this[n]=255&t;++r<e&&(s*=256);)t<0&&0===a&&0!==this[n+r-1]&&(a=1),this[n+r]=(t/s>>0)-a&255;return n+e},Buffer.prototype.writeIntBE=function(t,n,e,i){t=+t,n|=0,i||v(this,t,n,e,(i=Math.pow(2,8*e-1))-1,-i);var r=e-1,s=1,a=0;for(this[n+r]=255&t;0<=--r&&(s*=256);)t<0&&0===a&&0!==this[n+r+1]&&(a=1),this[n+r]=(t/s>>0)-a&255;return n+e},Buffer.prototype.writeInt8=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,1,127,-128),Buffer.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[n]=255&(t=t<0?255+t+1:t),n+1},Buffer.prototype.writeInt16LE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8):w(this,t,n,!0),n+2},Buffer.prototype.writeInt16BE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=t>>>8,this[n+1]=255&t):w(this,t,n,!1),n+2},Buffer.prototype.writeInt32LE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,4,2147483647,-2147483648),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=255&t,this[n+1]=t>>>8,this[n+2]=t>>>16,this[n+3]=t>>>24):_(this,t,n,!0),n+4},Buffer.prototype.writeInt32BE=function(t,n,e){return t=+t,n|=0,e||v(this,t,n,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),Buffer.TYPED_ARRAY_SUPPORT?(this[n]=t>>>24,this[n+1]=t>>>16,this[n+2]=t>>>8,this[n+3]=255&t):_(this,t,n,!1),n+4},Buffer.prototype.writeFloatLE=function(t,n,e){return k(this,t,n,!0,e)},Buffer.prototype.writeFloatBE=function(t,n,e){return k(this,t,n,!1,e)},Buffer.prototype.writeDoubleLE=function(t,n,e){return B(this,t,n,!0,e)},Buffer.prototype.writeDoubleBE=function(t,n,e){return B(this,t,n,!1,e)},Buffer.prototype.copy=function(t,n,e,i){if(e=e||0,i||0===i||(i=this.length),n>=t.length&&(n=t.length),(i=0<i&&i<e?e:i)===e)return 0;if(0===t.length||0===this.length)return 0;if((n=n||0)<0)throw new RangeError("targetStart out of bounds");if(e<0||e>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");i>this.length&&(i=this.length);var r,s=(i=t.length-n<i-e?t.length-n+e:i)-e;if(this===t&&e<n&&n<i)for(r=s-1;0<=r;--r)t[r+n]=this[r+e];else if(s<1e3||!Buffer.TYPED_ARRAY_SUPPORT)for(r=0;r<s;++r)t[r+n]=this[r+e];else Uint8Array.prototype.set.call(t,this.subarray(e,e+s),n);return s},Buffer.prototype.fill=function(t,n,e,i){if("string"==typeof t){var r;if("string"==typeof n?(i=n,n=0,e=this.length):"string"==typeof e&&(i=e,e=this.length),1!==t.length||(r=t.charCodeAt(0))<256&&(t=r),void 0!==i&&"string"!=typeof i)throw new TypeError("encoding must be a string");if("string"==typeof i&&!Buffer.isEncoding(i))throw new TypeError("Unknown encoding: "+i)}else"number"==typeof t&&(t&=255);if(n<0||this.length<n||this.length<e)throw new RangeError("Out of range index");if(e<=n)return this;if(n>>>=0,e=void 0===e?this.length:e>>>0,"number"==typeof(t=t||0))for(o=n;o<e;++o)this[o]=t;else for(var s=Buffer.isBuffer(t)?t:I(new Buffer(t,i).toString()),a=s.length,o=0;o<e-n;++o)this[o+n]=s[o%a];return this};var R=/[^+\/0-9A-Za-z-_]/g;function I(t,n){var e;n=n||1/0;for(var i=t.length,r=null,s=[],a=0;a<i;++a){if(55295<(e=t.charCodeAt(a))&&e<57344){if(!r){if(56319<e){-1<(n-=3)&&s.push(239,191,189);continue}if(a+1===i){-1<(n-=3)&&s.push(239,191,189);continue}r=e;continue}if(e<56320){-1<(n-=3)&&s.push(239,191,189),r=e;continue}e=65536+(r-55296<<10|e-56320)}else r&&-1<(n-=3)&&s.push(239,191,189);if(r=null,e<128){if(--n<0)break;s.push(e)}else if(e<2048){if((n-=2)<0)break;s.push(e>>6|192,63&e|128)}else if(e<65536){if((n-=3)<0)break;s.push(e>>12|224,e>>6&63|128,63&e|128)}else{if(!(e<1114112))throw new Error("Invalid code point");if((n-=4)<0)break;s.push(e>>18|240,e>>12&63|128,e>>6&63|128,63&e|128)}}return s}function P(t){return a.toByteArray(function(t){var n;if((t=((n=t).trim?n.trim():n.replace(/^\s+|\s+$/g,"")).replace(R,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function q(t,n,e,i){for(var r=0;r<i&&!(r+e>=n.length||r>=t.length);++r)n[r+e]=t[r];return r}}.call(this,n(77))},647:function(t,n,e){"use strict";n.byteLength=function(t){var n=p(t),t=n[0],n=n[1];return 3*(t+n)/4-n},n.toByteArray=function(t){for(var n,e=p(t),i=e[0],e=e[1],r=new c(3*(i+e)/4-e),s=0,a=0<e?i-4:i,o=0;o<a;o+=4)n=l[t.charCodeAt(o)]<<18|l[t.charCodeAt(o+1)]<<12|l[t.charCodeAt(o+2)]<<6|l[t.charCodeAt(o+3)],r[s++]=n>>16&255,r[s++]=n>>8&255,r[s++]=255&n;return 2===e&&(n=l[t.charCodeAt(o)]<<2|l[t.charCodeAt(o+1)]>>4,r[s++]=255&n),1===e&&(n=l[t.charCodeAt(o)]<<10|l[t.charCodeAt(o+1)]<<4|l[t.charCodeAt(o+2)]>>2,r[s++]=n>>8&255,r[s++]=255&n),r},n.fromByteArray=function(t){for(var n,e=t.length,i=e%3,r=[],s=0,a=e-i;s<a;s+=16383)r.push(function(t,n){for(var e,i=[],r=s;r<n;r+=3)e=(t[r]<<16&16711680)+(t[r+1]<<8&65280)+(255&t[r+2]),i.push(o[e>>18&63]+o[e>>12&63]+o[e>>6&63]+o[63&e]);return i.join("")}(t,a<s+16383?a:s+16383));return 1==i?(n=t[e-1],r.push(o[n>>2]+o[n<<4&63]+"==")):2==i&&(n=(t[e-2]<<8)+t[e-1],r.push(o[n>>10]+o[n>>4&63]+o[n<<2&63]+"=")),r.join("")};for(var o=[],l=[],c="undefined"!=typeof Uint8Array?Uint8Array:Array,i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",r=0,s=i.length;r<s;++r)o[r]=i[r],l[i.charCodeAt(r)]=r;function p(t){var n=t.length;if(0<n%4)throw new Error("Invalid string. Length must be a multiple of 4");t=t.indexOf("=");return[t=-1===t?n:t,t===n?0:4-t%4]}l["-".charCodeAt(0)]=62,l["_".charCodeAt(0)]=63},648:function(t,n){n.read=function(t,n,e,i,r){var s,a,o=8*r-i-1,l=(1<<o)-1,c=l>>1,p=-7,h=e?r-1:0,d=e?-1:1,e=t[n+h];for(h+=d,s=e&(1<<-p)-1,e>>=-p,p+=o;0<p;s=256*s+t[n+h],h+=d,p-=8);for(a=s&(1<<-p)-1,s>>=-p,p+=i;0<p;a=256*a+t[n+h],h+=d,p-=8);if(0===s)s=1-c;else{if(s===l)return a?NaN:1/0*(e?-1:1);a+=Math.pow(2,i),s-=c}return(e?-1:1)*a*Math.pow(2,s-i)},n.write=function(t,n,e,i,r,s){var a,o,l=8*s-r-1,c=(1<<l)-1,p=c>>1,h=23===r?Math.pow(2,-24)-Math.pow(2,-77):0,d=i?0:s-1,u=i?1:-1,s=n<0||0===n&&1/n<0?1:0;for(n=Math.abs(n),isNaN(n)||n===1/0?(o=isNaN(n)?1:0,a=c):(a=Math.floor(Math.log(n)/Math.LN2),n*(i=Math.pow(2,-a))<1&&(a--,i*=2),2<=(n+=1<=a+p?h/i:h*Math.pow(2,1-p))*i&&(a++,i/=2),c<=a+p?(o=0,a=c):1<=a+p?(o=(n*i-1)*Math.pow(2,r),a+=p):(o=n*Math.pow(2,p-1)*Math.pow(2,r),a=0));8<=r;t[e+d]=255&o,d+=u,o/=256,r-=8);for(a=a<<r|o,l+=r;0<l;t[e+d]=255&a,d+=u,a/=256,l-=8);t[e+d-u]|=128*s}},649:function(t,n){var e={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==e.call(t)}},953:function(t,n,u){"use strict";var f=u(954),x=u(955),m=u(956),g=u(957),e=u(313),y=e&&e.__esModule?e:{default:e};t.exports={base64png_to_xbrz_svg:function(t,c,p){var h=3<arguments.length&&void 0!==arguments[3]?arguments[3]:[],d=4<arguments.length&&void 0!==arguments[4]?arguments[4]:"xbrz",n=new Image;n.onload=function(){var n=document.createElement("canvas"),o=n.getContext("2d"),l=new Image;l.onload=function(){var e=l.width,i=l.height;function r(t,n){(0,m.image_tracer)(t,{pal:h.map(function(t){return{r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16),a:parseInt(t.slice(7,9),16)}}),corsenabled:!1,ltres:n,qtres:n,pathomit:n,rightangleenhance:!1,colorsampling:2,numberofcolors:512,mincolorratio:0,colorquantcycles:1,layering:0,strokewidth:3,linefilter:!0,scale:1,roundcoords:0,viewbox:!0,desc:!1,lcpr:0,qcpr:0,blurradius:0,blurdelta:20},function(t){t=(0,g.optimize)(t,{path:"path-to.svg",multipass:!0,plugin:["mergePaths"]}).data;p("data:image/svg+xml;base64,"+window.btoa(t),e*n,i*n)})}n.width=e,n.height=i,o.drawImage(l,0,0,e,i);var s,a,t=o.getImageData(0,0,e,i);"omniscale"===d?(s=document.createElement("canvas"),(0,x.omniscale)(t,6,function(t){s.width=t.width,s.height=t.height;var n=s.getContext("2d");n.putImageData(t,0,0);var e=n.canvas.toDataURL("image/png");u.e(0).then(u.t.bind(null,650,7)).then(function(t){(0,t.png_quant)(e,50,70,6,function(t){c(t)},y.default,!0)}),r(t,6)},y.default)):(a=document.createElement("canvas"),(0,f.xbrz)(t,6,function(t){a.width=t.width,a.height=t.height;var n=a.getContext("2d");n.putImageData(t,0,0);var e=n.canvas.toDataURL("image/png");u.e(0).then(u.t.bind(null,650,7)).then(function(t){(0,t.png_quant)(e,40,60,5,function(t){c(t)},y.default,!0)}),r(t,6)},y.default))},l.src=t},n.src=t}}},954:function(t,n,e){"use strict";window.xbrz_process_function_string='return async function(image_data, scale) {\n\n    const redMask = 0xff0000\n    const greenMask = 0x00ff00\n    const blueMask = 0x0000ff\n  \n    function blendComponent (mask, n, m, inPixel, setPixel) {\n      const inChan = inPixel & mask\n      const setChan = setPixel & mask\n      const blend = setChan * n + inChan * (m - n)\n      return mask & (blend / m)\n    }\n  \n    function alphaBlend (n, m, dstPtr, col) {\n      // assert n < 256 : "possible overflow of (col & redMask) * N";\n      // assert m < 256 : "possible overflow of (col & redMask) * N + (dst & redMask) * (M - N)";\n      // assert 0 < n && n < m : "0 < N && N < M";\n  \n      const dst = dstPtr.get()\n      const redComponent = blendComponent(redMask, n, m, dst, col)\n      const greenComponent = blendComponent(greenMask, n, m, dst, col)\n      const blueComponent = blendComponent(blueMask, n, m, dst, col)\n      const blend = (redComponent | greenComponent | blueComponent)\n      dstPtr.set(blend | 0xff000000)\n    }\n  \n  \n    class Scaler2x {\n      constructor () {\n        this.scale = 2\n      }\n  \n      scale () {\n        return this.scale\n      }\n  \n      blendLineShallow (col, out) {\n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n      }\n  \n      blendLineSteep (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(1, 0), col)\n        alphaBlend(1, 4, out.ref(0, 1), col)\n        alphaBlend(5, 6, out.ref(1, 1), col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(1, 1), col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(21, 100, out.ref(1, 1), col)\n      }\n    }\n  \n  \n    class Scaler3x extends Scaler2x{\n      constructor () {\n        super()\n        this.scale = 3\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(2, 0), col)\n        alphaBlend(1, 4, out.ref(0, 2), col)\n  \n        alphaBlend(3, 4, out.ref(2, 1), col)\n        alphaBlend(3, 4, out.ref(1, 2), col)\n  \n        out.ref(2, 2).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 8, out.ref(1, 2), col)\n        alphaBlend(1, 8, out.ref(2, 1), col)\n        alphaBlend(7, 8, out.ref(2, 2), col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(45, 100, out.ref(2, 2), col)\n      }\n    }\n  \n  \n    class Scaler4x extends Scaler3x {\n      constructor () {\n        super()\n        this.scale = 4\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n  \n        // out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n  \n        // out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(3, 4, out.ref(3, 1), col)\n        alphaBlend(3, 4, out.ref(1, 3), col)\n        alphaBlend(1, 4, out.ref(3, 0), col)\n        alphaBlend(1, 4, out.ref(0, 3), col)\n  \n        alphaBlend(1, 3, out.ref(2, 2), col)\n  \n        out.ref(3, 3).set(col)\n        out.ref(3, 2).set(col)\n        out.ref(2, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 2, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        out.ref(this.scale - 1, this.scale - 1).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(68, 100, out.ref(3, 3), col)\n        alphaBlend(9, 100, out.ref(3, 2), col)\n        alphaBlend(9, 100, out.ref(2, 3), col)\n      }\n    }\n  \n    class Scaler5x extends Scaler4x{\n      constructor () {\n        super()\n        this.scale = 5\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // **\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(1, 4, out.ref(this.scale - 3, 4), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n        // out.ref(this.scale - 1, 2).set(col)\n        // out.ref(this.scale - 1, 3).set(col)\n        out.ref(this.scale - 1, 4).set(col)\n        out.ref(this.scale - 2, 4).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(1, 4, out.ref(4, this.scale - 3), col)\n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n        // out.ref(2, this.scale - 1).set(col)\n        // out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n        out.ref(4, this.scale - 2).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n  \n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(2, 3, out.ref(3, 3), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        // **\n        alphaBlend(1, 8, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 8, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        alphaBlend(1, 8, out.ref(this.scale - 3, this.scale / 2 + 2), col)\n        alphaBlend(7, 8, out.ref(4, 3), col)\n        alphaBlend(7, 8, out.ref(3, 4), col)\n        out.ref(4, 4).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(86, 100, out.ref(4, 4), col)\n        alphaBlend(23, 100, out.ref(4, 3), col)\n        alphaBlend(23, 100, out.ref(3, 4), col)\n      }\n    }\n  \n    class Scaler6x extends Scaler5x {\n      constructor () {\n        super()\n        this.scale = 6\n      }\n  \n      blendLineShallow (col, out) {\n        super.blendLineShallow(col, out)\n        // alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        // alphaBlend(1, 4, out.ref(this.scale - 3, 4), col)\n  \n        // alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        // alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n        alphaBlend(3, 4, out.ref(this.scale - 3, 5), col)\n  \n        // out.ref(this.scale - 1, 2).set(col)\n        // out.ref(this.scale - 1, 3).set(col)\n        // out.ref(this.scale - 1, 4).set(col)\n        out.ref(this.scale - 1, 5).set(col)\n  \n        // out.ref(this.scale - 2, 4).set(col)\n        out.ref(this.scale - 2, 5).set(col)\n      }\n  \n      blendLineSteep (col, out) {\n        super.blendLineSteep(col, out)\n        // alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        // alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        // alphaBlend(1, 4, out.ref(4, this.scale - 3), col)\n  \n        // alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        // alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(5, this.scale - 3), col)\n  \n        // out.ref(2, this.scale - 1).set(col)\n        // out.ref(3, this.scale - 1).set(col)\n        // out.ref(4, this.scale - 1).set(col)\n        out.ref(5, this.scale - 1).set(col)\n  \n        // out.ref(4, this.scale - 2).set(col)\n        out.ref(5, this.scale - 2).set(col)\n      }\n  \n      blendLineSteepAndShallow (col, out) {\n        alphaBlend(1, 4, out.ref(0, this.scale - 1), col)\n        alphaBlend(1, 4, out.ref(2, this.scale - 2), col)\n        alphaBlend(3, 4, out.ref(1, this.scale - 1), col)\n        alphaBlend(3, 4, out.ref(3, this.scale - 2), col)\n  \n        alphaBlend(1, 4, out.ref(this.scale - 1, 0), col)\n        alphaBlend(1, 4, out.ref(this.scale - 2, 2), col)\n        alphaBlend(3, 4, out.ref(this.scale - 1, 1), col)\n        alphaBlend(3, 4, out.ref(this.scale - 2, 3), col)\n  \n        out.ref(2, this.scale - 1).set(col)\n        out.ref(3, this.scale - 1).set(col)\n        out.ref(4, this.scale - 1).set(col)\n        out.ref(5, this.scale - 1).set(col)\n  \n        out.ref(4, this.scale - 2).set(col)\n        out.ref(5, this.scale - 2).set(col)\n  \n        out.ref(this.scale - 1, 2).set(col)\n        out.ref(this.scale - 1, 3).set(col)\n      }\n  \n      blendLineDiagonal (col, out) {\n        alphaBlend(1, 2, out.ref(this.scale - 1, this.scale / 2), col)\n        alphaBlend(1, 2, out.ref(this.scale - 2, this.scale / 2 + 1), col)\n        alphaBlend(1, 2, out.ref(this.scale - 3, this.scale / 2 + 2), col)\n  \n        out.ref(this.scale - 2, this.scale - 1).set(col)\n        out.ref(this.scale - 1, this.scale - 1).set(col)\n        out.ref(this.scale - 1, this.scale - 2).set(col)\n      }\n  \n      blendCorner (col, out) {\n        alphaBlend(97, 100, out.ref(5, 5), col)\n        alphaBlend(42, 100, out.ref(4, 5), col)\n        alphaBlend(42, 100, out.ref(5, 4), col)\n        alphaBlend(6, 100, out.ref(5, 3), col)\n        alphaBlend(6, 100, out.ref(3, 5), col)\n      }\n    }\n  \n  \n    class IntPtr {\n      constructor (intArray) {\n        this.arr = intArray\n        this.ptr = 0\n      }\n  \n      position (pos) {\n        this.ptr = pos\n      }\n  \n      get () {\n        return this.arr[this.ptr]\n      }\n  \n      set (val) {\n        this.arr[this.ptr] = val\n      }\n    }\n  \n    class BlendResult {\n      constructor () {\n        this.f = 0\n        this.g = 0\n        this.j = 0\n        this.k = 0\n      }\n  \n      reset () {\n        this.f = 0\n        this.g = 0\n        this.j = 0\n        this.k = 0\n      }\n    }\n  \n    const maxRots = 4\n    const maxScale = 6\n    const maxScaleSq = maxScale * maxScale\n  \n    class OutputMatrix {\n      constructor (scale, out, outWidth) {\n        this.out = new IntPtr(out)\n        this.n = (scale - 2) * (maxRots * maxScaleSq)\n        this.outWidth = outWidth\n        this.outi = 0\n        this.nr = 0\n      }\n  \n      move (rotDeg, outi) {\n        this.nr = this.n + rotDeg * maxScaleSq\n        this.outi = outi\n      }\n  \n      ref (i, j) {\n        i = parseInt(i)\n        j = parseInt(j)\n        const rot = matrixRotation[this.nr + i * maxScale + j]\n        this.out.position(this.outi + rot.J + rot.I * this.outWidth)\n        return this.out\n      }\n    }\n  \n    const Rot = (function () {\n      /*\n      |0|6|8|2|1|3|\n      |7|5|2|0|6|8|\n      |3|8|5|1|4|4|\n      |4|4|5|1|3|7|\n      |6|8|2|0|7|5|\n      |1|3|8|2|0|7|\n       */\n      let arr = []\n      const\n          a = 0, b = 1, c = 2,\n          d = 3, e = 4, f = 5,\n          g = 6, h = 7, i = 8\n  \n      const deg0 = [\n        a, b, c,\n        d, e, f,\n        g, h, i\n      ]\n  \n      const deg90 = [\n        g, d, a,\n        h, e, b,\n        i, f, c\n      ]\n  \n      const deg180 = [\n        i, h, g,\n        f, e, d,\n        c, b, a\n      ]\n  \n      const deg270 = [\n        c, f, i,\n        b, e, h,\n        a, d, g\n      ]\n  \n      const rotation = [\n        deg0, deg90, deg180, deg270\n      ]\n  \n      for (let rotDeg = 0; rotDeg < 4; rotDeg++) {\n        for (let x = 0; x < 9; x++) {\n          arr[(x << 2) + rotDeg] = rotation[rotDeg][x]\n        }\n      }\n      return arr\n    })()\n  \n    const BlendType = {\n      \'BLEND_NONE\': 0,\n      \'BLEND_NORMAL\': 1,\n      \'BLEND_DOMINANT\': 2\n    }\n  \n    const blendResult = new BlendResult()\n  \n    function square (value) {\n      return value * value\n    }\n  \n  // 用指定颜色填充区块\n    function fillBlock (trg, trgi, pitch, col, blockSize) {\n      for (let y = 0; y < blockSize; ++y, trgi += pitch) {\n        for (let x = 0; x < blockSize; ++x) {\n          trg[trgi + x] = col\n        }\n      }\n    }\n  \n    function distYCbCr (pix1, pix2, lumaWeight) {\n      const r_diff = ((pix1 & redMask) - (pix2 & redMask)) >> 16\n      const g_diff = ((pix1 & greenMask) - (pix2 & greenMask)) >> 8\n      const b_diff = ((pix1 & blueMask) - (pix2 & blueMask))\n  \n      const k_b = 0.0722, k_r = 0.2126, k_g = 1 - k_b - k_r\n      const scale_b = 0.5 / (1 - k_b), scale_r = 0.5 / (1 - k_r)\n  \n      const y = k_r * r_diff + k_g * g_diff + k_b * b_diff\n      const c_b = scale_b * (b_diff - y)\n      const c_r = scale_r * (r_diff - y)\n      return square(lumaWeight * y) + square(c_b) + square(c_r)\n    }\n  \n    function colorDist (pix1, pix2, luminanceWeight) {\n      if (pix1 === pix2) {\n        return 0\n      }\n      return distYCbCr(pix1, pix2, luminanceWeight)\n    }\n  \n    let config = {\n      dominantDirectionThreshold: 3.6,\n      luminanceWeight: 1.0,\n      equalColorTolerance: 30.0,\n      steepDirectionThreshold: 2.2\n    }\n  \n    function preProcessCorners_colorDist_ (col1, col2) {\n      col1 = col1 & 0xffffffff\n      col2 = col2 & 0xffffffff\n      return colorDist(col1, col2, config.luminanceWeight)\n    }\n  \n    const eqColorThres = square(config.equalColorTolerance)\n  \n    function scalePixel_colorEq_ (col1, col2) {\n      return colorDist(col1, col2, config.luminanceWeight) < eqColorThres\n    }\n  \n    function scalePixel_colorDist_ (col1, col2) {\n      return colorDist(col1, col2, config.luminanceWeight)\n    }\n  \n    function buildMatrixRotation (rotDeg, I, J, N) {\n      let I_old = 0, J_old = 0\n      if (rotDeg === 0) {\n        I_old = I\n        J_old = J\n      } else {\n        const old = buildMatrixRotation(rotDeg - 1, I, J, N)\n        I_old = N - 1 - old.J\n        J_old = old.I\n      }\n      return { I: I_old, J: J_old }\n    }\n  \n    let matrixRotation = (function () {\n      let matrixRotation = []\n      for (let n = 2; n < maxScale + 1; n++) {\n        for (let r = 0; r < maxRots; r++) {\n          let nr = (n - 2) * (maxRots * maxScaleSq) + r * maxScaleSq\n          for (let i = 0; i < maxScale; i++) {\n            for (let j = 0; j < maxScale; j++) {\n              matrixRotation[nr + i * maxScale + j] = buildMatrixRotation(r, i, j, n)\n            }\n          }\n        }\n      }\n      return matrixRotation\n    })()\n  \n    function preProcessCorners (ker4x4) {\n      blendResult.reset()\n      if ((ker4x4.f === ker4x4.g && ker4x4.j === ker4x4.k) ||\n          (ker4x4.f === ker4x4.j && ker4x4.g === ker4x4.k)) {\n        return\n      }\n  \n      const dist = preProcessCorners_colorDist_\n  \n      const weight = 4\n      const jg =\n          dist(ker4x4.i, ker4x4.f) +\n          dist(ker4x4.f, ker4x4.c) +\n          dist(ker4x4.n, ker4x4.k) +\n          dist(ker4x4.k, ker4x4.h) +\n          weight * dist(ker4x4.j, ker4x4.g)\n      const fk =\n          dist(ker4x4.e, ker4x4.j) +\n          dist(ker4x4.j, ker4x4.o) +\n          dist(ker4x4.b, ker4x4.g) +\n          dist(ker4x4.g, ker4x4.l) +\n          weight * dist(ker4x4.f, ker4x4.k)\n  \n      const dominantGradient = config.dominantDirectionThreshold * jg < fk\n      if (jg < fk) {\n        if (ker4x4.f !== ker4x4.g && ker4x4.f !== ker4x4.j) {\n          blendResult.f = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n        if (ker4x4.k !== ker4x4.g && ker4x4.k !== ker4x4.j) {\n          blendResult.k = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n      } else if (fk < jg) {\n        if (ker4x4.j !== ker4x4.f && ker4x4.j !== ker4x4.k) {\n          blendResult.j = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n        if (ker4x4.g !== ker4x4.f && ker4x4.g !== ker4x4.k) {\n          blendResult.g = dominantGradient ? BlendType.BLEND_DOMINANT : BlendType.BLEND_NORMAL\n        }\n      }\n    }\n  \n    const BlendInfo = {\n      getTopL (b) {\n        return (b & 0x3) & 0xff\n      },\n      getTopR (b) {\n        return ((b >> 2) & 0x3) & 0xff\n      },\n      getBottomR (b) {\n        return ((b >> 4) & 0x3) & 0xff\n      },\n      getBottomL (b) {\n        return ((b >> 6) & 0x3) & 0xff\n      },\n      setTopL (b, bt) {\n        return (b | bt) & 0xff\n      },\n      setTopR (b, bt) {\n        return (b | bt << 2) & 0xff\n      },\n      setBottomR (b, bt) {\n        return (b | bt << 4) & 0xff\n      },\n      setBottomL (b, bt) {\n        return (b | (bt << 6)) & 0xff\n      },\n      rotate (b, rotDeg) {\n        // assert rotDeg >= 0 && rotDeg < 4 : "RotationDegree enum does not have type: " + rotDeg;\n        const l = rotDeg << 1\n        const r = 8 - l\n        return (b << l | b >> r) & 0xff\n      }\n    }\n  \n    let outputMatrix\n  \n    function scalePixel (scaler, rotDeg, ker3x3, trg, trgi, trgWidth, blendInfo) {\n      const b = ker3x3[Rot[(1 << 2) + rotDeg]]\n      const c = ker3x3[Rot[(2 << 2) + rotDeg]]\n      const d = ker3x3[Rot[(3 << 2) + rotDeg]]\n      const e = ker3x3[Rot[(4 << 2) + rotDeg]]\n      const f = ker3x3[Rot[(5 << 2) + rotDeg]]\n      const g = ker3x3[Rot[(6 << 2) + rotDeg]]\n      const h = ker3x3[Rot[(7 << 2) + rotDeg]]\n      const i = ker3x3[Rot[(8 << 2) + rotDeg]]\n  \n      const blend = BlendInfo.rotate(blendInfo, rotDeg)\n      if (BlendInfo.getBottomR(blend) === BlendType.BLEND_NONE) {\n        return\n      }\n  \n      const eq = scalePixel_colorEq_\n      const dist = scalePixel_colorDist_\n  \n      let doLineBlend\n  \n      if (BlendInfo.getBottomR(blend) >= BlendType.BLEND_DOMINANT) {\n        doLineBlend = true\n      } else if (BlendInfo.getTopR(blend) !== BlendType.BLEND_NONE && !eq(e, g)) {\n        doLineBlend = false\n      } else if (BlendInfo.getBottomL(blend) !== BlendType.BLEND_NONE && !eq(e, c)) {\n        doLineBlend = false\n      } else {\n        doLineBlend = !(eq(g, h) && eq(h, i) && eq(i, f) && eq(f, c) && !eq(e, i))\n      }\n  \n      const px = dist(e, f) <= dist(e, h) ? f : h\n  \n      const out = outputMatrix\n      out.move(rotDeg, trgi)\n  \n      if (!doLineBlend) {\n        scaler.blendCorner(px, out)\n        return\n      }\n  \n      const fg = dist(f, g)\n      const hc = dist(h, c)\n  \n      const haveShallowLine = config.steepDirectionThreshold * fg <= hc && e !== g && d !== g\n      const haveSteepLine = config.steepDirectionThreshold * hc <= fg && e !== c && b !== c\n  \n      if (haveShallowLine) {\n        if (haveSteepLine) {\n          scaler.blendLineSteepAndShallow(px, out)\n        } else {\n          scaler.blendLineShallow(px, out)\n        }\n      } else {\n        if (haveSteepLine) {\n          scaler.blendLineSteep(px, out)\n        } else {\n          scaler.blendLineDiagonal(px, out)\n        }\n      }\n    }\n  \n    function scaleImage (scaleSize, src, trg, srcWidth, srcHeight, yFirst, yLast) {\n      yFirst = Math.max(yFirst, 0)\n      yLast = Math.min(yLast, srcHeight)\n  \n      if (yFirst >= yLast || srcWidth <= 0) {\n        return\n      }\n  \n      const trgWidth = srcWidth * scaleSize\n  \n      let preProcBuffer = []\n      let ker4 = {\n        a: 0, b: 0, c: 0, d: 0,\n        e: 0, f: 0, g: 0, h: 0,\n        i: 0, j: 0, k: 0, l: 0,\n        m: 0, n: 0, o: 0, p: 0,\n      }\n  \n      if (yFirst > 0) {\n        const y = yFirst - 1\n        const s_m1 = srcWidth * Math.max(y - 1, 0)\n        const s_0 = srcWidth * y\n        const s_p1 = srcWidth * Math.min(y + 1, srcHeight - 1)\n        const s_p2 = srcWidth * Math.min(y + 2, srcHeight - 1)\n  \n        for (let x = 0; x < srcWidth; ++x) {\n          const x_m1 = Math.max(x - 1, 0)\n          const x_p1 = Math.min(x + 1, srcWidth - 1)\n          const x_p2 = Math.min(x + 2, srcWidth - 1)\n  \n          ker4.a = src[s_m1 + x_m1]\n          ker4.b = src[s_m1 + x]\n          ker4.c = src[s_m1 + x_p1]\n          ker4.d = src[s_m1 + x_p2]\n  \n          ker4.e = src[s_0 + x_m1]\n          ker4.f = src[s_0 + x]\n          ker4.g = src[s_0 + x_p1]\n          ker4.h = src[s_0 + x_p2]\n  \n          ker4.i = src[s_p1 + x_m1]\n          ker4.j = src[s_p1 + x]\n          ker4.k = src[s_p1 + x_p1]\n          ker4.l = src[s_p1 + x_p2]\n  \n          ker4.m = src[s_p2 + x_m1]\n          ker4.n = src[s_p2 + x]\n          ker4.o = src[s_p2 + x_p1]\n          ker4.p = src[s_p2 + x_p2]\n  \n          preProcessCorners(ker4)\n  \n          preProcBuffer[x] = BlendInfo.setTopR(preProcBuffer[x], blendResult.j)\n          if (x + 1 < srcWidth) {\n            preProcBuffer[x + 1] = BlendInfo.setTopL(preProcBuffer[x + 1] & 0xff, blendResult.k)\n          }\n        }\n      }\n  \n      outputMatrix = new OutputMatrix(scaleSize, trg, trgWidth)\n  \n      let blend_xy = 0\n      let blend_xy1 = 0\n  \n      let ker3 = []\n  \n      for (let y = yFirst; y < yLast; ++y) {\n        let trgi = scaleSize * y * trgWidth\n        const s_m1 = srcWidth * Math.max(y - 1, 0)\n        const s_0 = srcWidth * y\n        const s_p1 = srcWidth * Math.min(y + 1, srcHeight - 1)\n        const s_p2 = srcWidth * Math.min(y + 2, srcHeight - 1)\n  \n        blend_xy1 = 0\n  \n        for (let x = 0; x < srcWidth; ++x, trgi += scaleSize) {\n          const x_m1 = Math.max(x - 1, 0)\n          const x_p1 = Math.min(x + 1, srcWidth - 1)\n          const x_p2 = Math.min(x + 2, srcWidth - 1)\n          {\n            ker4.a = src[s_m1 + x_m1]\n            ker4.b = src[s_m1 + x]\n            ker4.c = src[s_m1 + x_p1]\n            ker4.d = src[s_m1 + x_p2]\n  \n            ker4.e = src[s_0 + x_m1]\n            ker4.f = src[s_0 + x]\n            ker4.g = src[s_0 + x_p1]\n            ker4.h = src[s_0 + x_p2]\n  \n            ker4.i = src[s_p1 + x_m1]\n            ker4.j = src[s_p1 + x]\n            ker4.k = src[s_p1 + x_p1]\n            ker4.l = src[s_p1 + x_p2]\n  \n            ker4.m = src[s_p2 + x_m1]\n            ker4.n = src[s_p2 + x]\n            ker4.o = src[s_p2 + x_p1]\n            ker4.p = src[s_p2 + x_p2]\n            preProcessCorners(ker4)\n  \n            blend_xy = BlendInfo.setBottomR(preProcBuffer[x], blendResult.f)\n            blend_xy1 = BlendInfo.setTopR(blend_xy1, blendResult.j)\n            preProcBuffer[x] = blend_xy1\n  \n            blend_xy1 = BlendInfo.setTopL(0, blendResult.k)\n            if (x + 1 < srcWidth) {\n              preProcBuffer[x + 1] = BlendInfo.setBottomL(preProcBuffer[x + 1], blendResult.g)\n            }\n          }\n  \n          fillBlock(trg, trgi, trgWidth, src[s_0 + x], scaleSize)\n  \n          if (blend_xy === 0) {\n            continue\n          }\n  \n          const a = 0, b = 1, c = 2, d = 3, e = 4, f = 5, g = 6, h = 7, i = 8\n  \n          ker3[a] = src[s_m1 + x_m1]\n          ker3[b] = src[s_m1 + x]\n          ker3[c] = src[s_m1 + x_p1]\n  \n          ker3[d] = src[s_0 + x_m1]\n          ker3[e] = src[s_0 + x]\n          ker3[f] = src[s_0 + x_p1]\n  \n          ker3[g] = src[s_p1 + x_m1]\n          ker3[h] = src[s_p1 + x]\n          ker3[i] = src[s_p1 + x_p1]\n  \n          let scaler\n          switch (scaleSize) {\n            case 2:\n              scaler = new Scaler2x()\n              break\n            case 3:\n              scaler = new Scaler3x()\n              break\n            case 4:\n              scaler = new Scaler4x()\n              break\n            case 5:\n              scaler = new Scaler5x()\n              break\n            case 6:\n              scaler = new Scaler6x()\n              break\n            default:\n              scaler = new Scaler6x()\n              break\n          }\n  \n          scalePixel(scaler, 0, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 1, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 2, ker3, trg, trgi, trgWidth, blend_xy)\n          scalePixel(scaler, 3, ker3, trg, trgi, trgWidth, blend_xy)\n        }\n      }\n    }\n    \n    const source_buffer = Array.from(image_data.data);\n    let source = [];\n    for (let i = 0, len = source_buffer.length; i < len; i += 4) {\n        const r = source_buffer[i];\n        const g = source_buffer[i + 1];\n        const b = source_buffer[i + 2];\n        const a = source_buffer[i + 3];\n        const pixel = a << 24 | r << 16 | g << 8 | b;\n        source.push(pixel)\n    }\n  \n    let target = new Array(image_data.width * scale * image_data.height * scale);\n    target.fill(0);\n    scaleImage(scale, source, target, image_data.width, image_data.height, 0, image_data.height);\n  \n    let target_buffer = [];\n    for (let i = 0, len = target.length; i < len; ++i) {\n      const pixel = target[i];\n      const a = (pixel >> 24) & 0xff;\n      const r = (pixel >> 16) & 0xff;\n      const g = (pixel >> 8) & 0xff;\n      const b = (pixel) & 0xff;\n      target_buffer.push(r);\n      target_buffer.push(g);\n      target_buffer.push(b);\n      target_buffer.push(a);\n    }\n  \n    const data_array_target = new Uint8ClampedArray(target_buffer);\n    const final_image_data = new ImageData(data_array_target, image_data.width * scale, image_data.height * scale);\n    return final_image_data;\n  }',t.exports={xbrz:function n(e,i,r){var s=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s?s.exec(window.xbrz_process_function_string,[e,i]).catch(function(t){return"Pool terminated"===t?n(e,i,r,s):new Function(window.xbrz_process_function_string)()(e,i)}).then(function(t){r(t)}).then(function(){s.terminate()}).timeout(1e4):new Function(window.xbrz_process_function_string)()(e,i).then(function(t){r(t)})}}},955:function(t,n,e){"use strict";window.omniscale_process_function_string="return async function(image_data, scale) {\n\n        // static class methods for common filter operations\n        class Common {\n    \n            static get Threshold() {\n    \n                return this.hasOwnProperty('_Threshold') ? this._Threshold : false;\n            }\n    \n            static set Threshold(v) {\n    \n                this._Threshold = v;\n            }\n    \n            static get ScaleX() {\n    \n                return this.hasOwnProperty('_ScaleX') ? this._ScaleX : parseInt(0);\n            }\n    \n            static set ScaleX(v) {\n    \n                this._ScaleX = parseInt(v);\n            }\n    \n            static get ScaleY() {\n    \n                return this.hasOwnProperty('_ScaleY') ? this._ScaleY : parseInt(0);\n            }\n    \n            static set ScaleY(v) {\n    \n                this._ScaleY = parseInt(v);\n            }\n    \n            static get SizeX() {\n    \n                return this.hasOwnProperty('_SizeX') ? this._SizeX : parseInt(0);\n            }\n    \n            static set SizeX(v) {\n    \n                this._SizeX = parseInt(v);\n            }\n    \n            static get SizeY() {\n    \n                return this.hasOwnProperty('_SizeY') ? this._SizeY : parseInt(0);\n            }\n    \n            static set SizeY(v) {\n    \n                this._SizeY = parseInt(v);\n            }\n    \n            static get ScaledImage() {\n    \n                return this.hasOwnProperty('_ScaledImage') ? this._ScaledImage : [];\n            }\n    \n            static set ScaledImage(v) {\n    \n                this._ScaledImage = v;\n            }\n    \n            static Copy(dst, src, Length) {\n    \n                for (var i = 0; i < Length; i++)\n                    dst[i] = this._Clip8(src[i]);\n            }\n    \n            static Copy2D(dst, src, dstx, dsty, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                var xdim = Math.min(srcx, dstx);\n                var ydim = Math.min(srcy, dsty);\n    \n                for (var y = 0; y < ydim; y++)\n                    for (var x = 0; x < xdim; x++)\n                        for (var Channel = 0; Channel < Channels; Channel++)\n                            dst[(y * dstx + x) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];\n            }\n    \n            static CopyPadded(src, srcx, srcy, scale) {\n    \n                const Channels = 4;\n    \n                var dim = Math.max(srcx, srcy);\n                dim = Common.NextPow(dim, scale);\n    \n                var dst = new Uint8ClampedArray(dim * dim * Channels);\n    \n                Common.Copy2D(dst, src, dim, dim, srcx, srcy);\n    \n                return dst;\n            }\n    \n            static CopyCropped(dst, src, dstx, dsty, srcx, srcy) {\n    \n                Common.Copy2D(dst, src, dstx, dsty, srcx, srcy);\n            }\n    \n            static ToArray(Input, srcx, srcy) {\n    \n                var dst = new Uint32Array(srcx * srcy);\n    \n                var Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n    \n                    for (var x = 0; x < srcx; x++) {\n    \n                        var index = y * srcx + x;\n                        var pixel = index * Channels;\n    \n                        var r = Input[pixel];\n                        var g = Input[pixel + 1];\n                        var b = Input[pixel + 2];\n                        var a = Input[pixel + 3];\n    \n                        dst[index] = this.ARGBINT(a, r, g, b);\n                    }\n                }\n    \n                return dst;\n            }\n    \n            static ToImage(dst, src, srcx, srcy) {\n    \n                var Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n                    for (var x = 0; x < srcx; x++) {\n    \n                        var index = y * srcx + x;\n                        var pixel = index * Channels;\n    \n                        dst[pixel] = this.Red(src[index]);\n                        dst[pixel + 1] = this.Green(src[index]);\n                        dst[pixel + 2] = this.Blue(src[index]);\n                        dst[pixel + 3] = this.Alpha(src[index]);\n                    }\n                }\n            }\n    \n            static _CLR(Input, srcx, srcy, x, y) {\n    \n                const Channels = 4;\n    \n                if (y >= 0 && y < srcy && x >= 0 && x < srcx) {\n    \n                    var index = (y * srcx + x) * Channels;\n    \n                    var r = Input[index];\n                    var g = Input[index + 1];\n                    var b = Input[index + 2];\n                    var a = Input[index + 3];\n    \n                    return this.ARGBINT(a, r, g, b);\n                }\n    \n                return 0;\n            }\n    \n            static CLR(Input, srcx, srcy, x, y, dx = 0, dy = 0) {\n    \n                var xx = parseInt(x + dx);\n                var yy = parseInt(y + dy);\n    \n                xx = Math.max(0, Math.min(srcx - 1, xx));\n                yy = Math.max(0, Math.min(srcy - 1, yy));\n    \n                return this._CLR(Input, srcx, srcy, xx, yy);\n            }\n    \n            static Alpha(rgb) {\n    \n                return parseInt(rgb >>> 24);\n            }\n    \n            static Red(rgb) {\n    \n                return parseInt((rgb >>> 0 & 0x00FF0000) >> 16);\n            }\n    \n            static Green(rgb) {\n    \n                return parseInt((rgb >>> 0 & 0x0000FF00) >> 8);\n            }\n    \n            static Blue(rgb) {\n    \n                return parseInt(rgb >>> 0 & 0x000000FF);\n            }\n    \n            static Brightness(rgb) {\n    \n                var dwordC = rgb & 0xFFFFFF;\n    \n                return this._Clip8((this.Red(dwordC) * 3 + this.Green(dwordC) * 3 + this.Blue(dwordC) * 2) >> 3);\n            }\n    \n            static Luminance(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(0.299 * r + 0.587 * g + 0.114 * b);\n            }\n    \n            static ChromaU(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(0.5 * r - 0.418688 * g - 0.081312 * b + 127.5);\n            }\n    \n            static ChromaV(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(-0.168736 * r - 0.331264 * g + 0.5 * b + 127.5);\n            }\n    \n            static IsLike(pixel1, pixel2) {\n    \n                if (!this.Threshold)\n                    return pixel1 == pixel2;\n    \n                const _LUMINANCE_TRIGGER = 48;\n                const _CHROMA_U_TRIGGER = 7;\n                const _CHROMA_V_TRIGGER = 6;\n    \n                var delta = this.Luminance(pixel1) - this.Luminance(pixel2);\n    \n                if (Math.abs(delta) > _LUMINANCE_TRIGGER)\n                    return false;\n    \n                delta = this.ChromaV(pixel1) - this.ChromaV(pixel2);\n    \n                if (Math.abs(delta) > _CHROMA_V_TRIGGER)\n                    return false;\n    \n                delta = this.ChromaU(pixel1) - this.ChromaU(pixel2);\n    \n                return Math.abs(delta) <= _CHROMA_U_TRIGGER;\n            }\n    \n            static IsNotLike(pixel1, pixel2) {\n    \n                return !this.IsLike(pixel1, pixel2);\n            }\n    \n            static _Clip8(color) {\n    \n                return Math.max(0, Math.min(255, color));\n            }\n    \n            static _Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n    \n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var dx = x * this.ScaleX;\n                    var dy = y * this.ScaleY;\n    \n                    dx += (Pixel == 2 || Pixel == 4) ? 1 : 0;\n                    dy += (Pixel == 3 || Pixel == 4) ? 1 : 0;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write4RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static _Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var deltax = 0;\n                    var deltay = 0;\n    \n                    if (Pixel == 2 || Pixel == 5 || Pixel == 8) {\n    \n                        deltax = 1;\n                    }\n    \n                    if (Pixel == 3 || Pixel == 6 || Pixel == 9) {\n    \n                        deltax = 2;\n                    }\n    \n                    if (Pixel == 4 || Pixel == 5 || Pixel == 6) {\n    \n                        deltay = 1;\n                    }\n    \n                    if (Pixel == 7 || Pixel == 8 || Pixel == 9) {\n    \n                        deltay = 2;\n                    }\n    \n                    var dx = x * this.ScaleX + deltax;\n                    var dy = y * this.ScaleY + deltay;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write9RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static _Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n    \n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var deltax = 0;\n                    var deltay = 0;\n    \n                    /*\n                    01 02 03 04\n                    05 06 07 08\n                    09 10 11 12\n                    13 14 15 16\n                    */\n    \n                    if (Pixel == 2 || Pixel == 6 || Pixel == 10 || Pixel == 14) {\n    \n                        deltax = 1;\n                    }\n    \n                    if (Pixel == 3 || Pixel == 7 || Pixel == 11 || Pixel == 15) {\n    \n                        deltax = 2;\n                    }\n    \n                    if (Pixel == 4 || Pixel == 8 || Pixel == 12 || Pixel == 16) {\n    \n                        deltax = 3;\n                    }\n    \n                    if (Pixel == 5 || Pixel == 6 || Pixel == 7 || Pixel == 8) {\n    \n                        deltay = 1;\n                    }\n    \n                    if (Pixel == 9 || Pixel == 10 || Pixel == 11 || Pixel == 12) {\n    \n                        deltay = 2;\n                    }\n    \n                    if (Pixel == 13 || Pixel == 14 || Pixel == 15 || Pixel == 16) {\n    \n                        deltay = 3;\n                    }\n    \n                    var dx = x * this.ScaleX + deltax;\n                    var dy = y * this.ScaleY + deltay;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write16RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static WriteMagnify(Input, Output, sizex, sizey, x, y) {\n    \n                const Channels = 4;\n    \n                var x0 = x * this.ScaleX;\n                var y0 = y * this.ScaleY;\n    \n                for (var deltay = 0; deltay < this.ScaleY; deltay++) {\n                    for (var deltax = 0; deltax < this.ScaleX; deltax++) {\n    \n                        var dx = x0 + deltax;\n                        var dy = y0 + deltay;\n    \n                        var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                        var index = (y * sizex + x) * Channels;\n    \n                        for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                            Output[dst + Channel] = Input[index + Channel];\n                        }\n                    }\n                }\n            }\n    \n            static RGBINT(r, g, b) {\n    \n                return parseInt((this._Clip8(r) << 16) + (this._Clip8(g) << 8) + this._Clip8(b));\n            }\n    \n            static ARGBINT(a, r, g, b) {\n    \n                return ((((((a) >>> 0) << 24) >>> 0) | (((r) << 16) + ((g) << 8) + ((b)))) >>> 0);\n            }\n    \n            static Truncate(color) {\n    \n                return this._Clip8(color);\n            }\n    \n            static NextPow(v, scale) {\n    \n                var dim = 1;\n    \n                for (var i = 0; i < 10; i++) {\n    \n                    if (v <= dim)\n                        break;\n    \n                    dim *= scale;\n                }\n    \n                return dim;\n            }\n        }\n    \n    // brightness control\n        class Brightness {\n    \n            static AdjustBrightness(color, level) {\n    \n                return Common.Truncate(color + level);\n            }\n        }\n    \n    // color interpolation\n        class Interpolate {\n    \n            static Interpolate3P(pixel1, pixel2, pixel3) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3)) / 3);\n                var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3)) / 3);\n                var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3)) / 3);\n                var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3)) / 3);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P(pixel1, pixel2) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2)) >> 1);\n                var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2)) >> 1);\n                var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2)) >> 1);\n                var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2)) >> 1);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P1Q(pixel1, pixel2, quantifier) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) * (1.0 - quantifier) + Common.Red(pixel2) * quantifier));\n                var g = parseInt(parseInt(Common.Green(pixel1) * (1.0 - quantifier) + Common.Green(pixel2) * quantifier));\n                var b = parseInt(parseInt(Common.Blue(pixel1) * (1.0 - quantifier) + Common.Blue(pixel2) * quantifier));\n                var a = parseInt(parseInt(Common.Alpha(pixel1) * (1.0 - quantifier) + Common.Alpha(pixel2) * quantifier));\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P2Q(pixel1, pixel2, quantifier1, quantifier2) {\n    \n                var total = (quantifier1 + quantifier2);\n    \n                var r = parseInt(((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2)) / total);\n                var g = parseInt(((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2)) / total);\n                var b = parseInt(((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2)) / total);\n                var a = parseInt(((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2)) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate3P3Q(pixel1, pixel2, pixel3, quantifier1, quantifier2, quantifier3) {\n    \n                var total = parseInt(quantifier1 + quantifier2 + quantifier3);\n    \n                var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3) / total);\n                var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3) / total);\n                var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3) / total);\n                var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate4P(pixel1, pixel2, pixel3, pixel4) {\n    \n                var r = parseInt((Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3) + Common.Red(pixel4)) >> 2);\n                var g = parseInt((Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3) + Common.Green(pixel4)) >> 2);\n                var b = parseInt((Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3) + Common.Blue(pixel4)) >> 2);\n                var a = parseInt((Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3) + Common.Alpha(pixel4)) >> 2);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate4P4Q(pixel1, pixel2, pixel3, pixel4, quantifier1, quantifier2, quantifier3, quantifier4) {\n    \n                var total = parseInt(quantifier1 + quantifier2 + quantifier3 + quantifier4);\n    \n                var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3 + Common.Red(pixel4) * quantifier4) / total);\n                var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3 + Common.Green(pixel4) * quantifier4) / total);\n                var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3 + Common.Blue(pixel4) * quantifier4) / total);\n                var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3 + Common.Alpha(pixel4) * quantifier4) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Mixpal(c1, c2) {\n    \n                return (this.Interpolate2P2Q(c1, c2, 3, 1));\n            }\n    \n            static Fix(n, min, max) {\n    \n                return Math.max(Math.min(n, max), min);\n            }\n    \n            static Unmix(c1, c2) {\n    \n                /* A variant of an unsharp mask, without the blur part. */\n    \n                var ra = Common.Red(c1);\n                var ga = Common.Green(c1);\n                var ba = Common.Blue(c1);\n                var aa = Common.Alpha(c1);\n    \n                var rb = Common.Red(c2);\n                var gb = Common.Green(c2);\n                var bb = Common.Blue(c2);\n                var ab = Common.Alpha(c2);\n    \n                var r = ((this.Fix((ra + (ra - rb)), 0, 255) + rb) >> 1);\n                var g = ((this.Fix((ga + (ga - gb)), 0, 255) + gb) >> 1);\n                var b = ((this.Fix((ba + (ba - bb)), 0, 255) + bb) >> 1);\n                var a = ((this.Fix((aa + (aa - ab)), 0, 255) + ab) >> 1);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n        }\n    \n    // image flips\n        class Flip {\n    \n            static FlipUD(src, sizex, sizey) {\n    \n                const Channels = 4;\n    \n                if (src.length > 0) {\n    \n                    for (var y = 0; y < sizey / 2; y++) {\n                        for (var x = 0; x < sizex; x++) {\n    \n                            var index = (y * sizex + x) * Channels;\n                            var rev = ((sizey - y - 1) * sizex + x) * Channels;\n    \n                            for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                                var temp = src[index + Channel];\n                                src[index + Channel] = src[rev + Channel];\n                                src[rev + Channel] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n    \n            static FlipLR(src, sizex, sizey) {\n    \n                const Channels = 4;\n    \n                if (src.length > 0) {\n    \n                    for (var y = 0; y < sizey; y++) {\n                        for (var x = 0; x < sizex / 2; x++) {\n    \n                            var index = (y * sizex + x) * Channels;\n                            var rev = (y * sizex + (sizex - x - 1)) * Channels;\n    \n                            for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                                var temp = src[index + Channel];\n                                src[index + Channel] = src[rev + Channel];\n                                src[rev + Channel] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    \n        class Rotate {\n    \n            static Transpose(dst, src, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n                    for (var x = 0; x < srcx; x++) {\n                        for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                            dst[(x * srcy + y) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];\n                        }\n                    }\n                }\n            }\n    \n            static Rotate90(dst, src, srcx, srcy) {\n    \n                this.Transpose(dst, src, srcx, srcy);\n    \n                Flip.FlipUD(dst, srcy, srcx);\n            }\n    \n            static Rotate180(dst, src, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                Common.Copy(dst, src, srcx * srcy * Channels);\n    \n                Flip.FlipUD(dst, srcx, srcy);\n    \n                Flip.FlipLR(dst, srcx, srcy);\n            }\n    \n            static Rotate270(dst, src, srcx, srcy) {\n    \n                Flip.FlipUD(src, srcx, srcy);\n    \n                this.Transpose(dst, src, srcx, srcy);\n            }\n        }\n    \n        class Kreed {\n    \n            static Conc2D(c00, c01, c10, c11) {\n    \n                var result = 0;\n    \n                var acAreAlike = Common.IsLike(c00, c10);\n    \n                var x = acAreAlike ? 1 : 0;\n                var y = (Common.IsLike(c01, c10) && !(acAreAlike)) ? 1 : 0;\n    \n                var adAreAlike = Common.IsLike(c00, c11);\n    \n                x += adAreAlike ? 1 : 0;\n                y += (Common.IsLike(c01, c11) && !(adAreAlike)) ? 1 : 0;\n    \n                if (x <= 1)\n                    result++;\n    \n                if (y <= 1)\n                    result--;\n    \n                return (result);\n            }\n        }\n    \n        class ReverseAA {\n    \n            static Clamp(v, min, max) {\n    \n                return parseInt(Math.min(max, Math.max(v, min)));\n            }\n    \n            static FullClamp(value) {\n    \n                return Common._Clip8(value);\n            }\n    \n            static _ReverseAntiAlias(b1, b, d, e, f, h, h5, d0, f4) {\n    \n                var n1 = b1;\n                var n2 = b;\n                var s = e;\n                var n3 = h;\n                var n4 = h5;\n                var aa = n2 - n1;\n                var bb = s - n2;\n                var cc = n3 - s;\n                var dd = n4 - n3;\n    \n                var tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                var m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var s1 = s + tilt / 2;\n                var s0 = s1 - tilt;\n    \n                n1 = d0;\n                n2 = d;\n                s = s0;\n                n3 = f;\n                n4 = f4;\n                aa = n2 - n1;\n                bb = s - n2;\n                cc = n3 - s;\n                dd = n4 - n3;\n    \n                tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var e1 = s + tilt / 2;\n                var e0 = e1 - tilt;\n    \n                s = s1;\n                bb = s - n2;\n                cc = n3 - s;\n    \n                tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var e3 = s + tilt / 2;\n                var e2 = e3 - tilt;\n    \n                return { rd: this.FullClamp(e0), gn: this.FullClamp(e1), bl: this.FullClamp(e2), alpha: this.FullClamp(e3) };\n            }\n        }\n    \n    // image initialization\n        class Init {\n    \n            static Buffer(Length, c) {\n    \n                const Channels = 4;\n    \n                var buffer = new Uint8ClampedArray(Length * Channels);\n    \n                for (var i = 0; i < Length; i++) {\n    \n                    var index = i * Channels;\n    \n                    buffer[index] = parseInt(c);\n                    buffer[index + 1] = parseInt(c);\n                    buffer[index + 2] = parseInt(c);\n                    buffer[index + 3] = 255;\n                }\n    \n                return buffer;\n            }\n    \n            static New(x, y) {\n    \n                return this.Buffer(x * y, 0);\n            }\n    \n            static Init(srcx, srcy, FilterScaleX, FilterScaleY, ComparisonThreshold) {\n    \n                Common.ScaleX = FilterScaleX;\n                Common.ScaleY = FilterScaleY;\n                Common.SizeX = srcx * FilterScaleX;\n                Common.SizeY = srcy * FilterScaleY;\n                Common.Threshold = ComparisonThreshold;\n    \n                Common.ScaledImage = this.New(Common.SizeX, Common.SizeY);\n            }\n        }\n    \n    \n        // Lior Halphon's Omniscale (Modified: Uses Maxim Stepin's Color comparison routine)\n        var Filter = class {\n    \n            Apply(Input, srcx, srcy, scale, threshold) {\n    \n                var Channels = 4;\n    \n                scale = Math.max(1, scale);\n    \n                Init.Init(srcx, srcy, scale, scale, threshold);\n    \n                var total = Common.SizeY;\n                var current = 0;\n    \n                for (var y = 0; y < Common.SizeY; y++) {\n    \n                    var offset = y * Common.SizeX;\n                    var positiony = y / Common.SizeY;\n    \n                    for (var x = 0; x < Common.SizeX; x++) {\n    \n                        var argb = this.ScaleImage(Input, x / Common.SizeX, positiony, srcx, srcy, Common.SizeX, Common.SizeY);\n    \n                        Common.ScaledImage[(offset + x) * Channels] = Common.Red(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 1] = Common.Green(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 2] = Common.Blue(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 3] = Common.Alpha(argb);\n                    }\n    \n                    current++;\n    \n                    //notify({ ScalingProgress: current / total });\n                }\n    \n                return new ImageData(new Uint8ClampedArray(Common.ScaledImage), srcx * scale, srcy * scale);\n            }\n    \n            is_different(a, b) {\n    \n                return Common.IsNotLike(a, b);\n            }\n    \n            mix(x, y, a) {\n    \n                return Interpolate.Interpolate2P1Q(x, y, a);\n            }\n    \n            fract(x) {\n    \n                return x - Math.floor(x);\n            }\n    \n            P(pattern, m, r) {\n    \n                return ((pattern & (m)) == (r))\n            }\n    \n            Mul(x, y) {\n    \n                var r = Common.Red(x) * y;\n                var g = Common.Green(x) * y;\n                var b = Common.Blue(x) * y;\n                var a = Common.Alpha(x) * y;\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            Add(x, y, scale) {\n    \n                var r = (Common.Red(x) + Common.Red(y)) * scale;\n                var g = (Common.Green(x) + Common.Green(y)) * scale;\n                var b = (Common.Blue(x) + Common.Blue(y)) * scale;\n                var a = (Common.Alpha(x) + Common.Alpha(y)) * scale;\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            length(a, b) {\n    \n                return Math.sqrt(a * a + b * b);\n            }\n    \n            ScaleImage(image, ppx, ppy, srcx, srcy, dstx, dsty) {\n    \n                var ox = 1.0 / srcx;\n                var oy = 1.0 / srcy;\n    \n                var px = this.fract(ppx * srcx);\n                var py = this.fract(ppy * srcy);\n    \n                if (px > 0.5) {\n    \n                    ox = -ox;\n                    px = 1.0 - px;\n                }\n    \n                if (py > 0.5) {\n    \n                    oy = -oy;\n                    py = 1.0 - py;\n                }\n    \n                // convert texture coordinates to image coordinates\n                ox = parseInt(ox * srcx);\n                oy = parseInt(oy * srcy);\n    \n                var positionx = parseInt(ppx * srcx);\n                var positiony = parseInt(ppy * srcy);\n    \n                var w0 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, -oy);\n                var w1 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, -oy);\n                var w2 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, -oy);\n                var w3 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, 0);\n                var w4 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, 0);\n                var w5 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, 0);\n                var w6 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, oy);\n                var w7 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, oy);\n                var w8 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, oy);\n    \n                var pattern = 0;\n    \n                if (this.is_different(w0, w4)) pattern |= (1 << 0);\n                if (this.is_different(w1, w4)) pattern |= (1 << 1);\n                if (this.is_different(w2, w4)) pattern |= (1 << 2);\n                if (this.is_different(w3, w4)) pattern |= (1 << 3);\n                if (this.is_different(w5, w4)) pattern |= (1 << 4);\n                if (this.is_different(w6, w4)) pattern |= (1 << 5);\n                if (this.is_different(w7, w4)) pattern |= (1 << 6);\n                if (this.is_different(w8, w4)) pattern |= (1 << 7);\n    \n                if ((this.P(pattern, 0xbf, 0x37) || this.P(pattern, 0xdb, 0x13)) && this.is_different(w1, w5))\n                    return this.mix(w4, w3, 0.5 - px);\n    \n                if ((this.P(pattern, 0xdb, 0x49) || this.P(pattern, 0xef, 0x6d)) && this.is_different(w7, w3))\n                    return this.mix(w4, w1, 0.5 - py);\n    \n                if ((this.P(pattern, 0x0b, 0x0b) || this.P(pattern, 0xfe, 0x4a) || this.P(pattern, 0xfe, 0x1a)) && this.is_different(w3, w1))\n                    return w4;\n    \n                if ((this.P(pattern, 0x6f, 0x2a) || this.P(pattern, 0x5b, 0x0a) || this.P(pattern, 0xbf, 0x3a) || this.P(pattern, 0xdf, 0x5a) || this.P(pattern, 0x9f, 0x8a) || this.P(pattern, 0xcf, 0x8a) || this.P(pattern, 0xef, 0x4e) || this.P(pattern, 0x3f, 0x0e) ||\n                    this.P(pattern, 0xfb, 0x5a) || this.P(pattern, 0xbb, 0x8a) || this.P(pattern, 0x7f, 0x5a) || this.P(pattern, 0xaf, 0x8a) || this.P(pattern, 0xeb, 0x8a)) && this.is_different(w3, w1))\n                    return this.mix(w4, this.mix(w4, w0, 0.5 - px), 0.5 - py);\n    \n                if (this.P(pattern, 0x0b, 0x08))\n                    return this.mix(this.mix(this.Mul(w0, 0.375) + this.Mul(w1, 0.25) + this.Mul(w4, 0.375), this.Mul(w4, 0.5) + this.Mul(w1, 0.5), px * 2.0), w4, py * 2.0);\n    \n                if (this.P(pattern, 0x0b, 0x02))\n                    return this.mix(this.mix(this.Mul(w0, 0.375) + this.Mul(w3, 0.25) + this.Mul(w4, 0.375), this.Mul(w4, 0.5) + this.Mul(w3, 0.5), py * 2.0), w4, px * 2.0);\n    \n                var r, dist, pixel_size;\n    \n                if (this.P(pattern, 0x2f, 0x2f)) {\n    \n                    dist = this.length(px - 0.5, py - 0.5);\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist > 0.5 + pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(w4, r, (dist - 0.5 + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xbf, 0x37) || this.P(pattern, 0xdb, 0x13)) {\n    \n                    dist = px - 2.0 * py;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (dist > pixel_size / 2) {\n    \n                        return w1;\n                    }\n    \n                    r = this.mix(w3, w4, px + 0.5);\n    \n                    if (dist < -pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w1, (dist + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xdb, 0x49) || this.P(pattern, 0xef, 0x6d)) {\n    \n                    dist = py - 2.0 * px;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (py - 2.0 * px > pixel_size / 2) {\n    \n                        return w3;\n                    }\n    \n                    r = this.mix(w1, w4, px + 0.5);\n    \n                    if (dist < -pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w3, (dist + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xbf, 0x8f) || this.P(pattern, 0x7e, 0x0e)) {\n    \n                    dist = px + 2.0 * py;\n    \n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (dist > 1.0 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 1.0 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 1.0) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x7e, 0x2a) || this.P(pattern, 0xef, 0xab)) {\n    \n                    dist = py + 2.0 * px;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (py + 2.0 * px > 1.0 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 1.0 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 1.0) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x1b, 0x03) || this.P(pattern, 0x4f, 0x43) || this.P(pattern, 0x8b, 0x83) || this.P(pattern, 0x6b, 0x43))\n                    return this.mix(w4, w3, 0.5 - px);\n    \n                if (this.P(pattern, 0x4b, 0x09) || this.P(pattern, 0x8b, 0x89) || this.P(pattern, 0x1f, 0x19) || this.P(pattern, 0x3b, 0x19))\n                    return this.mix(w4, w1, 0.5 - py);\n    \n                if (this.P(pattern, 0xfb, 0x6a) || this.P(pattern, 0x6f, 0x6e) || this.P(pattern, 0x3f, 0x3e) || this.P(pattern, 0xfb, 0xfa) || this.P(pattern, 0xdf, 0xde) || this.P(pattern, 0xdf, 0x1e))\n                    return this.mix(w4, w0, (1.0 - px - py) / 2.0);\n    \n                if (this.P(pattern, 0x4f, 0x4b) || this.P(pattern, 0x9f, 0x1b) || this.P(pattern, 0x2f, 0x0b) || this.P(pattern, 0xbe, 0x0a) || this.P(pattern, 0xee, 0x0a) || this.P(pattern, 0x7e, 0x0a) || this.P(pattern, 0xeb, 0x4b) || this.P(pattern, 0x3b, 0x1b)) {\n    \n                    dist = px + py;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                    if (dist > 0.5 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 0.5) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x0b, 0x01))\n                    return this.mix(this.mix(w4, w3, 0.5 - px), this.mix(w1, this.Add(w1, w3, 0.5), 0.5 - px), 0.5 - py);\n    \n                if (this.P(pattern, 0x0b, 0x00))\n                    return this.mix(this.mix(w4, w3, 0.5 - px), this.mix(w1, w0, 0.5 - px), 0.5 - py);\n    \n                dist = px + py;\n                pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                if (dist > 0.5 + pixel_size / 2)\n                    return w4;\n    \n                /* We need more samples to \"solve\" this diagonal */\n                var x0 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, -oy);\n                var x1 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, -oy * 2.0);\n                var x2 = Common.CLR(image, srcx, srcy, positionx, positiony, 0.0, -oy * 2.0);\n                var x3 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, -oy * 2.0);\n                var x4 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, -oy);\n                var x5 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, 0.0);\n                var x6 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, oy);\n    \n                if (this.is_different(x0, w4)) pattern |= 1 << 8;\n                if (this.is_different(x1, w4)) pattern |= 1 << 9;\n                if (this.is_different(x2, w4)) pattern |= 1 << 10;\n                if (this.is_different(x3, w4)) pattern |= 1 << 11;\n                if (this.is_different(x4, w4)) pattern |= 1 << 12;\n                if (this.is_different(x5, w4)) pattern |= 1 << 13;\n                if (this.is_different(x6, w4)) pattern |= 1 << 14;\n    \n                var diagonal_bias = -7;\n    \n                while (pattern != 0) {\n    \n                    diagonal_bias += pattern & 1;\n                    pattern >>= 1;\n                }\n    \n                if (diagonal_bias <= 0) {\n    \n                    r = this.mix(w1, w3, py - px + 0.5);\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 0.5) / pixel_size);\n                }\n    \n                return w4;\n            }\n        }\n    \n        const fltr = new Filter();\n        return fltr.Apply(image_data.data, image_data.width, image_data.height, scale, 1);\n    }",t.exports={omniscale:function n(e,i,r){var s=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s?s.exec(window.omniscale_process_function_string,[e,i]).catch(function(t){return"Pool terminated"===t?n(e,i,r,s):new Function(window.omniscale_process_function_string)()(e,i)}).then(function(t){r(t)}).then(function(){s.terminate()}).timeout(36e4):new Function(window.omniscale_process_function_string)()(e,i).then(function(t){r(t)}).then()}}},956:function(t,n,e){"use strict";var e=e(313),r=e&&e.__esModule?e:{default:e};window.image_tracer_process_function_string="return function(image_data, options){\n\n\tfunction ImageTracer(){\n\t\tvar _this = this;\n\n\t\tthis.versionnumber = '1.2.6',\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  API\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Loading an image from a URL, tracing when loaded,\n\t\t// then executing callback with the scaled svg string as argument\n\t\tthis.imageToSVG = function( url, callback, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// loading image, tracing and callback\n\t\t\t_this.loadImage(\n\t\t\t\turl,\n\t\t\t\tfunction(canvas){\n\t\t\t\t\tcallback(\n\t\t\t\t\t\t_this.imagedataToSVG( _this.getImgdata(canvas), options )\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\toptions\n\t\t\t);\n\t\t},// End of imageToSVG()\n\n\t\t// Tracing imagedata, then returning the scaled svg string\n\t\tthis.imagedataToSVG = function( imgd, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// tracing imagedata\n\t\t\tvar td = _this.imagedataToTracedata( imgd, options );\n\t\t\t// returning SVG string\n\t\t\treturn _this.getsvgstring(td, options);\n\t\t},// End of imagedataToSVG()\n\n\t\t// Loading an image from a URL, tracing when loaded,\n\t\t// then executing callback with tracedata as argument\n\t\tthis.imageToTracedata = function( url, callback, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// loading image, tracing and callback\n\t\t\t_this.loadImage(\n\t\t\t\t\turl,\n\t\t\t\t\tfunction(canvas){\n\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t_this.imagedataToTracedata( _this.getImgdata(canvas), options )\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\toptions\n\t\t\t);\n\t\t},// End of imageToTracedata()\n\n\t\t// Tracing imagedata, then returning tracedata (layers with paths, palette, image size)\n\t\tthis.imagedataToTracedata = function( imgd, options ){\n\t\t\toptions = _this.checkoptions(options);\n\n\t\t\t// 1. Color quantization\n\t\t\tvar ii = _this.colorquantization( imgd, options );\n\n\t\t\tif(options.layering === 0){// Sequential layering\n\n\t\t\t\t// create tracedata object\n\t\t\t\tvar tracedata = {\n\t\t\t\t\tlayers : [],\n\t\t\t\t\tpalette : ii.palette,\n\t\t\t\t\twidth : ii.array[0].length-2,\n\t\t\t\t\theight : ii.array.length-2\n\t\t\t\t};\n\n\t\t\t\t// Loop to trace each color layer\n\t\t\t\tfor(var colornum=0; colornum<ii.palette.length; colornum++){\n\n\t\t\t\t\t// layeringstep -> pathscan -> internodes -> batchtracepaths\n\t\t\t\t\tvar tracedlayer =\n\t\t\t\t\t\t_this.batchtracepaths(\n\n\t\t\t\t\t\t\t_this.internodes(\n\n\t\t\t\t\t\t\t\t_this.pathscan(\n\t\t\t\t\t\t\t\t\t_this.layeringstep( ii, colornum ),\n\t\t\t\t\t\t\t\t\toptions.pathomit\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\toptions\n\n\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\toptions.ltres,\n\t\t\t\t\t\t\toptions.qtres\n\n\t\t\t\t\t\t);\n\n\t\t\t\t\t// adding traced layer\n\t\t\t\t\ttracedata.layers.push(tracedlayer);\n\n\t\t\t\t}// End of color loop\n\n\t\t\t}else{// Parallel layering\n\t\t\t\t// 2. Layer separation and edge detection\n\t\t\t\tvar ls = _this.layering( ii );\n\n\t\t\t\t// Optional edge node visualization\n\t\t\t\tif(options.layercontainerid){ _this.drawLayers( ls, _this.specpalette, options.scale, options.layercontainerid ); }\n\n\t\t\t\t// 3. Batch pathscan\n\t\t\t\tvar bps = _this.batchpathscan( ls, options.pathomit );\n\n\t\t\t\t// 4. Batch interpollation\n\t\t\t\tvar bis = _this.batchinternodes( bps, options );\n\n\t\t\t\t// 5. Batch tracing and creating tracedata object\n\t\t\t\tvar tracedata = {\n\t\t\t\t\tlayers : _this.batchtracelayers( bis, options.ltres, options.qtres ),\n\t\t\t\t\tpalette : ii.palette,\n\t\t\t\t\twidth : imgd.width,\n\t\t\t\t\theight : imgd.height\n\t\t\t\t};\n\n\t\t\t}// End of parallel layering\n\n\t\t\t// return tracedata\n\t\t\treturn tracedata;\n\n\t\t},// End of imagedataToTracedata()\n\n\t\tthis.optionpresets = {\n\t\t\t'default': {\n\n\t\t\t\t// Tracing\n\t\t\t\tcorsenabled : false,\n\t\t\t\tltres : 1,\n\t\t\t\tqtres : 1,\n\t\t\t\tpathomit : 8,\n\t\t\t\trightangleenhance : true,\n\n\t\t\t\t// Color quantization\n\t\t\t\tcolorsampling : 2,\n\t\t\t\tnumberofcolors : 16,\n\t\t\t\tmincolorratio : 0,\n\t\t\t\tcolorquantcycles : 3,\n\n\t\t\t\t// Layering method\n\t\t\t\tlayering : 0,\n\n\t\t\t\t// SVG rendering\n\t\t\t\tstrokewidth : 1,\n\t\t\t\tlinefilter : false,\n\t\t\t\tscale : 1,\n\t\t\t\troundcoords : 1,\n\t\t\t\tviewbox : false,\n\t\t\t\tdesc : false,\n\t\t\t\tlcpr : 0,\n\t\t\t\tqcpr : 0,\n\n\t\t\t\t// Blur\n\t\t\t\tblurradius : 0,\n\t\t\t\tblurdelta : 20\n\n\t\t\t},\n\t\t\t'posterized1': { colorsampling:0, numberofcolors:2 },\n\t\t\t'posterized2': { numberofcolors:4, blurradius:5 },\n\t\t\t'curvy': { ltres:0.01, linefilter:true, rightangleenhance:false },\n\t\t\t'sharp': { qtres:0.01, linefilter:false },\n\t\t\t'detailed': { pathomit:0, roundcoords:2, ltres:0.5, qtres:0.5, numberofcolors:64 },\n\t\t\t'smoothed': { blurradius:5, blurdelta: 64 },\n\t\t\t'grayscale': { colorsampling:0, colorquantcycles:1, numberofcolors:7 },\n\t\t\t'fixedpalette': { colorsampling:0, colorquantcycles:1, numberofcolors:27 },\n\t\t\t'randomsampling1': { colorsampling:1, numberofcolors:8 },\n\t\t\t'randomsampling2': { colorsampling:1, numberofcolors:64 },\n\t\t\t'artistic1': { colorsampling:0, colorquantcycles:1, pathomit:0, blurradius:5, blurdelta: 64, ltres:0.01, linefilter:true, numberofcolors:16, strokewidth:2 },\n\t\t\t'artistic2': { qtres:0.01, colorsampling:0, colorquantcycles:1, numberofcolors:4, strokewidth:0 },\n\t\t\t'artistic3': { qtres:10, ltres:10, numberofcolors:8 },\n\t\t\t'artistic4': { qtres:10, ltres:10, numberofcolors:64, blurradius:5, blurdelta: 256, strokewidth:2 },\n\t\t\t'posterized3': { ltres: 1, qtres: 1, pathomit: 20, rightangleenhance: true, colorsampling: 0, numberofcolors: 3,\n\t\t\t\tmincolorratio: 0, colorquantcycles: 3, blurradius: 3, blurdelta: 20, strokewidth: 0, linefilter: false,\n\t\t\t\troundcoords: 1, pal: [ { r: 0, g: 0, b: 100, a: 255 }, { r: 255, g: 255, b: 255, a: 255 } ] }\n\t\t},// End of optionpresets\n\n\t\t// creating options object, setting defaults for missing values\n\t\tthis.checkoptions = function(options){\n\t\t\toptions = options || {};\n\t\t\t// Option preset\n\t\t\tif(typeof options === 'string'){\n\t\t\t\toptions = options.toLowerCase();\n\t\t\t\tif( _this.optionpresets[options] ){ options = _this.optionpresets[options]; }else{ options = {}; }\n\t\t\t}\n\t\t\t// Defaults\n\t\t\tvar ok = Object.keys(_this.optionpresets['default']);\n\t\t\tfor(var k=0; k<ok.length; k++){\n\t\t\t\tif(!options.hasOwnProperty(ok[k])){ options[ok[k]] = _this.optionpresets['default'][ok[k]]; }\n\t\t\t}\n\t\t\t// options.pal is not defined here, the custom palette should be added externally: options.pal = [ { 'r':0, 'g':0, 'b':0, 'a':255 }, {...}, ... ];\n\t\t\t// options.layercontainerid is not defined here, can be added externally: options.layercontainerid = 'mydiv'; ... <div id=\"mydiv\"></div>\n\t\t\treturn options;\n\t\t},// End of checkoptions()\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  Vectorizing functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// 1. Color quantization\n\t\t// Using a form of k-means clustering repeatead options.colorquantcycles times. http://en.wikipedia.org/wiki/Color_quantization\n\t\tthis.colorquantization = function( imgd, options ){\n\t\t\tvar arr = [], idx=0, cd,cdl,ci, paletteacc = [], pixelnum = imgd.width * imgd.height, i, j, k, cnt, palette;\n\n\t\t\t// imgd.data must be RGBA, not just RGB\n\t\t\tif( imgd.data.length < pixelnum * 4 ){\n\t\t\t\tvar newimgddata = new Uint8ClampedArray(pixelnum * 4);\n\t\t\t\tfor(var pxcnt = 0; pxcnt < pixelnum ; pxcnt++){\n\t\t\t\t\tnewimgddata[pxcnt*4  ] = imgd.data[pxcnt*3  ];\n\t\t\t\t\tnewimgddata[pxcnt*4+1] = imgd.data[pxcnt*3+1];\n\t\t\t\t\tnewimgddata[pxcnt*4+2] = imgd.data[pxcnt*3+2];\n\t\t\t\t\tnewimgddata[pxcnt*4+3] = 255;\n\t\t\t\t}\n\t\t\t\timgd.data = newimgddata;\n\t\t\t}// End of RGBA imgd.data check\n\n\t\t\t// Filling arr (color index array) with -1\n\t\t\tfor( j=0; j<imgd.height+2; j++ ){ arr[j]=[]; for(i=0; i<imgd.width+2 ; i++){ arr[j][i] = -1; } }\n\n\t\t\t// Use custom palette if pal is defined or sample / generate custom length palette\n\t\t\tif(options.pal){\n\t\t\t\tpalette = options.pal;\n\t\t\t}else if(options.colorsampling === 0){\n\t\t\t\tpalette = _this.generatepalette(options.numberofcolors);\n\t\t\t}else if(options.colorsampling === 1){\n\t\t\t\tpalette = _this.samplepalette( options.numberofcolors, imgd );\n\t\t\t}else{\n\t\t\t\tpalette = _this.samplepalette2( options.numberofcolors, imgd );\n\t\t\t}\n\n\t\t\t// Selective Gaussian blur preprocessing\n\t\t\tif( options.blurradius > 0 ){ imgd = _this.blur( imgd, options.blurradius, options.blurdelta ); }\n\n\t\t\t// Repeat clustering step options.colorquantcycles times\n\t\t\tfor( cnt=0; cnt < options.colorquantcycles; cnt++ ){\n\n\t\t\t\t// Average colors from the second iteration\n\t\t\t\tif(cnt>0){\n\t\t\t\t\t// averaging paletteacc for palette\n\t\t\t\t\tfor( k=0; k < palette.length; k++ ){\n\n\t\t\t\t\t\t// averaging\n\t\t\t\t\t\tif( paletteacc[k].n > 0 ){\n\t\t\t\t\t\t\tpalette[k] = {  r: Math.floor( paletteacc[k].r / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\tg: Math.floor( paletteacc[k].g / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\tb: Math.floor( paletteacc[k].b / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\ta:  Math.floor( paletteacc[k].a / paletteacc[k].n ) };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Randomizing a color, if there are too few pixels and there will be a new cycle\n\t\t\t\t\t\tif( ( paletteacc[k].n/pixelnum < options.mincolorratio ) && ( cnt < options.colorquantcycles-1 ) ){\n\t\t\t\t\t\t\tpalette[k] = {  r: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\tg: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\tb: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\ta: Math.floor(Math.random()*255) };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}// End of palette loop\n\t\t\t\t}// End of Average colors from the second iteration\n\n\t\t\t\t// Reseting palette accumulator for averaging\n\t\t\t\tfor( i=0; i < palette.length; i++ ){ paletteacc[i] = { r:0, g:0, b:0, a:0, n:0 }; }\n\n\t\t\t\t// loop through all pixels\n\t\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\t\t// pixel index\n\t\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\n\t\t\t\t\t\t// find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors\n\t\t\t\t\t\tci=0; cdl = 1024; // 4 * 256 is the maximum RGBA distance\n\t\t\t\t\t\tfor( k=0; k<palette.length; k++ ){\n\n\t\t\t\t\t\t\t// In my experience, https://en.wikipedia.org/wiki/Rectilinear_distance works better than https://en.wikipedia.org/wiki/Euclidean_distance\n\t\t\t\t\t\t\tcd =\n\t\t\t\t\t\t\t\t( palette[k].r > imgd.data[idx  ] ? palette[k].r - imgd.data[idx  ] : imgd.data[idx  ] - palette[k].r ) +\n\t\t\t\t\t\t\t\t( palette[k].g > imgd.data[idx+1] ? palette[k].g - imgd.data[idx+1] : imgd.data[idx+1] - palette[k].g ) +\n\t\t\t\t\t\t\t\t( palette[k].b > imgd.data[idx+2] ? palette[k].b - imgd.data[idx+2] : imgd.data[idx+2] - palette[k].b ) +\n\t\t\t\t\t\t\t\t( palette[k].a > imgd.data[idx+3] ? palette[k].a - imgd.data[idx+3] : imgd.data[idx+3] - palette[k].a );\n\n\t\t\t\t\t\t\t// Remember this color if this is the closest yet\n\t\t\t\t\t\t\tif(cd<cdl){ cdl = cd; ci = k; }\n\n\t\t\t\t\t\t}// End of palette loop\n\n\t\t\t\t\t\t// add to palettacc\n\t\t\t\t\t\tpaletteacc[ci].r += imgd.data[idx  ];\n\t\t\t\t\t\tpaletteacc[ci].g += imgd.data[idx+1];\n\t\t\t\t\t\tpaletteacc[ci].b += imgd.data[idx+2];\n\t\t\t\t\t\tpaletteacc[ci].a += imgd.data[idx+3];\n\t\t\t\t\t\tpaletteacc[ci].n++;\n\n\t\t\t\t\t\t// update the indexed color array\n\t\t\t\t\t\tarr[j+1][i+1] = ci;\n\n\t\t\t\t\t}// End of i loop\n\t\t\t\t}// End of j loop\n\n\t\t\t}// End of Repeat clustering step options.colorquantcycles times\n\n\t\t\treturn { array:arr, palette:palette };\n\n\t\t},// End of colorquantization()\n\n\t\t// Sampling a palette from imagedata\n\t\tthis.samplepalette = function( numberofcolors, imgd ){\n\t\t\tvar idx, palette=[];\n\t\t\tfor(var i=0; i<numberofcolors; i++){\n\t\t\t\tidx = Math.floor( Math.random() * imgd.data.length / 4 ) * 4;\n\t\t\t\tpalette.push({ r:imgd.data[idx  ], g:imgd.data[idx+1], b:imgd.data[idx+2], a:imgd.data[idx+3] });\n\t\t\t}\n\t\t\treturn palette;\n\t\t},// End of samplepalette()\n\n\t\t// Deterministic sampling a palette from imagedata: rectangular grid\n\t\tthis.samplepalette2 = function( numberofcolors, imgd ){\n\t\t\tvar idx, palette=[], ni = Math.ceil(Math.sqrt(numberofcolors)), nj = Math.ceil(numberofcolors/ni),\n\t\t\t\tvx = imgd.width / (ni+1), vy = imgd.height / (nj+1);\n\t\t\tfor(var j=0; j<nj; j++){\n\t\t\t\tfor(var i=0; i<ni; i++){\n\t\t\t\t\tif(palette.length === numberofcolors){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tidx = Math.floor( ((j+1)*vy) * imgd.width + ((i+1)*vx) ) * 4;\n\t\t\t\t\t\tpalette.push( { r:imgd.data[idx], g:imgd.data[idx+1], b:imgd.data[idx+2], a:imgd.data[idx+3] } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn palette;\n\t\t},// End of samplepalette2()\n\n\t\t// Generating a palette with numberofcolors\n\t\tthis.generatepalette = function(numberofcolors){\n\t\t\tvar palette = [], rcnt, gcnt, bcnt;\n\t\t\tif(numberofcolors<8){\n\n\t\t\t\t// Grayscale\n\t\t\t\tvar graystep = Math.floor(255/(numberofcolors-1));\n\t\t\t\tfor(var i=0; i<numberofcolors; i++){ palette.push({ r:i*graystep, g:i*graystep, b:i*graystep, a:255 }); }\n\n\t\t\t}else{\n\n\t\t\t\t// RGB color cube\n\t\t\t\tvar colorqnum = Math.floor(Math.pow(numberofcolors, 1/3)), // Number of points on each edge on the RGB color cube\n\t\t\t\t\tcolorstep = Math.floor(255/(colorqnum-1)), // distance between points\n\t\t\t\t\trndnum = numberofcolors - colorqnum*colorqnum*colorqnum; // number of random colors\n\n\t\t\t\tfor(rcnt=0; rcnt<colorqnum; rcnt++){\n\t\t\t\t\tfor(gcnt=0; gcnt<colorqnum; gcnt++){\n\t\t\t\t\t\tfor(bcnt=0; bcnt<colorqnum; bcnt++){\n\t\t\t\t\t\t\tpalette.push( { r:rcnt*colorstep, g:gcnt*colorstep, b:bcnt*colorstep, a:255 } );\n\t\t\t\t\t\t}// End of blue loop\n\t\t\t\t\t}// End of green loop\n\t\t\t\t}// End of red loop\n\n\t\t\t\t// Rest is random\n\t\t\t\tfor(rcnt=0; rcnt<rndnum; rcnt++){ palette.push({ r:Math.floor(Math.random()*255), g:Math.floor(Math.random()*255), b:Math.floor(Math.random()*255), a:Math.floor(Math.random()*255) }); }\n\n\t\t\t}// End of numberofcolors check\n\n\t\t\treturn palette;\n\t\t},// End of generatepalette()\n\n\t\t// 2. Layer separation and edge detection\n\t\t// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n\t\t// 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n\t\t// 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n\t\t//     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\n\t\tthis.layering = function(ii){\n\t\t\t// Creating layers for each indexed color in arr\n\t\t\tvar layers = [], val=0, ah = ii.array.length, aw = ii.array[0].length, n1,n2,n3,n4,n5,n6,n7,n8, i, j, k;\n\n\t\t\t// Create layers\n\t\t\tfor(k=0; k<ii.palette.length; k++){\n\t\t\t\tlayers[k] = [];\n\t\t\t\tfor(j=0; j<ah; j++){\n\t\t\t\t\tlayers[k][j] = [];\n\t\t\t\t\tfor(i=0; i<aw; i++){\n\t\t\t\t\t\tlayers[k][j][i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Looping through all pixels and calculating edge node type\n\t\t\tfor(j=1; j<ah-1; j++){\n\t\t\t\tfor(i=1; i<aw-1; i++){\n\n\t\t\t\t\t// This pixel's indexed color\n\t\t\t\t\tval = ii.array[j][i];\n\n\t\t\t\t\t// Are neighbor pixel colors the same?\n\t\t\t\t\tn1 = ii.array[j-1][i-1]===val ? 1 : 0;\n\t\t\t\t\tn2 = ii.array[j-1][i  ]===val ? 1 : 0;\n\t\t\t\t\tn3 = ii.array[j-1][i+1]===val ? 1 : 0;\n\t\t\t\t\tn4 = ii.array[j  ][i-1]===val ? 1 : 0;\n\t\t\t\t\tn5 = ii.array[j  ][i+1]===val ? 1 : 0;\n\t\t\t\t\tn6 = ii.array[j+1][i-1]===val ? 1 : 0;\n\t\t\t\t\tn7 = ii.array[j+1][i  ]===val ? 1 : 0;\n\t\t\t\t\tn8 = ii.array[j+1][i+1]===val ? 1 : 0;\n\n\t\t\t\t\t// this pixel's type and looking back on previous pixels\n\t\t\t\t\tlayers[val][j+1][i+1] = 1 + n5 * 2 + n8 * 4 + n7 * 8 ;\n\t\t\t\t\tif(!n4){ layers[val][j+1][i  ] = 0 + 2 + n7 * 4 + n6 * 8 ; }\n\t\t\t\t\tif(!n2){ layers[val][j  ][i+1] = 0 + n3*2 + n5 * 4 + 8 ; }\n\t\t\t\t\tif(!n1){ layers[val][j  ][i  ] = 0 + n2*2 + 4 + n4 * 8 ; }\n\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn layers;\n\t\t},// End of layering()\n\n\t\t// 2. Layer separation and edge detection\n\t\t// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n\t\t// 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n\t\t// 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n\t\t//     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\n\t\tthis.layeringstep = function(ii,cnum){\n\t\t\t// Creating layers for each indexed color in arr\n\t\t\tvar layer = [], val=0, ah = ii.array.length, aw = ii.array[0].length, n1,n2,n3,n4,n5,n6,n7,n8, i, j, k;\n\n\t\t\t// Create layer\n\t\t\tfor(j=0; j<ah; j++){\n\t\t\t\tlayer[j] = [];\n\t\t\t\tfor(i=0; i<aw; i++){\n\t\t\t\t\tlayer[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Looping through all pixels and calculating edge node type\n\t\t\tfor(j=1; j<ah; j++){\n\t\t\t\tfor(i=1; i<aw; i++){\n\t\t\t\t\tlayer[j][i] =\n\t\t\t\t\t\t( ii.array[j-1][i-1]===cnum ? 1 : 0 ) +\n\t\t\t\t\t\t( ii.array[j-1][i]===cnum ? 2 : 0 ) +\n\t\t\t\t\t\t( ii.array[j][i-1]===cnum ? 8 : 0 ) +\n\t\t\t\t\t\t( ii.array[j][i]===cnum ? 4 : 0 )\n\t\t\t\t\t;\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn layer;\n\t\t},// End of layeringstep()\n\n\t\t// Point in polygon test\n\t\tthis.pointinpoly = function( p, pa ){\n\t\t\tvar isin=false;\n\n\t\t\tfor(var i=0,j=pa.length-1; i<pa.length; j=i++){\n\t\t\t\tisin =\n\t\t\t\t\t( ((pa[i].y > p.y) !== (pa[j].y > p.y)) && (p.x < (pa[j].x - pa[i].x) * (p.y - pa[i].y) / (pa[j].y - pa[i].y) + pa[i].x) )\n\t\t\t\t\t? !isin : isin;\n\t\t\t}\n\n\t\t\treturn isin;\n\t\t},\n\n\t\t// Lookup tables for pathscan\n\t\t// pathscan_combined_lookup[ arr[py][px] ][ dir ] = [nextarrpypx, nextdir, deltapx, deltapy];\n\t\tthis.pathscan_combined_lookup = [\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1]],// arr[py][px]===0 is invalid\n\t\t\t[[ 0, 1, 0,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 1, 0,-1], [ 0, 0, 1, 0]],\n\t\t\t[[ 0, 0, 1, 0], [-1,-1,-1,-1], [ 0, 2,-1, 0], [-1,-1,-1,-1]],\n\n\t\t\t[[-1,-1,-1,-1], [ 0, 0, 1, 0], [ 0, 3, 0, 1], [-1,-1,-1,-1]],\n\t\t\t[[13, 3, 0, 1], [13, 2,-1, 0], [ 7, 1, 0,-1], [ 7, 0, 1, 0]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 1, 0,-1], [-1,-1,-1,-1], [ 0, 3, 0, 1]],\n\t\t\t[[ 0, 3, 0, 1], [ 0, 2,-1, 0], [-1,-1,-1,-1], [-1,-1,-1,-1]],\n\n\t\t\t[[ 0, 3, 0, 1], [ 0, 2,-1, 0], [-1,-1,-1,-1], [-1,-1,-1,-1]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 1, 0,-1], [-1,-1,-1,-1], [ 0, 3, 0, 1]],\n\t\t\t[[11, 1, 0,-1], [14, 0, 1, 0], [14, 3, 0, 1], [11, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 0, 1, 0], [ 0, 3, 0, 1], [-1,-1,-1,-1]],\n\n\t\t\t[[ 0, 0, 1, 0], [-1,-1,-1,-1], [ 0, 2,-1, 0], [-1,-1,-1,-1]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 1, 0,-1], [ 0, 0, 1, 0]],\n\t\t\t[[ 0, 1, 0,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1]]// arr[py][px]===15 is invalid\n\t\t],\n\n\t\t// 3. Walking through an edge node array, discarding edge node types 0 and 15 and creating paths from the rest.\n\t\t// Walk directions (dir): 0 > ; 1 ^ ; 2 < ; 3 v\n\t\tthis.pathscan = function( arr, pathomit ){\n\t\t\tvar paths=[], pacnt=0, pcnt=0, px=0, py=0, w = arr[0].length, h = arr.length,\n\t\t\t\tdir=0, pathfinished=true, holepath=false, lookuprow;\n\n\t\t\tfor(var j=0; j<h; j++){\n\t\t\t\tfor(var i=0; i<w; i++){\n\t\t\t\t\tif( (arr[j][i] == 4) || ( arr[j][i] == 11) ){ // Other values are not valid\n\n\t\t\t\t\t\t// Init\n\t\t\t\t\t\tpx = i; py = j;\n\t\t\t\t\t\tpaths[pacnt] = {};\n\t\t\t\t\t\tpaths[pacnt].points = [];\n\t\t\t\t\t\tpaths[pacnt].boundingbox = [px,py,px,py];\n\t\t\t\t\t\tpaths[pacnt].holechildren = [];\n\t\t\t\t\t\tpathfinished = false;\n\t\t\t\t\t\tpcnt=0;\n\t\t\t\t\t\tholepath = (arr[j][i]==11);\n\t\t\t\t\t\tdir = 1;\n\n\t\t\t\t\t\t// Path points loop\n\t\t\t\t\t\twhile(!pathfinished){\n\n\t\t\t\t\t\t\t// New path point\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt] = {};\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x = px-1;\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y = py-1;\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].t = arr[py][px];\n\n\t\t\t\t\t\t\t// Bounding box\n\t\t\t\t\t\t\tif( (px-1) < paths[pacnt].boundingbox[0] ){ paths[pacnt].boundingbox[0] = px-1; }\n\t\t\t\t\t\t\tif( (px-1) > paths[pacnt].boundingbox[2] ){ paths[pacnt].boundingbox[2] = px-1; }\n\t\t\t\t\t\t\tif( (py-1) < paths[pacnt].boundingbox[1] ){ paths[pacnt].boundingbox[1] = py-1; }\n\t\t\t\t\t\t\tif( (py-1) > paths[pacnt].boundingbox[3] ){ paths[pacnt].boundingbox[3] = py-1; }\n\n\t\t\t\t\t\t\t// Next: look up the replacement, direction and coordinate changes = clear this cell, turn if required, walk forward\n\t\t\t\t\t\t\tlookuprow = _this.pathscan_combined_lookup[ arr[py][px] ][ dir ];\n\t\t\t\t\t\t\tarr[py][px] = lookuprow[0]; dir = lookuprow[1]; px += lookuprow[2]; py += lookuprow[3];\n\n\t\t\t\t\t\t\t// Close path\n\t\t\t\t\t\t\tif( (px-1 === paths[pacnt].points[0].x ) && ( py-1 === paths[pacnt].points[0].y ) ){\n\t\t\t\t\t\t\t\tpathfinished = true;\n\n\t\t\t\t\t\t\t\t// Discarding paths shorter than pathomit\n\t\t\t\t\t\t\t\tif( paths[pacnt].points.length < pathomit ){\n\t\t\t\t\t\t\t\t\tpaths.pop();\n\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\tpaths[pacnt].isholepath = holepath ? true : false;\n\n\t\t\t\t\t\t\t\t\t// Finding the parent shape for this hole\n\t\t\t\t\t\t\t\t\tif(holepath){\n\n\t\t\t\t\t\t\t\t\t\tvar parentidx = 0, parentbbox = [-1,-1,w+1,h+1];\n\t\t\t\t\t\t\t\t\t\tfor(var parentcnt=0; parentcnt < pacnt; parentcnt++){\n\t\t\t\t\t\t\t\t\t\t\tif( (!paths[parentcnt].isholepath) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.boundingboxincludes( paths[parentcnt].boundingbox , paths[pacnt].boundingbox ) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.boundingboxincludes( parentbbox , paths[parentcnt].boundingbox ) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.pointinpoly( paths[pacnt].points[0], paths[parentcnt].points )\n\t\t\t\t\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\t\t\t\t\tparentidx = parentcnt;\n\t\t\t\t\t\t\t\t\t\t\t\tparentbbox = paths[parentcnt].boundingbox;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tpaths[parentidx].holechildren.push( pacnt );\n\n\t\t\t\t\t\t\t\t\t}// End of holepath parent finding\n\n\t\t\t\t\t\t\t\t\tpacnt++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}// End of Close path\n\n\t\t\t\t\t\t\tpcnt++;\n\n\t\t\t\t\t\t}// End of Path points loop\n\n\t\t\t\t\t}// End of Follow path\n\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn paths;\n\t\t},// End of pathscan()\n\n\t\tthis.boundingboxincludes = function( parentbbox, childbbox ){\n\t\t\treturn ( ( parentbbox[0] < childbbox[0] ) && ( parentbbox[1] < childbbox[1] ) && ( parentbbox[2] > childbbox[2] ) && ( parentbbox[3] > childbbox[3] ) );\n\t\t},// End of boundingboxincludes()\n\n\t\t// 3. Batch pathscan\n\t\tthis.batchpathscan = function( layers, pathomit ){\n\t\t\tvar bpaths = [];\n\t\t\tfor(var k in layers){\n\t\t\t\tif(!layers.hasOwnProperty(k)){ continue; }\n\t\t\t\tbpaths[k] = _this.pathscan( layers[k], pathomit );\n\t\t\t}\n\t\t\treturn bpaths;\n\t\t},\n\n\t\t// 4. interpollating between path points for nodes with 8 directions ( East, SouthEast, S, SW, W, NW, N, NE )\n\t\tthis.internodes = function( paths, options ){\n\t\t\tvar ins = [], palen=0, nextidx=0, nextidx2=0, previdx=0, previdx2=0, pacnt, pcnt;\n\n\t\t\t// paths loop\n\t\t\tfor(pacnt=0; pacnt<paths.length; pacnt++){\n\n\t\t\t\tins[pacnt] = {};\n\t\t\t\tins[pacnt].points = [];\n\t\t\t\tins[pacnt].boundingbox = paths[pacnt].boundingbox;\n\t\t\t\tins[pacnt].holechildren = paths[pacnt].holechildren;\n\t\t\t\tins[pacnt].isholepath = paths[pacnt].isholepath;\n\t\t\t\tpalen = paths[pacnt].points.length;\n\n\t\t\t\t// pathpoints loop\n\t\t\t\tfor(pcnt=0; pcnt<palen; pcnt++){\n\n\t\t\t\t\t// next and previous point indexes\n\t\t\t\t\tnextidx = (pcnt+1)%palen; nextidx2 = (pcnt+2)%palen; previdx = (pcnt-1+palen)%palen; previdx2 = (pcnt-2+palen)%palen;\n\n\t\t\t\t\t// right angle enhance\n\t\t\t\t\tif( options.rightangleenhance && _this.testrightangle( paths[pacnt], previdx2, previdx, pcnt, nextidx, nextidx2 ) ){\n\n\t\t\t\t\t\t// Fix previous direction\n\t\t\t\t\t\tif(ins[pacnt].points.length > 0){\n\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].linesegment = _this.getdirection(\n\t\t\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].x,\n\t\t\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].y,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This corner point\n\t\t\t\t\t\tins[pacnt].points.push({\n\t\t\t\t\t\t\tx : paths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\ty : paths[pacnt].points[pcnt].y,\n\t\t\t\t\t\t\tlinesegment : _this.getdirection(\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y,\n\t\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}// End of right angle enhance\n\n\t\t\t\t\t// interpolate between two path points\n\t\t\t\t\tins[pacnt].points.push({\n\t\t\t\t\t\tx : (( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\ty : (( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2),\n\t\t\t\t\t\tlinesegment : _this.getdirection(\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y ) /2)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t});\n\n\t\t\t\t}// End of pathpoints loop\n\n\t\t\t}// End of paths loop\n\n\t\t\treturn ins;\n\t\t},// End of internodes()\n\n\t\tthis.testrightangle = function( path, idx1, idx2, idx3, idx4, idx5 ){\n\t\t\treturn ( (( path.points[idx3].x === path.points[idx1].x) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx2].x) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx4].y) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx5].y)\n\t\t\t\t\t ) ||\n\t\t\t\t\t (( path.points[idx3].y === path.points[idx1].y) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx2].y) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx4].x) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx5].x)\n\t\t\t\t\t )\n\t\t\t);\n\t\t},// End of testrightangle()\n\n\t\tthis.getdirection = function( x1, y1, x2, y2 ){\n\t\t\tvar val = 8;\n\t\t\tif(x1 < x2){\n\t\t\t\tif     (y1 < y2){ val = 1; }// SouthEast\n\t\t\t\telse if(y1 > y2){ val = 7; }// NE\n\t\t\t\telse            { val = 0; }// E\n\t\t\t}else if(x1 > x2){\n\t\t\t\tif     (y1 < y2){ val = 3; }// SW\n\t\t\t\telse if(y1 > y2){ val = 5; }// NW\n\t\t\t\telse            { val = 4; }// W\n\t\t\t}else{\n\t\t\t\tif     (y1 < y2){ val = 2; }// S\n\t\t\t\telse if(y1 > y2){ val = 6; }// N\n\t\t\t\telse            { val = 8; }// center, this should not happen\n\t\t\t}\n\t\t\treturn val;\n\t\t},// End of getdirection()\n\n\t\t// 4. Batch interpollation\n\t\tthis.batchinternodes = function( bpaths, options ){\n\t\t\tvar binternodes = [];\n\t\t\tfor (var k in bpaths) {\n\t\t\t\tif(!bpaths.hasOwnProperty(k)){ continue; }\n\t\t\t\tbinternodes[k] = _this.internodes(bpaths[k], options);\n\t\t\t}\n\t\t\treturn binternodes;\n\t\t},\n\n\t\t// 5. tracepath() : recursively trying to fit straight and quadratic spline segments on the 8 direction internode path\n\n\t\t// 5.1. Find sequences of points with only 2 segment types\n\t\t// 5.2. Fit a straight line on the sequence\n\t\t// 5.3. If the straight line fails (distance error > ltres), find the point with the biggest error\n\t\t// 5.4. Fit a quadratic spline through errorpoint (project this to get controlpoint), then measure errors on every point in the sequence\n\t\t// 5.5. If the spline fails (distance error > qtres), find the point with the biggest error, set splitpoint = fitting point\n\t\t// 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\n\t\tthis.tracepath = function( path, ltres, qtres ){\n\t\t\tvar pcnt=0, segtype1, segtype2, seqend, smp = {};\n\t\t\tsmp.segments = [];\n\t\t\tsmp.boundingbox = path.boundingbox;\n\t\t\tsmp.holechildren = path.holechildren;\n\t\t\tsmp.isholepath = path.isholepath;\n\n\t\t\twhile(pcnt < path.points.length){\n\t\t\t\t// 5.1. Find sequences of points with only 2 segment types\n\t\t\t\tsegtype1 = path.points[pcnt].linesegment; segtype2 = -1; seqend=pcnt+1;\n\t\t\t\twhile(\n\t\t\t\t\t((path.points[seqend].linesegment === segtype1) || (path.points[seqend].linesegment === segtype2) || (segtype2 === -1))\n\t\t\t\t\t&& (seqend < path.points.length-1) ){\n\n\t\t\t\t\tif((path.points[seqend].linesegment!==segtype1) && (segtype2===-1)){ segtype2 = path.points[seqend].linesegment; }\n\t\t\t\t\tseqend++;\n\n\t\t\t\t}\n\t\t\t\tif(seqend === path.points.length-1){ seqend = 0; }\n\n\t\t\t\t// 5.2. - 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\t\t\t\tsmp.segments = smp.segments.concat( _this.fitseq(path, ltres, qtres, pcnt, seqend) );\n\n\t\t\t\t// forward pcnt;\n\t\t\t\tif(seqend>0){ pcnt = seqend; }else{ pcnt = path.points.length; }\n\n\t\t\t}// End of pcnt loop\n\n\t\t\treturn smp;\n\t\t},// End of tracepath()\n\n\t\t// 5.2. - 5.6. recursively fitting a straight or quadratic line segment on this sequence of path nodes,\n\t\t// called from tracepath()\n\t\tthis.fitseq = function( path, ltres, qtres, seqstart, seqend ){\n\t\t\t// return if invalid seqend\n\t\t\tif( (seqend>path.points.length) || (seqend<0) ){ return []; }\n\t\t\t// variables\n\t\t\tvar errorpoint=seqstart, errorval=0, curvepass=true, px, py, dist2;\n\t\t\tvar tl = (seqend-seqstart); if(tl<0){ tl += path.points.length; }\n\t\t\tvar vx = (path.points[seqend].x-path.points[seqstart].x) / tl,\n\t\t\t\tvy = (path.points[seqend].y-path.points[seqstart].y) / tl;\n\n\t\t\t// 5.2. Fit a straight line on the sequence\n\t\t\tvar pcnt = (seqstart+1) % path.points.length, pl;\n\t\t\twhile(pcnt != seqend){\n\t\t\t\tpl = pcnt-seqstart; if(pl<0){ pl += path.points.length; }\n\t\t\t\tpx = path.points[seqstart].x + vx * pl; py = path.points[seqstart].y + vy * pl;\n\t\t\t\tdist2 = (path.points[pcnt].x-px)*(path.points[pcnt].x-px) + (path.points[pcnt].y-py)*(path.points[pcnt].y-py);\n\t\t\t\tif(dist2>ltres){curvepass=false;}\n\t\t\t\tif(dist2>errorval){ errorpoint=pcnt; errorval=dist2; }\n\t\t\t\tpcnt = (pcnt+1)%path.points.length;\n\t\t\t}\n\t\t\t// return straight line if fits\n\t\t\tif(curvepass){ return [{ type:'L', x1:path.points[seqstart].x, y1:path.points[seqstart].y, x2:path.points[seqend].x, y2:path.points[seqend].y }]; }\n\n\t\t\t// 5.3. If the straight line fails (distance error>ltres), find the point with the biggest error\n\t\t\tvar fitpoint = errorpoint; curvepass = true; errorval = 0;\n\n\t\t\t// 5.4. Fit a quadratic spline through this point, measure errors on every point in the sequence\n\t\t\t// helpers and projecting to get control point\n\t\t\tvar t=(fitpoint-seqstart)/tl, t1=(1-t)*(1-t), t2=2*(1-t)*t, t3=t*t;\n\t\t\tvar cpx = (t1*path.points[seqstart].x + t3*path.points[seqend].x - path.points[fitpoint].x)/-t2 ,\n\t\t\t\tcpy = (t1*path.points[seqstart].y + t3*path.points[seqend].y - path.points[fitpoint].y)/-t2 ;\n\n\t\t\t// Check every point\n\t\t\tpcnt = seqstart+1;\n\t\t\twhile(pcnt != seqend){\n\t\t\t\tt=(pcnt-seqstart)/tl; t1=(1-t)*(1-t); t2=2*(1-t)*t; t3=t*t;\n\t\t\t\tpx = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x;\n\t\t\t\tpy = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y;\n\n\t\t\t\tdist2 = (path.points[pcnt].x-px)*(path.points[pcnt].x-px) + (path.points[pcnt].y-py)*(path.points[pcnt].y-py);\n\n\t\t\t\tif(dist2>qtres){curvepass=false;}\n\t\t\t\tif(dist2>errorval){ errorpoint=pcnt; errorval=dist2; }\n\t\t\t\tpcnt = (pcnt+1)%path.points.length;\n\t\t\t}\n\t\t\t// return spline if fits\n\t\t\tif(curvepass){ return [{ type:'Q', x1:path.points[seqstart].x, y1:path.points[seqstart].y, x2:cpx, y2:cpy, x3:path.points[seqend].x, y3:path.points[seqend].y }]; }\n\t\t\t// 5.5. If the spline fails (distance error>qtres), find the point with the biggest error\n\t\t\tvar splitpoint = fitpoint; // Earlier: Math.floor((fitpoint + errorpoint)/2);\n\n\t\t\t// 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\t\t\treturn _this.fitseq( path, ltres, qtres, seqstart, splitpoint ).concat(\n\t\t\t\t\t_this.fitseq( path, ltres, qtres, splitpoint, seqend ) );\n\n\t\t},// End of fitseq()\n\n\t\t// 5. Batch tracing paths\n\t\tthis.batchtracepaths = function(internodepaths,ltres,qtres){\n\t\t\tvar btracedpaths = [];\n\t\t\tfor(var k in internodepaths){\n\t\t\t\tif(!internodepaths.hasOwnProperty(k)){ continue; }\n\t\t\t\tbtracedpaths.push( _this.tracepath(internodepaths[k],ltres,qtres) );\n\t\t\t}\n\t\t\treturn btracedpaths;\n\t\t},\n\n\t\t// 5. Batch tracing layers\n\t\tthis.batchtracelayers = function(binternodes, ltres, qtres){\n\t\t\tvar btbis = [];\n\t\t\tfor(var k in binternodes){\n\t\t\t\tif(!binternodes.hasOwnProperty(k)){ continue; }\n\t\t\t\tbtbis[k] = _this.batchtracepaths(binternodes[k], ltres, qtres);\n\t\t\t}\n\t\t\treturn btbis;\n\t\t},\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  SVG Drawing functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Rounding to given decimals https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n\t\tthis.roundtodec = function(val,places){ return +val.toFixed(places); },\n\n\t\t// Getting SVG path element string from a traced path\n\t\tthis.svgpathstring = function( tracedata, lnum, pathnum, options ){\n\n\t\t\tvar layer = tracedata.layers[lnum], smp = layer[pathnum], str='', pcnt;\n\n\t\t\t// Line filter\n\t\t\tif(options.linefilter && (smp.segments.length < 3)){ return str; }\n\n\t\t\t// Starting path element, desc contains layer and path number\n\t\t\tstr = '<path '+\n\t\t\t\t( options.desc ? ('desc=\"l '+lnum+' p '+pathnum+'\" ') : '' ) +\n\t\t\t\t_this.tosvgcolorstr(tracedata.palette[lnum], options) +\n\t\t\t\t'd=\"';\n\n\t\t\t// Creating non-hole path string\n\t\t\tif( options.roundcoords === -1 ){\n\t\t\t\tstr += 'M '+ smp.segments[0].x1 * options.scale +' '+ smp.segments[0].y1 * options.scale +' ';\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tstr += smp.segments[pcnt].type +' '+ smp.segments[pcnt].x2 * options.scale +' '+ smp.segments[pcnt].y2 * options.scale +' ';\n\t\t\t\t\tif(smp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += smp.segments[pcnt].x3 * options.scale +' '+ smp.segments[pcnt].y3 * options.scale +' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += 'Z ';\n\t\t\t}else{\n\t\t\t\tstr += 'M '+ _this.roundtodec( smp.segments[0].x1 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[0].y1 * options.scale, options.roundcoords ) +' ';\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tstr += smp.segments[pcnt].type +' '+ _this.roundtodec( smp.segments[pcnt].x2 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[pcnt].y2 * options.scale, options.roundcoords ) +' ';\n\t\t\t\t\tif(smp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += _this.roundtodec( smp.segments[pcnt].x3 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[pcnt].y3 * options.scale, options.roundcoords ) +' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += 'Z ';\n\t\t\t}// End of creating non-hole path string\n\n\t\t\t// Hole children\n\t\t\tfor( var hcnt=0; hcnt < smp.holechildren.length; hcnt++){\n\t\t\t\tvar hsmp = layer[ smp.holechildren[hcnt] ];\n\t\t\t\t// Creating hole path string\n\t\t\t\tif( options.roundcoords === -1 ){\n\n\t\t\t\t\tif(hsmp.segments[ hsmp.segments.length-1 ].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += 'M '+ hsmp.segments[ hsmp.segments.length-1 ].x3 * options.scale +' '+ hsmp.segments[ hsmp.segments.length-1 ].y3 * options.scale +' ';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr += 'M '+ hsmp.segments[ hsmp.segments.length-1 ].x2 * options.scale +' '+ hsmp.segments[ hsmp.segments.length-1 ].y2 * options.scale +' ';\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(pcnt = hsmp.segments.length-1; pcnt >= 0; pcnt--){\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].type +' ';\n\t\t\t\t\t\tif(hsmp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\t\tstr += hsmp.segments[pcnt].x2 * options.scale +' '+ hsmp.segments[pcnt].y2 * options.scale +' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].x1 * options.scale +' '+ hsmp.segments[pcnt].y1 * options.scale +' ';\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(hsmp.segments[ hsmp.segments.length-1 ].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += 'M '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].x3 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].y3 * options.scale ) +' ';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr += 'M '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].x2 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].y2 * options.scale ) +' ';\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(pcnt = hsmp.segments.length-1; pcnt >= 0; pcnt--){\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].type +' ';\n\t\t\t\t\t\tif(hsmp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\t\tstr += _this.roundtodec( hsmp.segments[pcnt].x2 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[pcnt].y2 * options.scale ) +' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += _this.roundtodec( hsmp.segments[pcnt].x1 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[pcnt].y1 * options.scale ) +' ';\n\t\t\t\t\t}\n\n\n\t\t\t\t}// End of creating hole path string\n\n\t\t\t\tstr += 'Z '; // Close path\n\n\t\t\t}// End of holepath check\n\n\t\t\t// Closing path element\n\t\t\tstr += '\" />';\n\n\t\t\t// Rendering control points\n\t\t\tif(options.lcpr || options.qcpr){\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tif( smp.segments[pcnt].hasOwnProperty('x3') && options.qcpr ){\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"cyan\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x3 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y3 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"white\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\tstr += '<line x1=\"'+ smp.segments[pcnt].x1 * options.scale +'\" y1=\"'+ smp.segments[pcnt].y1 * options.scale +'\" x2=\"'+ smp.segments[pcnt].x2 * options.scale +'\" y2=\"'+ smp.segments[pcnt].y2 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\tstr += '<line x1=\"'+ smp.segments[pcnt].x2 * options.scale +'\" y1=\"'+ smp.segments[pcnt].y2 * options.scale +'\" x2=\"'+ smp.segments[pcnt].x3 * options.scale +'\" y2=\"'+ smp.segments[pcnt].y3 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t}\n\t\t\t\t\tif( (!smp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr){\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.lcpr +'\" fill=\"white\" stroke-width=\"'+ options.lcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Hole children control points\n\t\t\t\tfor( var hcnt=0; hcnt < smp.holechildren.length; hcnt++){\n\t\t\t\t\tvar hsmp = layer[ smp.holechildren[hcnt] ];\n\t\t\t\t\tfor(pcnt=0; pcnt<hsmp.segments.length; pcnt++){\n\t\t\t\t\t\tif( hsmp.segments[pcnt].hasOwnProperty('x3') && options.qcpr ){\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"cyan\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x3 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y3 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"white\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t\tstr += '<line x1=\"'+ hsmp.segments[pcnt].x1 * options.scale +'\" y1=\"'+ hsmp.segments[pcnt].y1 * options.scale +'\" x2=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" y2=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\t\tstr += '<line x1=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" y1=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" x2=\"'+ hsmp.segments[pcnt].x3 * options.scale +'\" y2=\"'+ hsmp.segments[pcnt].y3 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( (!hsmp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr){\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.lcpr +'\" fill=\"white\" stroke-width=\"'+ options.lcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}// End of Rendering control points\n\n\t\t\treturn str;\n\n\t\t},// End of svgpathstring()\n\n\t\t// Converting tracedata to an SVG string\n\t\tthis.getsvgstring = function( tracedata, options ){\n\n\t\t\toptions = _this.checkoptions(options);\n\n\t\t\tvar w = tracedata.width * options.scale, h = tracedata.height * options.scale;\n\n\t\t\t// SVG start\n\t\t\tvar svgstr = '<svg ' + (options.viewbox ? ('viewBox=\"0 0 '+w+' '+h+'\" ') : ('width=\"'+w+'\" height=\"'+h+'\" ')) +\n\t\t\t\t'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" desc=\"Created with image_tracer.js version '+_this.versionnumber+'\" >';\n\n\t\t\t// Drawing: Layers and Paths loops\n\t\t\tfor(var lcnt=0; lcnt < tracedata.layers.length; lcnt++){\n\t\t\t\tfor(var pcnt=0; pcnt < tracedata.layers[lcnt].length; pcnt++){\n\n\t\t\t\t\t// Adding SVG <path> string\n\t\t\t\t\tif( !tracedata.layers[lcnt][pcnt].isholepath ){\n\t\t\t\t\t\tsvgstr += _this.svgpathstring( tracedata, lcnt, pcnt, options );\n\t\t\t\t\t}\n\n\t\t\t\t}// End of paths loop\n\t\t\t}// End of layers loop\n\n\t\t\t// SVG End\n\t\t\tsvgstr+='</svg>';\n\n\t\t\treturn svgstr;\n\n\t\t},// End of getsvgstring()\n\n\t\t// Comparator for numeric Array.sort\n\t\tthis.compareNumbers = function(a,b){ return a - b; },\n\n\t\t// Convert color object to rgba string\n\t\tthis.torgbastr = function(c){ return 'rgba('+c.r+','+c.g+','+c.b+','+c.a+')'; },\n\n\t\t// Convert color object to SVG color string\n\t\tthis.tosvgcolorstr = function(c, options){\n\t\t\treturn 'fill=\"rgb('+c.r+','+c.g+','+c.b+')\" stroke=\"rgb('+c.r+','+c.g+','+c.b+')\" stroke-width=\"'+options.strokewidth+'\" opacity=\"'+c.a/255.0+'\" ';\n\t\t},\n\n\t\t// Helper function: Appending an <svg> element to a container from an svgstring\n\t\tthis.appendSVGString = function(svgstr,parentid){\n\t\t\tvar div;\n\t\t\tif(parentid){\n\t\t\t\tdiv = document.getElementById(parentid);\n\t\t\t\tif(!div){\n\t\t\t\t\tdiv = document.createElement('div');\n\t\t\t\t\tdiv.id = parentid;\n\t\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdiv = document.createElement('div');\n\t\t\t\tdocument.body.appendChild(div);\n\t\t\t}\n\t\t\tdiv.innerHTML += svgstr;\n\t\t},\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  Canvas functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Gaussian kernels for blur\n\t\tthis.gks = [ [0.27901,0.44198,0.27901], [0.135336,0.228569,0.272192,0.228569,0.135336], [0.086776,0.136394,0.178908,0.195843,0.178908,0.136394,0.086776],\n\t\t\t\t\t [0.063327,0.093095,0.122589,0.144599,0.152781,0.144599,0.122589,0.093095,0.063327], [0.049692,0.069304,0.089767,0.107988,0.120651,0.125194,0.120651,0.107988,0.089767,0.069304,0.049692] ],\n\n\t\t// Selective Gaussian blur for preprocessing\n\t\tthis.blur = function(imgd,radius,delta){\n\t\t\tvar i,j,k,d,idx,racc,gacc,bacc,aacc,wacc;\n\n\t\t\t// new ImageData\n\t\t\tvar imgd2 = { width:imgd.width, height:imgd.height, data:[] };\n\n\t\t\t// radius and delta limits, this kernel\n\t\t\tradius = Math.floor(radius); if(radius<1){ return imgd; } if(radius>5){ radius = 5; } delta = Math.abs( delta ); if(delta>1024){ delta = 1024; }\n\t\t\tvar thisgk = _this.gks[radius-1];\n\n\t\t\t// loop through all pixels, horizontal blur\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tracc = 0; gacc = 0; bacc = 0; aacc = 0; wacc = 0;\n\t\t\t\t\t// gauss kernel loop\n\t\t\t\t\tfor( k = -radius; k < radius+1; k++){\n\t\t\t\t\t\t// add weighted color values\n\t\t\t\t\t\tif( (i+k > 0) && (i+k < imgd.width) ){\n\t\t\t\t\t\t\tidx = (j*imgd.width+i+k)*4;\n\t\t\t\t\t\t\tracc += imgd.data[idx  ] * thisgk[k+radius];\n\t\t\t\t\t\t\tgacc += imgd.data[idx+1] * thisgk[k+radius];\n\t\t\t\t\t\t\tbacc += imgd.data[idx+2] * thisgk[k+radius];\n\t\t\t\t\t\t\taacc += imgd.data[idx+3] * thisgk[k+radius];\n\t\t\t\t\t\t\twacc += thisgk[k+radius];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// The new pixel\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\timgd2.data[idx  ] = Math.floor(racc / wacc);\n\t\t\t\t\timgd2.data[idx+1] = Math.floor(gacc / wacc);\n\t\t\t\t\timgd2.data[idx+2] = Math.floor(bacc / wacc);\n\t\t\t\t\timgd2.data[idx+3] = Math.floor(aacc / wacc);\n\n\t\t\t\t}// End of width loop\n\t\t\t}// End of horizontal blur\n\n\t\t\t// copying the half blurred imgd2\n\t\t\tvar himgd = new Uint8ClampedArray(imgd2.data);\n\n\t\t\t// loop through all pixels, vertical blur\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tracc = 0; gacc = 0; bacc = 0; aacc = 0; wacc = 0;\n\t\t\t\t\t// gauss kernel loop\n\t\t\t\t\tfor( k = -radius; k < radius+1; k++){\n\t\t\t\t\t\t// add weighted color values\n\t\t\t\t\t\tif( (j+k > 0) && (j+k < imgd.height) ){\n\t\t\t\t\t\t\tidx = ((j+k)*imgd.width+i)*4;\n\t\t\t\t\t\t\tracc += himgd[idx  ] * thisgk[k+radius];\n\t\t\t\t\t\t\tgacc += himgd[idx+1] * thisgk[k+radius];\n\t\t\t\t\t\t\tbacc += himgd[idx+2] * thisgk[k+radius];\n\t\t\t\t\t\t\taacc += himgd[idx+3] * thisgk[k+radius];\n\t\t\t\t\t\t\twacc += thisgk[k+radius];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// The new pixel\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\timgd2.data[idx  ] = Math.floor(racc / wacc);\n\t\t\t\t\timgd2.data[idx+1] = Math.floor(gacc / wacc);\n\t\t\t\t\timgd2.data[idx+2] = Math.floor(bacc / wacc);\n\t\t\t\t\timgd2.data[idx+3] = Math.floor(aacc / wacc);\n\n\t\t\t\t}// End of width loop\n\t\t\t}// End of vertical blur\n\n\t\t\t// Selective blur: loop through all pixels\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\t// d is the difference between the blurred and the original pixel\n\t\t\t\t\td = Math.abs(imgd2.data[idx  ] - imgd.data[idx  ]) + Math.abs(imgd2.data[idx+1] - imgd.data[idx+1]) +\n\t\t\t\t\t\tMath.abs(imgd2.data[idx+2] - imgd.data[idx+2]) + Math.abs(imgd2.data[idx+3] - imgd.data[idx+3]);\n\t\t\t\t\t// selective blur: if d>delta, put the original pixel back\n\t\t\t\t\tif(d>delta){\n\t\t\t\t\t\timgd2.data[idx  ] = imgd.data[idx  ];\n\t\t\t\t\t\timgd2.data[idx+1] = imgd.data[idx+1];\n\t\t\t\t\t\timgd2.data[idx+2] = imgd.data[idx+2];\n\t\t\t\t\t\timgd2.data[idx+3] = imgd.data[idx+3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}// End of Selective blur\n\n\t\t\treturn imgd2;\n\n\t\t},// End of blur()\n\n\t\t// Helper function: loading an image from a URL, then executing callback with canvas as argument\n\t\tthis.loadImage = function(url,callback,options){\n\t\t\tvar img = new Image();\n\t\t\tif(options && options.corsenabled){ img.crossOrigin = 'Anonymous'; }\n\t\t\timg.onload = function(){\n\t\t\t\tvar canvas = null;\n\t\t\t\ttry {\n\t\t\t\t    canvas = new OffscreenCanvas();\n\t\t\t\t} catch(e) {\n\t\t\t\t    \n\t\t\t\t    canvas = document.createElement('canvas');\n\t\t\t\t}\n\t\t\t\tcanvas.width = img.width;\n\t\t\t\tcanvas.height = img.height;\n\t\t\t\tvar context = canvas.getContext('2d');\n\t\t\t\tcontext.drawImage(img,0,0);\n\t\t\t\tcallback(canvas);\n\t\t\t};\n\t\t\timg.src = url;\n\t\t},\n\n\t\t// Helper function: getting ImageData from a canvas\n\t\tthis.getImgdata = function(canvas){\n\t\t\tvar context = canvas.getContext('2d');\n\t\t\treturn context.getImageData(0,0,canvas.width,canvas.height);\n\t\t},\n\n\t\t// Special palette to use with drawlayers()\n\t\tthis.specpalette = [\n\t\t\t{r:0,g:0,b:0,a:255}, {r:128,g:128,b:128,a:255}, {r:0,g:0,b:128,a:255}, {r:64,g:64,b:128,a:255},\n\t\t\t{r:192,g:192,b:192,a:255}, {r:255,g:255,b:255,a:255}, {r:128,g:128,b:192,a:255}, {r:0,g:0,b:192,a:255},\n\t\t\t{r:128,g:0,b:0,a:255}, {r:128,g:64,b:64,a:255}, {r:128,g:0,b:128,a:255}, {r:168,g:168,b:168,a:255},\n\t\t\t{r:192,g:128,b:128,a:255}, {r:192,g:0,b:0,a:255}, {r:255,g:255,b:255,a:255}, {r:0,g:128,b:0,a:255}\n\t\t]\n\n\t\t// Helper function: Drawing all edge node layers into a container\n\t\t;// End of function list\n\n\t\t}// End of ImageTracer object\n\n\t\n\t\tvar imgtrc = new ImageTracer();\n\t\treturn imgtrc.imagedataToSVG(image_data, options);\n}",t.exports={image_tracer:function(n,e,i){r.default.exec(window.image_tracer_process_function_string,[n,e]).catch(function(t){return new Function(window.image_tracer_process_function_string)()(n,e)}).then(function(t){i(t)}).timeout(72e3)}}}}]);