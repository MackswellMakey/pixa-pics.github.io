(window.webpackJsonp=window.webpackJsonp||[]).push([[1],{739:function(e,n,t){"use strict";window.lzp3_json_process_function_string="return async function(uint8a_or_obj, mode) {\n        \n        \"use strict\";\n        var RangeCoder          //no dependencies\n            ,Stream              //no dependencies\n            ,BitStream           //depands on [Stream]\n            ,Util                //depands on [Stream]\n            ,LogDistanceModel    //depands on [Util(Stream)]\n            ,Huffman             //depands on [Util(Stream),BitStream(Stream)]\n            ,NoModel             //depands on [Util(Stream),BitStream(Stream)]\n            ,FenwickModel        //depands on [RangeCoder, Stream, Util(Stream)]\n            ,DefSumModel         //depands on [RangeCoder, Stream, Util(Stream)]\n            ,Context1Model       //depands on [Util(Stream),BitStream(Stream),Huffman(Util(Stream),BitStream(Stream))]\n            ,Lzp3                //depands on [RangeCoder, Stream, Util(Stream), LogDistanceModel(Util(Stream)), NoModel(Util(Stream),BitStream(Stream)), FenwickModel(RangeCoder, Stream, Util(Stream)), Context1Model(Util(Stream),BitStream(Stream),Huffman(Util(Stream),BitStream(Stream)))]\n        ;\n        \n        \n        RangeCoder = (function(){\n            /* Range Coder.  Inspired by rangecod.c from rngcod13.zip from\n             *    http://www.compressconsult.com/rangecoder/\n             * This JavaScript version is:\n             *    Copyright (c) 2013 C. Scott Ananian.\n             */\n        // Uses 32-bit integer math.  Hopefully the JavaScript runtime figures\n        // that out. ;)\n        // see https://github.com/kripken/emscripten/wiki/LLVM-Types-in-JavaScript\n        // for some hints on doing 32-bit unsigned match in JavaScript.\n        // One key is the use of \">>>0\" to change a signed result to unsigned.\n            var CODE_BITS = 32;\n            var Top_value = Math.pow(2, CODE_BITS - 1);\n            var SHIFT_BITS = (CODE_BITS - 9);\n            var EXTRA_BITS = ((CODE_BITS - 2) % 8 + 1);\n            var Bottom_value = (Top_value >>> 8);\n        \n            var MAX_INT = Math.pow(2, CODE_BITS) - 1;\n        \n            /* it is highly recommended that the total frequency count is less  */\n            /* than 1 << 19 to minimize rounding effects.                       */\n            /* the total frequency count MUST be less than 1<<23                */\n        \n        \n            var RangeCoder = function(stream) {\n                this.low = 0; /* low end of interval */\n                this.range = Top_value; /* length of interval */\n                this.buffer = 0; /* buffer for input/output */\n                this.help = 0; /* bytes_to_follow / intermediate value */\n                this.bytecount = 0; /* counter for output bytes */\n                this.stream = stream;\n            };\n        \n            /* Do the normalization before we need a defined state, instead of\n             * after messing it up.  This simplifies starting and ending. */\n            var enc_normalize = function(rc, outputStream) {\n                while (rc.range <= Bottom_value) { /* do we need renormalization? */\n                    if (rc.low < (0xFF << SHIFT_BITS)) { //no carry possible, so output\n                        outputStream.writeByte(rc.buffer);\n                        for (; rc.help; rc.help--)\n                            outputStream.writeByte(0xFF);\n                        rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n                    } else if (rc.low & Top_value) { /* carry now, no future carry */\n                        outputStream.writeByte(rc.buffer + 1);\n                        for (; rc.help; rc.help--)\n                            outputStream.writeByte(0x00);\n                        rc.buffer = (rc.low >>> SHIFT_BITS) & 0xFF;\n                    } else {\n                        rc.help++;\n                        if (rc.help > MAX_INT)\n                            throw new Error(\"Too many bytes outstanding, \" +\n                                \"file too large!\");\n                    }\n                    rc.range = (rc.range << 8) >>> 0; /*ensure result remains positive*/\n                    rc.low = ((rc.low << 8) & (Top_value - 1)) >>> 0; /* unsigned */\n                    rc.bytecount++;\n                }\n            };\n        \n            /* Start the encoder                                         */\n            /* c is written as the first byte in the datastream.\n             * one could do w/o, but then you have an additional if per output byte */\n            RangeCoder.prototype.encodeStart = function(c, initlength) {\n                this.low = 0;\n                this.range = Top_value;\n                this.buffer = c;\n                this.help = 0;\n                this.bytecount = initlength;\n            };\n        \n            /* Encode a symbol using frequencies                         */\n            /* rc is the range coder to be used                          */\n            /* sy_f is the interval length (frequency of the symbol)     */\n            /* lt_f is the lower end (frequency sum of < symbols)        */\n            /* tot_f is the total interval length (total frequency sum)  */\n            /* or (faster): tot_f = (code_value)1<<shift                             */\n            RangeCoder.prototype.encodeFreq = function(sy_f, lt_f, tot_f) {\n                enc_normalize(this, this.stream);\n                var r = (this.range / tot_f) >>> 0; // note coercion to integer\n                var tmp = r * lt_f;\n                this.low += tmp;\n                if ((lt_f + sy_f) < tot_f) {\n                    this.range = r * sy_f;\n                } else {\n                    this.range -= tmp;\n                }\n            };\n            RangeCoder.prototype.encodeShift = function(sy_f, lt_f, shift) {\n                enc_normalize(this, this.stream);\n                var r = this.range >>> shift;\n                var tmp = r * lt_f;\n                this.low += tmp;\n                if ((lt_f + sy_f) >>> shift) {\n                    this.range -= tmp;\n                } else {\n                    this.range = r * sy_f;\n                }\n            };\n            /* Encode a bit w/o modelling. */\n            RangeCoder.prototype.encodeBit = function(b) {\n                this.encodeShift(1, b ? 1 : 0, 1);\n            };\n            /* Encode a byte w/o modelling. */\n            RangeCoder.prototype.encodeByte = function(b) {\n                this.encodeShift(1, b, 8);\n            };\n            /* Encode a short w/o modelling. */\n            RangeCoder.prototype.encodeShort = function(s) {\n                this.encodeShift(1, s, 16);\n            };\n        \n            /* Finish encoding                                           */\n            /* returns number of bytes written                           */\n            RangeCoder.prototype.encodeFinish = function() {\n                var outputStream = this.stream;\n                enc_normalize(this, outputStream);\n                this.bytecount += 5;\n                var tmp = this.low >>> SHIFT_BITS;\n                if ((this.low & (Bottom_value - 1)) >= ((this.bytecount & 0xFFFFFF) >>> 1)) {\n                    tmp++;\n                }\n                if (tmp > 0xFF) { /* we have a carry */\n                    outputStream.writeByte(this.buffer + 1);\n                    for (; this.help; this.help--)\n                        outputStream.writeByte(0x00);\n                } else { /* no carry */\n                    outputStream.writeByte(this.buffer);\n                    for (; this.help; this.help--)\n                        outputStream.writeByte(0xFF);\n                }\n                outputStream.writeByte(tmp & 0xFF);\n                // XXX: i'm pretty sure these could be three arbitrary bytes\n                //      they are consumed by the decoder at the end\n                outputStream.writeByte((this.bytecount >>> 16) & 0xFF);\n                outputStream.writeByte((this.bytecount >>> 8) & 0xFF);\n                outputStream.writeByte((this.bytecount) & 0xFF);\n                return this.bytecount;\n            };\n        \n            /* Start the decoder; you need to provide the *second* byte from the\n             * datastream. (The first byte was provided to startEncoding and is\n             * ignored by the decoder.)\n             */\n            RangeCoder.prototype.decodeStart = function(skipInitialRead) {\n                var c = skipInitialRead ? 0 : this.stream.readByte();\n                if (typeof(c) !== 'number' || c < 0) {\n                    return c; // EOF\n                }\n                this.buffer = this.stream.readByte();\n                this.low = this.buffer >>> (8 - EXTRA_BITS);\n                this.range = 1 << EXTRA_BITS;\n                return c;\n            };\n        \n            var dec_normalize = function(rc, inputStream) {\n                while (rc.range <= Bottom_value) {\n                    rc.low = (rc.low << 8) | ((rc.buffer << EXTRA_BITS) & 0xFF);\n                    /* rc.low could be negative here; don't fix it quite yet */\n                    rc.buffer = inputStream.readByte();\n                    rc.low |= rc.buffer >>> (8 - EXTRA_BITS);\n                    rc.low = rc.low >>> 0; /* fix it now */\n                    rc.range = (rc.range << 8) >>> 0; /* ensure stays positive */\n                }\n            };\n        \n            /* Calculate cumulative frequency for next symbol. Does NO update!*/\n            /* rc is the range coder to be used                          */\n            /* tot_f is the total frequency                              */\n            /* or: totf is (code_value)1<<shift                                      */\n            /* returns the <= cumulative frequency                         */\n            RangeCoder.prototype.decodeCulFreq = function(tot_f) {\n                dec_normalize(this, this.stream);\n                this.help = (this.range / tot_f) >>> 0; // note coercion to integer\n                var tmp = (this.low / this.help) >>> 0; // again\n                return (tmp >= tot_f ? tot_f - 1 : tmp);\n            };\n            RangeCoder.prototype.decodeCulShift = function(shift) {\n                dec_normalize(this, this.stream);\n                this.help = this.range >>> shift;\n                var tmp = (this.low / this.help) >>> 0; // coercion to unsigned\n                // shift is less than 31, so shift below will remain positive\n                return ((tmp >>> shift) ? (1 << shift) - 1 : tmp);\n            };\n        \n            /* Update decoding state                                     */\n            /* rc is the range coder to be used                          */\n            /* sy_f is the interval length (frequency of the symbol)     */\n            /* lt_f is the lower end (frequency sum of < symbols)        */\n            /* tot_f is the total interval length (total frequency sum)  */\n            RangeCoder.prototype.decodeUpdate = function(sy_f, lt_f, tot_f) {\n                var tmp = this.help * lt_f; // should not overflow!\n                this.low -= tmp;\n                if (lt_f + sy_f < tot_f) {\n                    this.range = (this.help * sy_f);\n                } else {\n                    this.range -= tmp;\n                }\n            };\n        \n            /* Decode a bit w/o modelling. */\n            RangeCoder.prototype.decodeBit = function() {\n                var tmp = this.decodeCulShift(1);\n                this.decodeUpdate(1, tmp, 1 << 1);\n                return tmp;\n            };\n            /* decode a byte w/o modelling */\n            RangeCoder.prototype.decodeByte = function() {\n                var tmp = this.decodeCulShift(8);\n                this.decodeUpdate(1, tmp, 1 << 8);\n                return tmp;\n            };\n            /* decode a short w/o modelling */\n            RangeCoder.prototype.decodeShort = function() {\n                var tmp = this.decodeCulShift(16);\n                this.decodeUpdate(1, tmp, 1 << 16);\n                return tmp;\n            };\n        \n            /* Finish decoding */\n            RangeCoder.prototype.decodeFinish = function() {\n                /* normalize to use up all bytes */\n                dec_normalize(this, this.stream);\n            };\n        \n            /** Utility functions */\n        \n        // bitstream interface\n            RangeCoder.prototype.writeBit = RangeCoder.prototype.encodeBit;\n            RangeCoder.prototype.readBit = RangeCoder.prototype.decodeBit;\n        \n        // stream interface\n            RangeCoder.prototype.writeByte = RangeCoder.prototype.encodeByte;\n            RangeCoder.prototype.readByte = RangeCoder.prototype.decodeByte;\n        \n            return RangeCoder;\n        \n        }());\n        \n        \n        Stream = (function(){\n            /** Abstract Stream interface, for byte-oriented i/o. */\n            var EOF = -1;\n        \n            var Stream = function() {\n                /* ABSTRACT */\n            };\n        // you must define one of read / readByte for a readable stream\n            Stream.prototype.readByte = function() {\n                var buf = [0];\n                var len = this.read(buf, 0, 1);\n                if (len === 0) { this._eof = true; return EOF; }\n                return buf[0];\n            };\n            Stream.prototype.read = function(buf, bufOffset, length) {\n                var ch, bytesRead = 0;\n                while (bytesRead < length) {\n                    ch = this.readByte();\n                    if (ch === EOF) { this._eof = true; break; }\n                    buf[bufOffset + (bytesRead++)] = ch;\n                }\n                return bytesRead;\n            };\n            Stream.prototype.eof = function() { return !!this._eof; };    // reasonable default implementation of 'eof'\n            Stream.prototype.seek = function(pos) {                       // not all readable streams are seekable\n                throw new Error('Stream is not seekable.');\n            };\n            Stream.prototype.tell = function() {\n                throw new Error('Stream is not seekable.');\n            };\n            Stream.prototype.writeByte = function(_byte) {    // you must define one of write / writeByte for a writable stream\n                var buf = [_byte];\n                this.write(buf, 0, 1);\n            };\n            Stream.prototype.write = function(buf, bufOffset, length) {\n                var i;\n                for (i = 0; i < length; i++) {\n                    this.writeByte(buf[bufOffset + i]);\n                }\n                return length;\n            };\n            Stream.prototype.flush = function(){};      //flush will happily do nothing if you don't override it.\n            Stream.EOF = EOF;                           //export EOF as a constant.\n        \n            return Stream;\n        }());\n        \n        \n        BitStream = (function(){\n            /** Big-Endian Bit Stream, implemented on top of a (normal byte) stream. */\n            var BitStream = function(stream) {\n                (function() {\n                    var bufferByte = 0x100; // private var for readers\n                    this.readBit = function() {\n                        if ((bufferByte & 0xFF) === 0) {\n                            var ch = stream.readByte();\n                            if (ch === Stream.EOF) {\n                                this._eof = true;\n                                return ch; /* !!! */\n                            }\n                            bufferByte = (ch << 1) | 1;\n                        }\n                        var bit = (bufferByte & 0x100) ? 1 : 0;\n                        bufferByte <<= 1;\n                        return bit;\n                    };\n                    // seekable iff the provided stream is\n                    this.seekBit = function(pos) {\n                        var n_byte = pos >>> 3;\n                        var n_bit = pos - (n_byte * 8);\n                        this.seek(n_byte);\n                        this._eof = false;\n                        this.readBits(n_bit);\n                    };\n                    this.tellBit = function() {\n                        var pos = stream.tell() * 8;\n                        var b = bufferByte;\n                        while ((b & 0xFF) !== 0) {\n                            pos--;\n                            b <<= 1;\n                        }\n                        return pos;\n                    };\n                    // implement byte stream interface as well.\n                    this.readByte = function() {\n                        if ((bufferByte & 0xFF) === 0) {\n                            return stream.readByte();\n                        }\n                        return this.readBits(8);\n                    };\n                    this.seek = function(pos) {\n                        stream.seek(pos);\n                        bufferByte = 0x100;\n                    };\n                })\n                    .call(this);\n                (function() {\n                    var bufferByte = 1; // private var for writers\n                    this.writeBit = function(b) {\n                        bufferByte <<= 1;\n                        if (b) { bufferByte |= 1; }\n                        if (bufferByte & 0x100) {\n                            stream.writeByte(bufferByte & 0xFF);\n                            bufferByte = 1;\n                        }\n                    };\n                    // implement byte stream interface as well\n                    this.writeByte = function(_byte) {\n                        if (bufferByte === 1) {\n                            stream.writeByte(_byte);\n                        } else {\n                            stream.writeBits(8, _byte);\n                        }\n                    };\n                    this.flush = function() {\n                        while (bufferByte !== 1) {\n                            this.writeBit(0);\n                        }\n                        if (stream.flush) { stream.flush(); }\n                    };\n                })\n                    .call(this);\n            };\n        // inherit read/write methods from Stream.\n            BitStream.EOF = Stream.EOF;\n            BitStream.prototype = Object.create(Stream.prototype);\n        // bit chunk read/write\n            BitStream.prototype.readBits = function(n) {\n                var i, r = 0\n                    , b;\n                if (n > 31) {\n                    r = this.readBits(n - 16) * 0x10000; // fp multiply, not shift\n                    return r + this.readBits(16);\n                }\n                for (i = 0; i < n; i++) {\n                    r <<= 1; // this could make a negative value if n>31\n                    // bits read past EOF are all zeros!\n                    if (this.readBit() > 0) { r++; }\n                }\n                return r;\n            };\n            BitStream.prototype.writeBits = function(n, value) {\n                if (n > 32) {\n                    var low = (value & 0xFFFF);\n                    var high = (value - low) / (0x10000); // fp division, not shift\n                    this.writeBits(n - 16, high);\n                    this.writeBits(16, low);\n                    return;\n                }\n                var i;\n                for (i = n - 1; i >= 0; i--) {\n                    this.writeBit((value >>> i) & 1);\n                }\n            };\n        \n            return BitStream;\n        }());\n        \n        \n        Util = (function(){\n            var Util = Object.create(null);\n        \n            var EOF = Stream.EOF;\n        \n            /* Take a buffer, array, or stream, and return an input stream. */\n            Util.coerceInputStream = function(input, forceRead) {\n                if (!('readByte' in input)) {\n                    var buffer = input;\n                    input = new Stream();\n                    input.size = buffer.length;\n                    input.pos = 0;\n                    input.readByte = function() {\n                        if (this.pos >= this.size) { return EOF; }\n                        return buffer[this.pos++];\n                    };\n                    input.read = function(buf, bufOffset, length) {\n                        var bytesRead = 0;\n                        while (bytesRead < length && this.pos < buffer.length) {\n                            buf[bufOffset++] = buffer[this.pos++];\n                            bytesRead++;\n                        }\n                        return bytesRead;\n                    };\n                    input.seek = function(pos) { this.pos = pos; };\n                    input.tell = function() { return this.pos; };\n                    input.eof = function() { return this.pos >= buffer.length; };\n                } else if (forceRead && !('read' in input)) {\n                    // wrap input if it doesn't implement read\n                    var s = input;\n                    input = new Stream();\n                    input.readByte = function() {\n                        var ch = s.readByte();\n                        if (ch === EOF) { this._eof = true; }\n                        return ch;\n                    };\n                    if ('size' in s) { input.size = s.size; }\n                    if ('seek' in s) {\n                        input.seek = function(pos) {\n                            s.seek(pos); // may throw if s doesn't implement seek\n                            this._eof = false;\n                        };\n                    }\n                    if ('tell' in s) {\n                        input.tell = s.tell.bind(s);\n                    }\n                }\n                return input;\n            };\n        \n            var BufferStream = function(buffer, resizeOk) {\n                this.buffer = buffer;\n                this.resizeOk = resizeOk;\n                this.pos = 0;\n            };\n            BufferStream.prototype = Object.create(Stream.prototype);\n            BufferStream.prototype.writeByte = function(_byte) {\n                if (this.resizeOk && this.pos >= this.buffer.length) {\n                    var newBuffer = Util.makeU8Buffer(this.buffer.length * 2);\n                    newBuffer.set(this.buffer);\n                    this.buffer = newBuffer;\n                }\n                this.buffer[this.pos++] = _byte;\n            };\n            BufferStream.prototype.getBuffer = function() {\n                // trim buffer if needed\n                if (this.pos !== this.buffer.length) {\n                    if (!this.resizeOk)\n                        throw new TypeError('outputsize does not match decoded input');\n                    var newBuffer = Util.makeU8Buffer(this.pos);\n                    newBuffer.set(this.buffer.subarray(0, this.pos));\n                    this.buffer = newBuffer;\n                }\n                return this.buffer;\n            };\n        \n            /* Take a stream (or not) and an (optional) size, and return an\n             * output stream.  Return an object with a 'retval' field equal to\n             * the output stream (if that was given) or else a pointer at the\n             * internal Uint8Array/buffer/array; and a 'stream' field equal to\n             * an output stream to use.\n             */\n            Util.coerceOutputStream = function(output, size) {\n                var r = { stream: output, retval: output };\n                if (output) {\n                    if (typeof(output) === 'object' && 'writeByte' in output) {\n                        return r; /* leave output alone */\n                    } else if (typeof(size) === 'number') {\n                        console.assert(size >= 0);\n                        r.stream = new BufferStream(Util.makeU8Buffer(size), false);\n                    } else { // output is a buffer\n                        r.stream = new BufferStream(output, false);\n                    }\n                } else {\n                    r.stream = new BufferStream(Util.makeU8Buffer(16384), true);\n                }\n                Object.defineProperty(r, 'retval', {\n                    get: r.stream.getBuffer.bind(r.stream)\n                });\n                return r;\n            };\n        \n            Util.compressFileHelper = function(magic, guts, suppressFinalByte) {\n                return function(inStream, outStream, props) {\n                    inStream = Util.coerceInputStream(inStream);\n                    var o = Util.coerceOutputStream(outStream, outStream);\n                    outStream = o.stream;\n        \n                    // write the magic number to identify this file type\n                    // (it better be ASCII, we're not doing utf-8 conversion)\n                    var i;\n                    for (i = 0; i < magic.length; i++) {\n                        outStream.writeByte(magic.charCodeAt(i));\n                    }\n        \n                    // if we know the size, write it\n                    var fileSize;\n                    if ('size' in inStream && inStream.size >= 0) {\n                        fileSize = inStream.size;\n                    } else {\n                        fileSize = -1; // size unknown\n                    }\n                    if (suppressFinalByte) {\n                        var tmpOutput = Util.coerceOutputStream([]);\n                        Util.writeUnsignedNumber(tmpOutput.stream, fileSize + 1);\n                        tmpOutput = tmpOutput.retval;\n                        for (i = 0; i < tmpOutput.length - 1; i++) {\n                            outStream.writeByte(tmpOutput[i]);\n                        }\n                        suppressFinalByte = tmpOutput[tmpOutput.length - 1];\n                    } else {\n                        Util.writeUnsignedNumber(outStream, fileSize + 1);\n                    }\n        \n                    // call the guts to do the real compression\n                    guts(inStream, outStream, fileSize, props, suppressFinalByte);\n        \n                    return o.retval;\n                };\n            };\n            Util.decompressFileHelper = function(magic, guts) {\n                return function(inStream, outStream) {\n                    inStream = Util.coerceInputStream(inStream);\n        \n                    // read the magic number to confirm this file type\n                    // (it better be ASCII, we're not doing utf-8 conversion)\n                    var i;\n                    for (i = 0; i < magic.length; i++) {\n                        if (magic.charCodeAt(i) !== inStream.readByte()) {\n                            throw new Error(\"Bad magic\");\n                        }\n                    }\n        \n                    // read the file size & create an appropriate output stream/buffer\n                    var fileSize = Util.readUnsignedNumber(inStream) - 1;\n                    var o = Util.coerceOutputStream(outStream, fileSize);\n                    outStream = o.stream;\n        \n                    // call the guts to do the real decompression\n                    guts(inStream, outStream, fileSize);\n        \n                    return o.retval;\n                };\n            };\n        // a helper for simple self-test of model encode\n            Util.compressWithModel = function(inStream, fileSize, model) {\n                var inSize = 0;\n                while (inSize !== fileSize) {\n                    var ch = inStream.readByte();\n                    if (ch === EOF) {\n                        model.encode(256); // end of stream;\n                        break;\n                    }\n                    model.encode(ch);\n                    inSize++;\n                }\n            };\n        // a helper for simple self-test of model decode\n            Util.decompressWithModel = function(outStream, fileSize, model) {\n                var outSize = 0;\n                while (outSize !== fileSize) {\n                    var ch = model.decode();\n                    if (ch === 256) {\n                        break; // end of stream;\n                    }\n                    outStream.writeByte(ch);\n                    outSize++;\n                }\n            };\n        \n            /** Write a number using a self-delimiting big-endian encoding. */\n            Util.writeUnsignedNumber = function(output, n) {\n                console.assert(n >= 0);\n                var bytes = []\n                    , i;\n                do {\n                    bytes.push(n & 0x7F);\n                    // use division instead of shift to allow encoding numbers up to\n                    // 2^53\n                    n = Math.floor(n / 128);\n                } while (n !== 0);\n                bytes[0] |= 0x80; // mark end of encoding.\n                for (i = bytes.length - 1; i >= 0; i--) {\n                    output.writeByte(bytes[i]); // write in big-endian order\n                }\n                return output;\n            };\n        \n            /** Read a number using a self-delimiting big-endian encoding. */\n            Util.readUnsignedNumber = function(input) {\n                var n = 0\n                    , c;\n                while (true) {\n                    c = input.readByte();\n                    if (c & 0x80) { n += (c & 0x7F); break; }\n                    // using + and * instead of << allows decoding numbers up to 2^53\n                    n = (n + c) * 128;\n                }\n                return n;\n            };\n        \n        // Compatibility thunks for Buffer/TypedArray constructors.\n        \n            var zerofill = function(a) {\n                for (var i = 0, len = a.length; i < len; i++) {\n                    a[i] = 0;\n                }\n                return a;\n            };\n        \n            var fallbackarray = function(size) {\n                return zerofill(new Array(size));\n            };\n        \n        // Node 0.11.6 - 0.11.10ish don't properly zero fill typed arrays.\n        // See https://github.com/joyent/node/issues/6664\n        // Try to detect and workaround the bug.\n            var ensureZeroed = function id(a) { return a; };\n            if ((typeof(process) !== 'undefined') &&\n                Array.prototype.some.call(new Uint32Array(128), function(x) {\n                    return x !== 0;\n                })) {\n                //console.warn('Working around broken TypedArray');\n                ensureZeroed = zerofill;\n            }\n        \n            /** Portable 8-bit unsigned buffer. */\n            Util.makeU8Buffer = (typeof(Uint8Array) !== 'undefined') ? function(size) {\n                // Uint8Array ought to be  automatically zero-filled\n                return ensureZeroed(new Uint8Array(size));\n            } : (typeof(Buffer) !== 'undefined') ? function(size) {\n                var b = new Buffer(size);\n                b.fill(0);\n                return b;\n            } : fallbackarray;\n        \n            /** Portable 16-bit unsigned buffer. */\n            Util.makeU16Buffer = (typeof(Uint16Array) !== 'undefined') ? function(size) {\n                // Uint16Array ought to be  automatically zero-filled\n                return ensureZeroed(new Uint16Array(size));\n            } : fallbackarray;\n        \n            /** Portable 32-bit unsigned buffer. */\n            Util.makeU32Buffer = (typeof(Uint32Array) !== 'undefined') ? function(size) {\n                // Uint32Array ought to be  automatically zero-filled\n                return ensureZeroed(new Uint32Array(size));\n            } : fallbackarray;\n        \n            /** Portable 32-bit signed buffer. */\n            Util.makeS32Buffer = (typeof(Int32Array) !== 'undefined') ? function(size) {\n                // Int32Array ought to be  automatically zero-filled\n                return ensureZeroed(new Int32Array(size));\n            } : fallbackarray;\n        \n            Util.arraycopy = function(dst, src) {\n                console.assert(dst.length >= src.length);\n                for (var i = 0, len = src.length; i < len; i++) {\n                    dst[i] = src[i];\n                }\n                return dst;\n            };\n        \n            /** Highest bit set in a byte. */\n            var bytemsb = [\n                0\n                ,1\n                ,2, 2\n                ,3, 3, 3, 3\n                ,4, 4, 4, 4, 4, 4, 4, 4\n                ,5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n                ,6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6\n                ,7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7\n                ,8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8 /* 256 */\n            ];\n            console.assert(bytemsb.length === 0x100);\n            /** Find last set (most significant bit).\n             *  @return the last bit set in the argument.\n             *          <code>fls(0)==0</code> and <code>fls(1)==1</code>. */\n            var fls = Util.fls = function(v) {\n                console.assert(v >= 0);\n                if (v > 0xFFFFFFFF) { // use floating-point mojo\n                    return 32 + fls(Math.floor(v / 0x100000000));\n                }\n                if ((v & 0xFFFF0000) !== 0) {\n                    if ((v & 0xFF000000) !== 0) {\n                        return 24 + bytemsb[(v >>> 24) & 0xFF];\n                    } else {\n                        return 16 + bytemsb[v >>> 16];\n                    }\n                } else if ((v & 0x0000FF00) !== 0) {\n                    return 8 + bytemsb[v >>> 8];\n                } else {\n                    return bytemsb[v];\n                }\n            };\n            /** Returns ceil(log2(n)) */\n            Util.log2c = function(v) {\n                return (v === 0) ? -1 : fls(v - 1);\n            };\n        \n            return Util; // ensure constants are recognized as such.\n        }());\n        \n        \n        LogDistanceModel = (function(){\n            /** Simple (log n)(n) distance model. */\n        \n        // lengthBitsModelFactory will be called with arguments 2, 4, 8, 16, etc\n        // and must return an appropriate model or coder.\n            var LogDistanceModel = function(size, extraStates\n                , lgDistanceModelFactory\n                , lengthBitsModelFactory) {\n                var i;\n                var bits = Util.fls(size - 1);\n                this.extraStates = +extraStates || 0;\n                this.lgDistanceModel = lgDistanceModelFactory(1 + bits + extraStates);\n                // this.distanceModel[n] used for distances which are n-bits long,\n                // but only n-1 bits are encoded: the top bit is known to be one.\n                this.distanceModel = [];\n                for (i = 2; i <= bits; i++) {\n                    var numBits = i - 1;\n                    this.distanceModel[i] = lengthBitsModelFactory(1 << numBits);\n                }\n            };\n            /* you can give this model arguments between 0 and (size-1), or else\n               a negative argument which is one of the 'extra states'. */\n            LogDistanceModel.prototype.encode = function(distance) {\n                if (distance < 2) { // small distance or an 'extra state'\n                    this.lgDistanceModel.encode(distance + this.extraStates);\n                    return;\n                }\n                var lgDistance = Util.fls(distance);\n                console.assert(distance & (1 << (lgDistance - 1))); // top bit is set\n                console.assert(lgDistance >= 2);\n                this.lgDistanceModel.encode(lgDistance + this.extraStates);\n                // now encode the rest of the bits.\n                var rest = distance & ((1 << (lgDistance - 1)) - 1);\n                this.distanceModel[lgDistance].encode(rest);\n            };\n            LogDistanceModel.prototype.decode = function() {\n                var lgDistance = this.lgDistanceModel.decode() - this.extraStates;\n                if (lgDistance < 2) {\n                    return lgDistance; // this is a small distance or an 'extra state'\n                }\n                var rest = this.distanceModel[lgDistance].decode();\n                return (1 << (lgDistance - 1)) + rest;\n            };\n        \n            return LogDistanceModel;\n        \n        }());\n        \n        \n        Huffman = (function(){\n            /* Adaptive Huffman code, using Vitter's algorithm ported from\n             * vitter.c at http://code.google.com/p/compression-code/downloads/list\n             * The original code was placed in the public domain, and so I\n             * also place this JavaScript port in the public domain.\n             *   -- C. Scott Ananian <cscott@cscott.net>, 2013\n             * ps. some truly grotty C code in the originally, faithfully ported to\n             *     evil comma-operator-using, assignment-in-if-condition JavaScript.\n             */\n        \n        //  This code is adapted from Professor Vitter's\n        //  article, Design and Analysis of Dynamic Huffman Codes,\n        //  which appeared in JACM October 1987\n        \n        //  A design trade-off has been made to simplify the\n        //  code:  a node's block is determined dynamically,\n        //  and the implicit tree structure is maintained,\n        //  e.g. explicit node numbers are also implicit.\n        \n        //  Dynamic Huffman table weight ranking\n        //  is maintained per Professor Vitter's\n        //  invariant (*) for algorithm FGK:\n        \n        //  leaves precede internal nodes of the\n        //  same weight in a non-decreasing ranking\n        //  of weights using implicit node numbers:\n        \n        //  1) leaves slide over internal nodes, internal nodes\n        //  swap over groups of leaves, leaves are swapped\n        //  into group leader position, but two internal\n        //  nodes never change positions relative\n        //  to one another.\n        \n        //  2) weights are incremented by 2:\n        //  leaves always have even weight values;\n        //  internal nodes always have odd values.\n        \n        //  3) even node numbers are always right children;\n        //  odd numbers are left children in the tree.\n        \n        //  node 2 * HuffSize - 1 is always the tree root;\n        //  node HuffEsc is the escape node;\n        \n        //  the tree is initialized by creating an\n        //  escape node as the root.\n        \n        //  each new leaf symbol is paired with a new escape\n        //  node into the previous escape node in the tree,\n        //  until the last symbol which takes over the\n        //  tree position of the escape node, and\n        //  HuffEsc is left at zero.\n        \n        //  overall table size: 2 * HuffSize\n        \n        //  huff_init(alphabet_size, potential symbols used)\n        //  huff_encode(next_symbol)\n        //  next_symbol = huff_decode()\n        \n        //  huff_scale(by_bits) -- scale weights and re-balance tree\n        \n            var HTable = function(up, down, symbol, weight) {\n                this.up = up; // next node up the tree\n                this.down = down; // pair of down nodes\n                this.symbol = symbol; // node symbol value\n                this.weight = weight; // node weight\n            };\n            HTable.prototype.clone = function() {\n                return new HTable(this.up, this.down, this.symbol, this.weight);\n            };\n            HTable.prototype.set = function(htable) {\n                this.up = htable.up;\n                this.down = htable.down;\n                this.symbol = htable.symbol;\n                this.weight = htable.weight;\n            };\n        \n        //  initialize an adaptive coder\n        //  for alphabet size, and count\n        //  of nodes to be used\n            var Huffman = function(size, root, bitstream, max_weight) {\n                var i;\n                //  default: all alphabet symbols are used\n        \n                console.assert(size && typeof(size) === 'number');\n                if (!root || root > size)\n                    root = size;\n        \n                //  create the initial escape node\n                //  at the tree root\n        \n                if (root <<= 1) {\n                    root--;\n                }\n        \n                // create root+1 htables (coding table)\n                // XXX this could be views on a backing Uint32 array?\n                this.table = [];\n                for (i = 0; i <= root; i++) {\n                    this.table[i] = new HTable(0, 0, 0, 0);\n                }\n        \n                // this.map => mapping for symbols to nodes\n                this.map = [];\n                // this.size => the alphabet size\n                if (this.size = size) {\n                    for (i = 0; i < size; i++) {\n                        this.map[i] = 0;\n                    }\n                }\n        \n                // this.esc  => the current tree height\n                // this.root => the root of the tree\n                this.esc = this.root = root;\n        \n                if (bitstream) {\n                    this.readBit = bitstream.readBit.bind(bitstream);\n                    this.writeBit = bitstream.writeBit.bind(bitstream);\n                }\n                this.max_weight = max_weight; // may be null or undefined\n            }\n        // factory interface\n            Huffman.factory = function(bitstream, max_weight) {\n                return function(size) {\n                    return new Huffman(size, size, bitstream, max_weight);\n                };\n            };\n        \n        \n        // split escape node to incorporate new symbol\n        \n            Huffman.prototype.split = function(symbol) {\n                var pair, node;\n        \n                //  is the tree already full???\n        \n                if (pair = this.esc) {\n                    this.esc--;\n                } else {\n                    console.assert(false);\n                    return 0;\n                }\n        \n                //  if this is the last symbol, it moves into\n                //  the escape node's old position, and\n                //  this.esc is set to zero.\n        \n                //  otherwise, the escape node is promoted to\n                //  parent a new escape node and the new symbol.\n        \n                if (node = this.esc) {\n                    this.table[pair].down = node;\n                    this.table[pair].weight = 1;\n                    this.table[node].up = pair;\n                    this.esc--;\n                } else {\n                    pair = 0;\n                    node = 1;\n                }\n        \n                //  initialize the new symbol node\n        \n                this.table[node].symbol = symbol;\n                this.table[node].weight = 0;\n                this.table[node].down = 0;\n                this.map[symbol] = node;\n        \n                //  initialize a new escape node.\n        \n                this.table[this.esc].weight = 0;\n                this.table[this.esc].down = 0;\n                this.table[this.esc].up = pair;\n                return node;\n            };\n        \n        //  swap leaf to group leader position\n        //  return symbol's new node\n        \n            Huffman.prototype.leader = function(node) {\n                var weight = this.table[node].weight;\n                var leader = node\n                    , prev, symbol;\n        \n                while (weight === this.table[leader + 1].weight) {\n                    leader++;\n                }\n        \n                if (leader === node) {\n                    return node;\n                }\n        \n                // swap the leaf nodes\n        \n                symbol = this.table[node].symbol;\n                prev = this.table[leader].symbol;\n        \n                this.table[leader].symbol = symbol;\n                this.table[node].symbol = prev;\n                this.map[symbol] = leader;\n                this.map[prev] = node;\n                return leader;\n            };\n        \n        //  slide internal node up over all leaves of equal weight;\n        //  or exchange leaf with next smaller weight internal node\n        \n        //  return node's new position\n        \n            Huffman.prototype.slide = function(node) {\n                var next = node;\n                var swap;\n        \n                swap = this.table[next++].clone();\n        \n                // if we're sliding an internal node, find the\n                // highest possible leaf to exchange with\n        \n                if (swap.weight & 1) {\n                    while (swap.weight > this.table[next + 1].weight) {\n                        next++;\n                    }\n                }\n        \n                //  swap the two nodes\n        \n                this.table[node].set(this.table[next]);\n                this.table[next].set(swap);\n        \n                this.table[next].up = this.table[node].up;\n                this.table[node].up = swap.up;\n        \n                //  repair the symbol map and tree structure\n        \n                if (swap.weight & 1) {\n                    this.table[swap.down].up = next;\n                    this.table[swap.down - 1].up = next;\n                    this.map[this.table[node].symbol] = node;\n                } else {\n                    this.table[this.table[node].down - 1].up = node;\n                    this.table[this.table[node].down].up = node;\n                    this.map[swap.symbol] = next;\n                }\n        \n                return next;\n            };\n        \n        //  increment symbol weight and re balance the tree.\n        \n            Huffman.prototype.increment = function(node) {\n                var up;\n        \n                //  obviate swapping a parent with its child:\n                //    increment the leaf and proceed\n                //    directly to its parent.\n        \n                //  otherwise, promote leaf to group leader position in the tree\n        \n                if (this.table[node].up === node + 1) {\n                    this.table[node].weight += 2;\n                    node++;\n                } else {\n                    node = this.leader(node);\n                }\n        \n                //  increase the weight of each node and slide\n                //  over any smaller weights ahead of it\n                //  until reaching the root\n        \n                //  internal nodes work upwards from\n                //  their initial positions; while\n                //  symbol nodes slide over first,\n                //  then work up from their final\n                //  positions.\n        \n                while (this.table[node].weight += 2, up = this.table[node].up) {\n                    while (this.table[node].weight > this.table[node + 1].weight) {\n                        node = this.slide(node);\n                    }\n        \n                    if (this.table[node].weight & 1) {\n                        node = up;\n                    } else {\n                        node = this.table[node].up;\n                    }\n                }\n        \n                /* Re-scale if necessary. */\n                if (this.max_weight) {\n                    if (this.table[this.root].weight >= this.max_weight) {\n                        this.scale(1);\n                    }\n                }\n            };\n        \n        //  scale all weights and re-balance the tree\n        \n        //  zero weight nodes are removed from the tree\n        //  by sliding them out the left of the rank list\n        \n            Huffman.prototype.scale = function(bits) {\n                var node = this.esc\n                    , weight, prev;\n        \n                //  work up the tree from the escape node\n                //  scaling weights by the value of bits\n        \n                while (++node <= this.root) {\n                    //  recompute the weight of internal nodes;\n                    //  slide down and out any unused ones\n        \n                    if (this.table[node].weight & 1) {\n                        if (weight = this.table[this.table[node].down].weight & ~1) {\n                            weight += this.table[this.table[node].down - 1].weight | 1;\n                        }\n        \n                        //  remove zero weight leaves by incrementing HuffEsc\n                        //  and removing them from the symbol map.  take care\n        \n                    } else if (!(weight = this.table[node].weight >> bits & ~1)) {\n                        if (this.map[this.table[node].symbol] = 0, this.esc++) {\n                            this.esc++;\n                        }\n                    }\n        \n                    // slide the scaled node back down over any\n                    // previous nodes with larger weights\n        \n                    this.table[node].weight = weight;\n                    prev = node;\n        \n                    while (weight < this.table[--prev].weight) {\n                        this.slide(prev);\n                    }\n                }\n        \n                // prepare a new escape node\n        \n                this.table[this.esc].down = 0;\n            };\n        \n        //  send the bits for an escaped symbol\n        \n            Huffman.prototype.sendid = function(symbol) {\n                var empty = 0\n                    , max;\n        \n                //  count the number of empty symbols\n                //  before the symbol in the table\n        \n                while (symbol--) {\n                    if (!this.map[symbol]) {\n                        empty++;\n                    }\n                }\n        \n                //  send LSB of this count first, using\n                //  as many bits as are required for\n                //  the maximum possible count\n        \n                if (max = this.size - Math.floor((this.root - this.esc) / 2) - 1) {\n                    do {\n                        this.writeBit(empty & 1);\n                        empty >>= 1;\n                    } while (max >>= 1);\n                }\n            };\n        \n        //  encode the next symbol\n        \n            Huffman.prototype.encode = function(symbol) {\n                var emit = 1\n                    , bit;\n                var up, idx, node;\n        \n                if (symbol < this.size) {\n                    node = this.map[symbol];\n                } else {\n                    console.assert(false);\n                    return;\n                }\n        \n                //  for a new symbol, direct the receiver to the escape node\n                //  but refuse input if table is already full.\n        \n                if (!(idx = node)) {\n                    if (!(idx = this.esc)) {\n                        return;\n                    }\n                }\n        \n                //  accumulate the code bits by\n                //  working up the tree from\n                //  the node to the root\n        \n                while (up = this.table[idx].up) {\n                    emit <<= 1;\n                    emit |= idx & 1;\n                    idx = up;\n                }\n        \n                //  send the code, root selector bit first\n        \n                while (bit = emit & 1, emit >>= 1) {\n                    this.writeBit(bit);\n                }\n        \n                //  send identification and incorporate\n                //  new symbols into the tree\n        \n                if (!node) {\n                    this.sendid(symbol);\n                    node = this.split(symbol);\n                }\n        \n                //  adjust and re-balance the tree\n        \n                this.increment(node);\n            };\n        \n        //  read the identification bits\n        //  for an escaped symbol\n        \n            Huffman.prototype.readid = function() {\n                var empty = 0\n                    , bit = 1\n                    , max, symbol;\n        \n                //  receive the symbol, LSB first, reading\n                //  only the number of bits necessary to\n                //  transmit the maximum possible symbol value\n        \n                if (max = this.size - Math.floor((this.root - this.esc) / 2) - 1) {\n                    do {\n                        empty |= this.readBit() ? bit : 0;\n                        bit <<= 1;\n                    } while (max >>= 1);\n                }\n        \n                //  the count is of unmapped symbols\n                //  in the table before the new one\n        \n                for (symbol = 0; symbol < this.size; symbol++) {\n                    if (!this.map[symbol]) {\n                        if (!empty--) {\n                            return symbol;\n                        }\n                    }\n                }\n        \n                //  oops!  our count is too big, either due\n                //  to a bit error, or a short node count\n                //  given to huff_init.\n        \n                console.assert(false);\n                return 0;\n            };\n        \n        //  decode the next symbol\n        \n            Huffman.prototype.decode = function() {\n                var node = this.root;\n                var symbol, down;\n        \n                //  work down the tree from the root\n                //  until reaching either a leaf\n                //  or the escape node.  A one\n                //  bit means go left, a zero\n                //  means go right.\n        \n                while (down = this.table[node].down) {\n                    if (this.readBit()) {\n                        node = down - 1; // the left child precedes the right child\n                    } else {\n                        node = down;\n                    }\n                }\n        \n                //  sent to the escape node???\n                //  refuse to add to a full tree\n        \n                if (node === this.esc) {\n                    if (this.esc) {\n                        symbol = this.readid();\n                        node = this.split(symbol);\n                    } else {\n                        console.assert(false);\n                        return 0;\n                    }\n                } else {\n                    symbol = this.table[node].symbol;\n                }\n        \n                //  increment weights and re-balance\n                //  the coding tree\n        \n                this.increment(node);\n                return symbol;\n            };\n        \n        // stand alone compressor, mostly for testing\n            Huffman.MAGIC = 'huff';\n            Huffman.compressFile = Util.compressFileHelper(Huffman.MAGIC, function(input, output, size, props) {\n                var bitstream = new BitStream(output);\n        \n                var alphabetSize = 256;\n                if (size < 0) {\n                    alphabetSize++;\n                }\n                var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n                Util.compressWithModel(input, size, huff);\n                bitstream.flush();\n            });\n        \n        // stand alone decompresser, again for testing\n            Huffman.decompressFile = Util.decompressFileHelper(Huffman.MAGIC, function(input, output, size) {\n                var bitstream = new BitStream(input);\n        \n                var alphabetSize = 256;\n                if (size < 0) {\n                    alphabetSize++;\n                }\n                var huff = new Huffman(257, alphabetSize, bitstream, 8191);\n                Util.decompressWithModel(output, size, huff);\n            });\n        \n            return Huffman;\n        \n        }());\n        \n        \n        NoModel = (function(){\n            /** Simple \"lack of model\" -- just encode the bits directly.\n             *  Useful especially with sparse spaces or Huffman coders where there's\n             *  no obvious prediction to be made that will pay for itself.\n             */\n        \n            var NoModel = function(bitstream, size) {\n                this.bitstream = bitstream;\n                this.bits = Util.fls(size - 1);\n            };\n            NoModel.factory = function(bitstream) {\n                return function(size) { return new NoModel(bitstream, size); };\n            };\n            NoModel.prototype.encode = function(symbol) {\n                var i;\n                for (i = this.bits - 1; i >= 0; i--) {\n                    var b = (symbol >>> i) & 1;\n                    this.bitstream.writeBit(b);\n                }\n            };\n            NoModel.prototype.decode = function() {\n                var i, r = 0;\n                for (i = this.bits - 1; i >= 0; i--) {\n                    r <<= 1;\n                    if (this.bitstream.readBit()) r++;\n                }\n                return r;\n            };\n        \n            /** Brain-dead self-test. */\n            NoModel.MAGIC = 'nomo';\n            NoModel.compressFile = Util.compressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize, props) {\n                var bitstream = new BitStream(outStream);\n                var model = new NoModel(bitstream, (fileSize < 0) ? 257 : 256);\n                Util.compressWithModel(inStream, fileSize, model);\n                bitstream.flush();\n            });\n            NoModel.decompressFile = Util.decompressFileHelper(NoModel.MAGIC, function(inStream, outStream, fileSize) {\n                var bitstream = new BitStream(inStream);\n                var model = new NoModel(bitstream, (fileSize < 0) ? 257 : 256);\n                Util.decompressWithModel(outStream, fileSize, model);\n            });\n        \n            return NoModel;\n        \n        \n        }());\n        \n        \n        FenwickModel = (function(){\n            /** Range coding model based on Fenwick trees for O(ln N) query/update. */\n        \n            /** We store two probabilities in a U32, so max prob is going to be 0xFFFF */\n            var DEFAULT_MAX_PROB = 0xFF00;\n            var DEFAULT_INCREMENT = 0x0100;\n        \n            var ESC_MASK = 0x0000FFFF\n                , ESC_SHIFT = 0;\n            var SYM_MASK = 0xFFFF0000\n                , SYM_SHIFT = 16;\n            var SCALE_MASK = 0xFFFEFFFE;\n        \n            var FenwickModel = function(coder, size, max_prob, increment) {\n                this.coder = coder;\n                this.numSyms = size + 1; // save space for an escape symbol\n                this.tree = Util.makeU32Buffer(this.numSyms * 2);\n                this.increment = (+increment) || DEFAULT_INCREMENT;\n                this.max_prob = (+max_prob) || DEFAULT_MAX_PROB;\n                // sanity-check to prevent overflow.\n                console.assert((this.max_prob + (this.increment - 1)) <= 0xFFFF);\n                console.assert(size <= 0xFFFF);\n                // record escape probability as 1.\n                var i;\n                for (i = 0; i < size; i++) {\n                    this.tree[this.numSyms + i] = // escape prob=1, sym prob = 0\n                        (1 << ESC_SHIFT) | (0 << SYM_SHIFT);\n                }\n                this.tree[this.numSyms + i] = // escape prob = 0, sym prob = 1\n                    (0 << ESC_SHIFT) | (this.increment << SYM_SHIFT);\n                this._sumTree();\n                // probability sums are in this.tree[1].  this.tree[0] is unused.\n            };\n            FenwickModel.factory = function(coder, max_prob, increment) {\n                return function(size) {\n                    return new FenwickModel(coder, size, max_prob, increment);\n                };\n            };\n            FenwickModel.prototype.clone = function() {\n                var newModel = new FenwickModel(this.coder, this.size\n                    , this.max_prob, this.increment);\n                var i;\n                for (i = 1; i < this.tree.length; i++) {\n                    newModel.tree[i] = this.tree[i];\n                }\n                return newModel;\n            };\n            FenwickModel.prototype.encode = function(symbol) {\n                var i = this.numSyms + symbol;\n                var sy_f = this.tree[i];\n                var mask = SYM_MASK\n                    , shift = SYM_SHIFT;\n                var update = (this.increment << SYM_SHIFT);\n        \n                if ((sy_f & SYM_MASK) === 0) { // escape!\n                    this.encode(this.numSyms - 1);\n                    mask = ESC_MASK;\n                    update -= (1 << ESC_SHIFT); // not going to escape no mo'\n                    shift = ESC_SHIFT;\n                } else if (symbol === (this.numSyms - 1) &&\n                    ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n                    // this is the last escape, zero it out\n                    update = -this.tree[i];\n                }\n                // sum up the proper lt_f\n                var lt_f = 0;\n                while (i > 1) {\n                    var isRight = (i & 1);\n                    var parent = (i >>> 1);\n                    // if we're the right child, we need to\n                    // add the prob from the left child\n                    if (isRight) {\n                        lt_f += this.tree[2 * parent];\n                    }\n                    // update sums\n                    this.tree[i] += update; // increase sym / decrease esc\n                    i = parent;\n                }\n                var tot_f = this.tree[1];\n                this.tree[1] += update; // update prob in root\n                sy_f = (sy_f & mask) >>> shift;\n                lt_f = (lt_f & mask) >>> shift;\n                tot_f = (tot_f & mask) >>> shift;\n                this.coder.encodeFreq(sy_f, lt_f, tot_f);\n                // rescale?\n                if (((this.tree[1] & SYM_MASK) >>> SYM_SHIFT) >= this.max_prob) {\n                    this._rescale();\n                }\n            };\n            FenwickModel.prototype._decode = function(isEscape) {\n                var mask = SYM_MASK\n                    , shift = SYM_SHIFT;\n                var update = (this.increment << SYM_SHIFT);\n                if (isEscape) {\n                    mask = ESC_MASK;\n                    update -= (1 << ESC_SHIFT);\n                    shift = ESC_SHIFT;\n                }\n                var tot_f = (this.tree[1] & mask) >>> shift;\n                var prob = this.coder.decodeCulFreq(tot_f);\n                // travel down the tree looking for this\n                var i = 1\n                    , lt_f = 0;\n                while (i < this.numSyms) {\n                    this.tree[i] += update;\n                    // look at probability in left child.\n                    var leftProb = (this.tree[2 * i] & mask) >>> shift;\n                    i *= 2;\n                    if ((prob - lt_f) >= leftProb) {\n                        lt_f += leftProb;\n                        i++; // take the right child.\n                    }\n                }\n                var symbol = i - this.numSyms;\n                var sy_f = (this.tree[i] & mask) >>> shift;\n                this.tree[i] += update;\n                this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n                // was this the last escape?\n                if (symbol === (this.numSyms - 1) &&\n                    ((this.tree[1] & ESC_MASK) >>> ESC_SHIFT) === 1) {\n                    update = -this.tree[i]; // zero it out\n                    while (i >= 1) {\n                        this.tree[i] += update;\n                        i = (i >>> 1); // parent\n                    }\n                }\n                // rescale?\n                if (((this.tree[1] & SYM_MASK) >>> SYM_SHIFT) >= this.max_prob) {\n                    this._rescale();\n                }\n                return symbol;\n            };\n            FenwickModel.prototype.decode = function() {\n                var symbol = this._decode(false); // not escape\n                if (symbol === (this.numSyms - 1)) {\n                    // this was an escape!\n                    symbol = this._decode(true); // an escape!\n                }\n                return symbol;\n            };\n            FenwickModel.prototype._rescale = function() {\n                var i, prob, noEscape = true;\n                // scale symbols (possible causing them to escape)\n                for (i = 0; i < this.numSyms - 1; i++) {\n                    prob = this.tree[this.numSyms + i];\n                    if ((prob & ESC_MASK) !== 0) {\n                        // this symbol escapes\n                        noEscape = false;\n                        continue;\n                    }\n                    prob = (prob & SCALE_MASK) >>> 1;\n                    if (prob === 0) {\n                        // this symbol newly escapes\n                        prob = (1 << ESC_SHIFT);\n                        noEscape = false;\n                    }\n                    this.tree[this.numSyms + i] = prob;\n                }\n                // scale the escape symbol\n                prob = this.tree[this.numSyms + i];\n                prob = (prob & SCALE_MASK) >>> 1;\n                // prob should be zero if there are no escaping symbols, otherwise\n                // it must be at least 1.\n                if (noEscape) {\n                    prob = 0;\n                } else if (prob === 0) {\n                    prob = (1 << SYM_SHIFT);\n                }\n                this.tree[this.numSyms + i] = prob;\n                // sum it all up afresh\n                this._sumTree();\n            };\n            FenwickModel.prototype._sumTree = function() {\n                var i;\n                // sum it all. (we know we won't overflow)\n                for (i = this.numSyms - 1; i > 0; i--) {\n                    this.tree[i] = this.tree[2 * i] + this.tree[2 * i + 1];\n                }\n            };\n        \n            FenwickModel.MAGIC = 'fenw';\n            /** Simple order-0 compressor, as self-test. */\n            FenwickModel.compressFile = Util.compressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n                var range = new RangeCoder(outStream);\n                range.encodeStart(finalByte, 1);\n                var model = new FenwickModel(range, (fileSize < 0) ? 257 : 256);\n                Util.compressWithModel(inStream, fileSize, model);\n                range.encodeFinish();\n            }, true);\n        \n            /** Simple order-0 decompresser, as self-test. */\n            FenwickModel.decompressFile = Util.decompressFileHelper(FenwickModel.MAGIC, function(inStream, outStream, fileSize) {\n                var range = new RangeCoder(inStream);\n                range.decodeStart(true /*already read the final byte*/ );\n                var model = new FenwickModel(range, (fileSize < 0) ? 257 : 256);\n                Util.decompressWithModel(outStream, fileSize, model);\n                range.decodeFinish();\n            });\n        \n            return FenwickModel;\n        \n        }());\n        \n        \n        DefSumModel = (function(){\n            /** Deferred-sum model, suitable for small ( ~ 256 ) ranges. */\n        // See http://cbloom.com/src/defsum.zip\n        //     http://cbloom.com/papers/context.pdf\n        \n            var LOG_PROB_TOTAL = 8;\n            var PROB_TOTAL = 1 << LOG_PROB_TOTAL;\n            var MAX_ESCAPE_COUNT = 40;\n        \n            var DefSumModel = function(coder, size, isDecoder) {\n                var i;\n                console.assert(size < 300); // not meant for sparse\n                var ESCAPE = this.numSyms = size;\n                this.coder = coder;\n                this.prob = Util.makeU16Buffer(size + 2); /* size + ESC + 1 */\n                this.escape = Util.makeU16Buffer(size + 1); /* size + 1*/\n                this.update = Util.makeU16Buffer(size + 1); /* size + ESC */\n                this.prob[ESCAPE + 1] = PROB_TOTAL;\n                for (i = 0; i <= this.numSyms; i++) {\n                    this.escape[i] = i;\n                }\n                this.updateCount = 0;\n                this.updateThresh = PROB_TOTAL - Math.floor(PROB_TOTAL / 2);\n                if (!isDecoder) {\n                    return;\n                }\n                // extra tables for fast decoding\n                this.probToSym = Util.makeU16Buffer(PROB_TOTAL);\n                this.escProbToSym = Util.makeU16Buffer(this.numSyms);\n                for (i = 0; i < PROB_TOTAL; i++) {\n                    this.probToSym[i] = ESCAPE;\n                }\n                for (i = 0; i < this.numSyms; i++) {\n                    this.escProbToSym[i] = i;\n                }\n            };\n            DefSumModel.factory = function(coder, isDecoder) {\n                return function(size) {\n                    return new DefSumModel(coder, size, isDecoder);\n                };\n            };\n            DefSumModel.prototype._update = function(symbol, isDecoder) {\n                if (symbol === this.numSyms) {\n                    // some special cases for the escape character\n                    if (this.update[symbol] >= MAX_ESCAPE_COUNT) {\n                        return;\n                    } // hard limit\n                    // don't let an escape character trigger an update, because then the\n                    // escaped character might find itself unescaped after the tables have\n                    // been updated!\n                    if (this.updateCount >= (this.updateThresh - 1)) {\n                        return;\n                    }\n                }\n                this.update[symbol]++;\n                this.updateCount++;\n                // is it time to transfer the updated probabilities?\n                if (this.updateCount < this.updateThresh) {\n                    return; //defer update\n                }\n                var cumProb, cumEscProb, odd, i, j, k;\n                this.escape[0] = this.prob[0] = cumProb = cumEscProb = odd = 0;\n                for (i = 0; i < this.numSyms + 1; i++) {\n                    var newProb = ((this.prob[i + 1] - this.prob[i]) >>> 1) + this.update[i];\n                    if (newProb) {\n                        // live 'un\n                        this.prob[i] = cumProb;\n                        cumProb += newProb;\n                        if (newProb & 1) {\n                            odd++;\n                        }\n                        this.escape[i] = cumEscProb;\n                    } else {\n                        // this symbol will escape\n                        this.prob[i] = cumProb;\n                        this.escape[i] = cumEscProb;\n                        cumEscProb++;\n                    }\n                }\n                this.prob[i] = cumProb;\n                console.assert(cumProb === PROB_TOTAL);\n                /* how many updates will be required after current probs are halved? */\n                this.updateThresh = PROB_TOTAL - Math.floor((cumProb - odd) / 2);\n                /* reset the update table */\n                for (i = 0; i < (this.numSyms + 1); i++) {\n                    this.update[i] = 0;\n                }\n                this.update[this.numSyms] = 1; // ensure that escape never goes away\n                this.updateCount = 1;\n                /* compute decode table, if this is a decoder */\n                if (!isDecoder) {\n                    return;\n                }\n                for (i = 0, j = 0, k = 0; i < (this.numSyms + 1); i++) {\n                    var probLimit = this.prob[i + 1];\n                    for (; j < probLimit; j++) {\n                        this.probToSym[j] = i;\n                    }\n                    var escProbLimit = this.escape[i + 1];\n                    for (; k < escProbLimit; k++) {\n                        this.escProbToSym[k] = i;\n                    }\n                }\n            };\n            DefSumModel.prototype.encode = function(symbol) {\n                var lt_f = this.prob[symbol];\n                var sy_f = this.prob[symbol + 1] - lt_f;\n                console.assert(this.prob[this.numSyms + 1] === PROB_TOTAL);\n                if (sy_f) {\n                    this.coder.encodeShift(sy_f, lt_f, LOG_PROB_TOTAL);\n                    return this._update(symbol);\n                }\n                // escape!\n                console.assert(symbol !== this.numSyms); // catch infinite recursion\n                this.encode(this.numSyms); // guaranteed non-zero probability\n                // code symbol as literal, taking advantage of reduced escape range.\n                lt_f = this.escape[symbol];\n                sy_f = this.escape[symbol + 1] - lt_f;\n                var tot_f = this.escape[this.numSyms];\n                this.coder.encodeFreq(sy_f, lt_f, tot_f);\n                return this._update(symbol);\n            };\n            DefSumModel.prototype.decode = function() {\n                var prob = this.coder.decodeCulShift(LOG_PROB_TOTAL);\n                var symbol = this.probToSym[prob];\n                var lt_f = this.prob[symbol];\n                var sy_f = this.prob[symbol + 1] - lt_f;\n                this.coder.decodeUpdate(sy_f, lt_f, PROB_TOTAL);\n                this._update(symbol, true);\n                if (symbol !== this.numSyms) {\n                    return symbol;\n                }\n                // escape!\n                var tot_f = this.escape[this.numSyms];\n                prob = this.coder.decodeCulFreq(tot_f);\n                symbol = this.escProbToSym[prob];\n                lt_f = this.escape[symbol];\n                sy_f = this.escape[symbol + 1] - lt_f;\n                this.coder.decodeUpdate(sy_f, lt_f, tot_f);\n                this._update(symbol, true);\n                return symbol;\n            };\n        \n            DefSumModel.MAGIC = 'dfsm';\n            /** Simple order-0 compressor, as self-test. */\n            DefSumModel.compressFile = Util.compressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize, props, finalByte) {\n                var range = new RangeCoder(outStream);\n                range.encodeStart(finalByte, 1);\n                var model = new DefSumModel(range, (fileSize < 0) ? 257 : 256);\n                Util.compressWithModel(inStream, fileSize, model);\n                range.encodeFinish();\n            }, true);\n            /** Simple order-0 decompresser, as self-test. */\n            DefSumModel.decompressFile = Util.decompressFileHelper(DefSumModel.MAGIC, function(inStream, outStream, fileSize) {\n                var range = new RangeCoder(inStream);\n                range.decodeStart(true /*already read the final byte*/ );\n                var model = new DefSumModel(range, (fileSize < 0) ? 257 : 256, true);\n                Util.decompressWithModel(outStream, fileSize, model);\n                range.decodeFinish();\n            });\n        \n            return DefSumModel;\n        \n        }());\n        \n        \n        Context1Model = (function(){\n            /** A simple context-1 model. */\n        \n            var Context1Model = function(modelFactory, contextSize, alphabetSize) {\n                var i;\n                this.literalModel = [];\n                // even if there's an EOF symbol, we don't need a context for it!\n                for (i = 0; i < contextSize; i++) {\n                    this.literalModel[i] = modelFactory(alphabetSize);\n                }\n            };\n            Context1Model.prototype.encode = function(ch, context) {\n                this.literalModel[context].encode(ch);\n            };\n            Context1Model.prototype.decode = function(context) {\n                return this.literalModel[context].decode();\n            };\n        \n            /** Simple self-test. */\n            Context1Model.MAGIC = 'ctx1';\n            Context1Model.compressFile = Util.compressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize, props) {\n                var bitstream = new BitStream(outStream);\n                var alphabetSize = 256;\n                if (fileSize < 0) { alphabetSize++; }\n                var coder = Huffman.factory(bitstream, 8191);\n                var model = new Context1Model(coder, 256, alphabetSize);\n                var lastchar = 0x20;\n                var modelp = {\n                    encode: function(symbol) {\n                        model.encode(symbol, lastchar);\n                        lastchar = symbol;\n                    }\n                };\n                Util.compressWithModel(inStream, fileSize, modelp);\n                bitstream.flush();\n            });\n            Context1Model.decompressFile = Util.decompressFileHelper(Context1Model.MAGIC, function(inStream, outStream, fileSize) {\n                var bitstream = new BitStream(inStream);\n                var alphabetSize = 256;\n                if (fileSize < 0) { alphabetSize++; }\n                var coder = Huffman.factory(bitstream, 8191);\n                var model = new Context1Model(coder, 256, alphabetSize);\n                var lastchar = 0x20;\n                var modelp = {\n                    decode: function() {\n                        var symbol = model.decode(lastchar);\n                        lastchar = symbol;\n                        return symbol;\n                    }\n                };\n                Util.decompressWithModel(outStream, fileSize, modelp);\n            });\n        \n            return Context1Model;\n        \n        }());\n        \n        \n        Lzp3 = (function(){\n            /* Implementation of LZP3(ish), with an adaptive Huffman code or a range\n             * coder (instead of LZP3's original static Huffman code).\n             * See: http://www.cbloom.com/papers/lzp.pdf\n             */\n        \n        \n            var Lzp3 = Object.create(null);\n            Lzp3.MAGIC = 'lzp3';\n        \n        // use Huffman coder (fast) or else use range coder (slow)\n            var USE_HUFFMAN_CODE = false;\n        // use deferred-sum model, which is supposed to be faster (but compresses worse)\n            var USE_DEFSUM = false;\n        // when to give up attempting to model the length\n            var LENGTH_MODEL_CUTOFF = 256;\n            var MODEL_MAX_PROB = 0xFF00;\n            var MODEL_INCREMENT = 0x100;\n        \n        // Constants was used for compress/decompress function.\n            var CTXT4_TABLE_SIZE = 1 << 16;\n            var CTXT3_TABLE_SIZE = 1 << 12;\n            var CTXT2_TABLE_SIZE = 1 << 16;\n            var CONTEXT_LEN = 4;\n            var LOG_WINDOW_SIZE = 20;\n            var WINDOW_SIZE = 1 << LOG_WINDOW_SIZE;\n            var MAX_MATCH_LEN = WINDOW_SIZE - 1;\n            var MATCH_LEN_CONTEXTS = 16;\n        \n            var MAX32 = 0xFFFFFFFF;\n            var MAX24 = 0x00FFFFFF;\n            var MAX16 = 0x0000FFFF;\n            var MAX8 = 0x000000FF;\n        \n        \n            var Window = function(maxSize) {\n                this.buffer = Util.makeU8Buffer(Math.min(maxSize + 4, WINDOW_SIZE));\n                this.pos = 0;\n                // context-4 hash table.\n                this.ctxt4 = Util.makeU32Buffer(CTXT4_TABLE_SIZE);\n                // context-3 hash table\n                this.ctxt3 = Util.makeU32Buffer(CTXT3_TABLE_SIZE);\n                // context-2 table (not really a hash any more)\n                this.ctxt2 = Util.makeU32Buffer(CTXT2_TABLE_SIZE);\n                // initial context\n                this.put(0x63);\n                this.put(0x53);\n                this.put(0x61);\n                this.put(0x20);\n            };\n            Window.prototype.put = function(_byte) {\n                this.buffer[this.pos++] = _byte;\n                if (this.pos >= WINDOW_SIZE) { this.pos = 0; }\n                return _byte;\n            };\n            Window.prototype.get = function(pos) {\n                return this.buffer[pos & (WINDOW_SIZE - 1)];\n            };\n            Window.prototype.context = function(pos, n) {\n                var c = 0\n                    , i;\n                pos = (pos - n) & (WINDOW_SIZE - 1);\n                for (i = 0; i < n; i++) {\n                    c = (c << 8) | this.buffer[pos++];\n                    if (pos >= WINDOW_SIZE) { pos = 0; }\n                }\n                return c;\n            };\n        // if matchLen !== 0, update the index; otherwise get index value.\n            Window.prototype.getIndex = function(s, matchLen) {\n                var c = this.context(s, 4);\n                // compute context hashes\n                var h4 = ((c >>> 15) ^ c) & (CTXT4_TABLE_SIZE - 1);\n                var h3 = ((c >>> 11) ^ c) & (CTXT3_TABLE_SIZE - 1);\n                var h2 = c & MAX16;\n                // check order-4 context\n                var p = 0\n                    , checkc;\n                // only do context confirmation if matchLen==0 (that is, if we're not just\n                // doing an update)\n                if (matchLen === 0) {\n                    p = this.ctxt4[h4];\n                    if (p !== 0 && c !== this.context(p - 1, 4)) {\n                        p = 0; // context confirmation failed\n                    }\n                    if (p === 0) {\n                        // check order-3 context\n                        p = this.ctxt3[h3];\n                        if (p !== 0 && (c & MAX24) !== this.context(p - 1, 3)) {\n                            p = 0; // context confirmation failed\n                        }\n                        if (p === 0) {\n                            // check order-2 context\n                            p = this.ctxt2[h2];\n                            if (p !== 0 && (c && MAX16) !== this.context(p - 1, 2)) {\n                                p = 0; // context confirmation failed\n                            }\n                        }\n                    }\n                }\n                // update context index\n                if (matchLen) { matchLen--; }\n                this.ctxt4[h4] = this.ctxt3[h3] = this.ctxt2[h2] =\n                    (s | (matchLen << LOG_WINDOW_SIZE)) + 1;\n                // return lookup result.\n                return p;\n            };\n        \n            /**\n             * Compress using modified LZP3 algorithm.  Instead of using static\n             * Huffman coding, we use an adaptive Huffman code or range encoding.\n             */\n            Lzp3.compressFile = Util.compressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize, props) {\n                // sliding window & hash table\n                var window = new Window((fileSize >= 0) ? fileSize : WINDOW_SIZE);\n        \n                var coderFactory, sparseCoderFactory, flush;\n        \n                if (USE_HUFFMAN_CODE) {\n                    // Huffman contexts\n                    outStream.writeByte(0x80); // mark that this is Huffman coded.\n                    var bitstream = new BitStream(outStream);\n                    flush = bitstream.flush.bind(bitstream);\n                    coderFactory = Huffman.factory(bitstream, MAX16);\n                    sparseCoderFactory = NoModel.factory(bitstream);\n        \n                } else { // range encoder\n                    var range = new RangeCoder(outStream);\n                    range.encodeStart(0x00, 0); // 0x00 == range encoded\n        \n                    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n                    if (USE_DEFSUM) {\n                        coderFactory = DefSumModel.factory(range, false /* encoder */ );\n                    }\n                    // switch sparseCoderFactory to a NoModel when size > cutoff\n                    var noCoderFactory = NoModel.factory(range);\n                    sparseCoderFactory = function(size) {\n                        if (size > LENGTH_MODEL_CUTOFF) {\n                            return noCoderFactory(size);\n                        }\n                        return coderFactory(size);\n                    };\n                    flush = function() { range.encodeFinish(); };\n                }\n        \n                var huffLiteral = new Context1Model(coderFactory, 256\n                    , (fileSize < 0) ? 257 : 256);\n                var huffLen = []\n                    , i;\n                for (i = 0; i < MATCH_LEN_CONTEXTS; i++) {\n                    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN + 1, 1\n                        , coderFactory, sparseCoderFactory);\n                }\n        \n                var inSize = 0\n                    , s, matchContext = 0;\n                while (inSize !== fileSize) {\n                    var ch = inStream.readByte();\n                    s = window.pos;\n                    var p = window.getIndex(s, 0);\n                    if (p !== 0) {\n                        // great, a match! how long is it?\n                        p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n                        var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n                        var matchLen = 0;\n                        while (window.get(p + matchLen) === ch && matchLen < MAX_MATCH_LEN) {\n                            matchLen++;\n                            window.put(ch);\n                            ch = inStream.readByte();\n                        }\n                        // code match length; match len = 0 means \"literal\"\n                        // use \"extra state\" -1 to mean \"same as previous match length\"\n                        if (prevMatchLen === matchLen) {\n                            huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].encode(-1);\n                        } else {\n                            huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].encode(matchLen);\n                        }\n                        // update hash with this match\n                        window.getIndex(s, matchLen);\n                        inSize += matchLen;\n                        matchContext <<= 1;\n                        if (matchLen > 0) { matchContext |= 1; }\n                        // XXX: LZMA uses a special \"delta match\" context here if matchLen==0\n                        // XXX: it also uses the offset as context for the length (or vice-versa)\n                    }\n                    // always encode a literal after a match\n                    var context1 = window.get(window.pos - 1);\n                    if (ch === Stream.EOF) {\n                        if (fileSize < 0) {\n                            huffLiteral.encode(256, context1);\n                        }\n                        break;\n                    }\n                    huffLiteral.encode(ch, context1);\n                    window.put(ch);\n                    inSize++;\n                }\n                if (flush) flush();\n            });\n        \n            /**\n             * Decompress using modified LZP3 algorithm.\n             */\n            Lzp3.decompressFile = Util.decompressFileHelper(Lzp3.MAGIC, function(inStream, outStream, fileSize) {\n                var flags = inStream.readByte();\n                var use_huffman_code = !!(flags & 0x80);\n        \n                // sliding window & hash table\n                var window = new Window((fileSize >= 0) ? fileSize : WINDOW_SIZE);\n        \n                var coderFactory, sparseCoderFactory, finish;\n        \n                if (use_huffman_code) {\n                    // Huffman contexts\n                    var bitstream = new BitStream(inStream);\n                    coderFactory = Huffman.factory(bitstream, MAX16);\n                    sparseCoderFactory = NoModel.factory(bitstream);\n                } else { // range encoder\n                    var range = new RangeCoder(inStream);\n                    range.decodeStart(true /* skip initial read */ );\n                    coderFactory = FenwickModel.factory(range, MODEL_MAX_PROB, MODEL_INCREMENT);\n                    if (USE_DEFSUM) {\n                        coderFactory = DefSumModel.factory(range, true /* decoder */ );\n                    }\n                    // switch sparseCoderFactory to a NoModel when size > cutoff\n                    var noCoderFactory = NoModel.factory(range);\n                    sparseCoderFactory = function(size) {\n                        if (size > LENGTH_MODEL_CUTOFF) {\n                            return noCoderFactory(size);\n                        }\n                        return coderFactory(size);\n                    };\n                    finish = function() { range.decodeFinish(); };\n                }\n        \n                var huffLiteral = new Context1Model(coderFactory, 256\n                    , (fileSize < 0) ? 257 : 256);\n                var huffLen = []\n                    , i;\n                for (i = 0; i < MATCH_LEN_CONTEXTS; i++) {\n                    huffLen[i] = new LogDistanceModel(MAX_MATCH_LEN + 1, 1\n                        , coderFactory, sparseCoderFactory);\n                }\n        \n                var s, ch, outSize = 0\n                    , matchContext = 0;\n                while (outSize !== fileSize) {\n                    s = window.pos;\n                    var p = window.getIndex(s, 0);\n                    if (p !== 0) {\n                        p--; // p=0 is used for 'not here'. p=1 really means WINDOW_SIZE\n                        var prevMatchLen = (p >>> LOG_WINDOW_SIZE) + 1;\n                        var matchLen = huffLen[matchContext & (MATCH_LEN_CONTEXTS - 1)].decode();\n                        if (matchLen < 0) { matchLen = prevMatchLen; }\n                        // copy characters!\n                        for (i = 0; i < matchLen; i++) {\n                            ch = window.get(p + i);\n                            outStream.writeByte(window.put(ch));\n                        }\n                        window.getIndex(s, matchLen);\n                        outSize += matchLen;\n                        matchContext <<= 1;\n                        if (matchLen > 0) matchContext |= 1;\n                    }\n                    // literal always follows match (or failed match)\n                    if (outSize === fileSize) {\n                        break; // EOF\n                    }\n                    var context1 = window.get(window.pos - 1);\n                    ch = huffLiteral.decode(context1);\n                    if (ch === 256) {\n                        break; // EOF\n                    }\n                    outStream.writeByte(window.put(ch));\n                    outSize++;\n                }\n                if (finish) finish();\n            });\n        \n        \n            return Lzp3;\n        }());\n        \n        if(mode === \"COMPRESS_OBJECT\") {\n        \n            var json_str = JSON.stringify(uint8a_or_obj, null, 0);\n            var ui8a = new TextEncoder(\"utf-8\").encode(json_str);\n            var compressed = Lzp3.compressFile(ui8a);\n            \n            return Uint8Array.from(compressed);\n            \n        }else if(mode === \"DECOMPRESS_UINT8A\") {\n          \n             var decompressed = Lzp3.decompressFile(uint8a_or_obj);\n             var ui8a =  Uint8Array.from(decompressed);\n             var json_str = new TextDecoder().decode(ui8a);\n             \n            return JSON.parse(json_str);\n            \n        }else {\n        \n            return null;\n        }\n    }",e.exports={LZP3:function n(t){var i=1<arguments.length&&void 0!==arguments[1]?arguments[1]:"COMPRESS_OBJECT",r=2<arguments.length&&void 0!==arguments[2]?arguments[2]:function(){},o=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;Boolean(o)?o.exec(new Function(window.lzp3_json_process_function_string)(),[t,i]).catch(function(e){return"Pool terminated"===e?n(t,i,r,o):new Function(window.lzp3_json_process_function_string)()(t,i)}).then(function(e){r(e)}).timeout(15e3):new Function(window.lzp3_json_process_function_string)()(t,i).then(function(e){r(e)})}}}}]);