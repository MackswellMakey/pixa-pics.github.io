(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{976:function(n,t,e){"use strict";window.omniscale_process_function_string="return async function(image_data, scale) {\n\n        \"use strict\";\n        // static class methods for common filter operations\n        class Common {\n    \n            static get Threshold() {\n    \n                return this.hasOwnProperty('_Threshold') ? this._Threshold : false;\n            }\n    \n            static set Threshold(v) {\n    \n                this._Threshold = v;\n            }\n    \n            static get ScaleX() {\n    \n                return this.hasOwnProperty('_ScaleX') ? this._ScaleX : parseInt(0);\n            }\n    \n            static set ScaleX(v) {\n    \n                this._ScaleX = parseInt(v);\n            }\n    \n            static get ScaleY() {\n    \n                return this.hasOwnProperty('_ScaleY') ? this._ScaleY : parseInt(0);\n            }\n    \n            static set ScaleY(v) {\n    \n                this._ScaleY = parseInt(v);\n            }\n    \n            static get SizeX() {\n    \n                return this.hasOwnProperty('_SizeX') ? this._SizeX : parseInt(0);\n            }\n    \n            static set SizeX(v) {\n    \n                this._SizeX = parseInt(v);\n            }\n    \n            static get SizeY() {\n    \n                return this.hasOwnProperty('_SizeY') ? this._SizeY : parseInt(0);\n            }\n    \n            static set SizeY(v) {\n    \n                this._SizeY = parseInt(v);\n            }\n    \n            static get ScaledImage() {\n    \n                return this.hasOwnProperty('_ScaledImage') ? this._ScaledImage : [];\n            }\n    \n            static set ScaledImage(v) {\n    \n                this._ScaledImage = v;\n            }\n    \n            static Copy(dst, src, Length) {\n    \n                for (var i = 0; i < Length; i++)\n                    dst[i] = this._Clip8(src[i]);\n            }\n    \n            static Copy2D(dst, src, dstx, dsty, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                var xdim = Math.min(srcx, dstx);\n                var ydim = Math.min(srcy, dsty);\n    \n                for (var y = 0; y < ydim; y++)\n                    for (var x = 0; x < xdim; x++)\n                        for (var Channel = 0; Channel < Channels; Channel++)\n                            dst[(y * dstx + x) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];\n            }\n    \n            static CopyPadded(src, srcx, srcy, scale) {\n    \n                const Channels = 4;\n    \n                var dim = Math.max(srcx, srcy);\n                dim = Common.NextPow(dim, scale);\n    \n                var dst = new Uint8ClampedArray(dim * dim * Channels);\n    \n                Common.Copy2D(dst, src, dim, dim, srcx, srcy);\n    \n                return dst;\n            }\n    \n            static CopyCropped(dst, src, dstx, dsty, srcx, srcy) {\n    \n                Common.Copy2D(dst, src, dstx, dsty, srcx, srcy);\n            }\n    \n            static ToArray(Input, srcx, srcy) {\n    \n                var dst = new Uint32Array(srcx * srcy);\n    \n                var Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n    \n                    for (var x = 0; x < srcx; x++) {\n    \n                        var index = y * srcx + x;\n                        var pixel = index * Channels;\n    \n                        var r = Input[pixel];\n                        var g = Input[pixel + 1];\n                        var b = Input[pixel + 2];\n                        var a = Input[pixel + 3];\n    \n                        dst[index] = this.ARGBINT(a, r, g, b);\n                    }\n                }\n    \n                return dst;\n            }\n    \n            static ToImage(dst, src, srcx, srcy) {\n    \n                var Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n                    for (var x = 0; x < srcx; x++) {\n    \n                        var index = y * srcx + x;\n                        var pixel = index * Channels;\n    \n                        dst[pixel] = this.Red(src[index]);\n                        dst[pixel + 1] = this.Green(src[index]);\n                        dst[pixel + 2] = this.Blue(src[index]);\n                        dst[pixel + 3] = this.Alpha(src[index]);\n                    }\n                }\n            }\n    \n            static _CLR(Input, srcx, srcy, x, y) {\n    \n                const Channels = 4;\n    \n                if (y >= 0 && y < srcy && x >= 0 && x < srcx) {\n    \n                    var index = (y * srcx + x) * Channels;\n    \n                    var r = Input[index];\n                    var g = Input[index + 1];\n                    var b = Input[index + 2];\n                    var a = Input[index + 3];\n    \n                    return this.ARGBINT(a, r, g, b);\n                }\n    \n                return 0;\n            }\n    \n            static CLR(Input, srcx, srcy, x, y, dx = 0, dy = 0) {\n    \n                var xx = parseInt(x + dx);\n                var yy = parseInt(y + dy);\n    \n                xx = Math.max(0, Math.min(srcx - 1, xx));\n                yy = Math.max(0, Math.min(srcy - 1, yy));\n    \n                return this._CLR(Input, srcx, srcy, xx, yy);\n            }\n    \n            static Alpha(rgb) {\n    \n                return parseInt(rgb >>> 24);\n            }\n    \n            static Red(rgb) {\n    \n                return parseInt((rgb >>> 0 & 0x00FF0000) >> 16);\n            }\n    \n            static Green(rgb) {\n    \n                return parseInt((rgb >>> 0 & 0x0000FF00) >> 8);\n            }\n    \n            static Blue(rgb) {\n    \n                return parseInt(rgb >>> 0 & 0x000000FF);\n            }\n    \n            static Brightness(rgb) {\n    \n                var dwordC = rgb & 0xFFFFFF;\n    \n                return this._Clip8((this.Red(dwordC) * 3 + this.Green(dwordC) * 3 + this.Blue(dwordC) * 2) >> 3);\n            }\n    \n            static Luminance(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(0.299 * r + 0.587 * g + 0.114 * b);\n            }\n    \n            static ChromaU(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(0.5 * r - 0.418688 * g - 0.081312 * b + 127.5);\n            }\n    \n            static ChromaV(rgb) {\n    \n                var r = parseFloat(this.Red(rgb));\n                var g = parseFloat(this.Green(rgb));\n                var b = parseFloat(this.Blue(rgb));\n    \n                return parseInt(-0.168736 * r - 0.331264 * g + 0.5 * b + 127.5);\n            }\n    \n            static IsLike(pixel1, pixel2) {\n    \n                if (!this.Threshold)\n                    return pixel1 == pixel2;\n    \n                const _LUMINANCE_TRIGGER = 48;\n                const _CHROMA_U_TRIGGER = 7;\n                const _CHROMA_V_TRIGGER = 6;\n    \n                var delta = this.Luminance(pixel1) - this.Luminance(pixel2);\n    \n                if (Math.abs(delta) > _LUMINANCE_TRIGGER)\n                    return false;\n    \n                delta = this.ChromaV(pixel1) - this.ChromaV(pixel2);\n    \n                if (Math.abs(delta) > _CHROMA_V_TRIGGER)\n                    return false;\n    \n                delta = this.ChromaU(pixel1) - this.ChromaU(pixel2);\n    \n                return Math.abs(delta) <= _CHROMA_U_TRIGGER;\n            }\n    \n            static IsNotLike(pixel1, pixel2) {\n    \n                return !this.IsLike(pixel1, pixel2);\n            }\n    \n            static _Clip8(color) {\n    \n                return Math.max(0, Math.min(255, color));\n            }\n    \n            static _Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n    \n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var dx = x * this.ScaleX;\n                    var dy = y * this.ScaleY;\n    \n                    dx += (Pixel == 2 || Pixel == 4) ? 1 : 0;\n                    dy += (Pixel == 3 || Pixel == 4) ? 1 : 0;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write4RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write4RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static _Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var deltax = 0;\n                    var deltay = 0;\n    \n                    if (Pixel == 2 || Pixel == 5 || Pixel == 8) {\n    \n                        deltax = 1;\n                    }\n    \n                    if (Pixel == 3 || Pixel == 6 || Pixel == 9) {\n    \n                        deltax = 2;\n                    }\n    \n                    if (Pixel == 4 || Pixel == 5 || Pixel == 6) {\n    \n                        deltay = 1;\n                    }\n    \n                    if (Pixel == 7 || Pixel == 8 || Pixel == 9) {\n    \n                        deltay = 2;\n                    }\n    \n                    var dx = x * this.ScaleX + deltax;\n                    var dy = y * this.ScaleY + deltay;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write9RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write9RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static _Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B) {\n    \n                if (x >= 0 && x < sizex && y >= 0 && y < sizey) {\n    \n                    const Channels = 4;\n    \n                    var deltax = 0;\n                    var deltay = 0;\n    \n                    /*\n                    01 02 03 04\n                    05 06 07 08\n                    09 10 11 12\n                    13 14 15 16\n                    */\n    \n                    if (Pixel == 2 || Pixel == 6 || Pixel == 10 || Pixel == 14) {\n    \n                        deltax = 1;\n                    }\n    \n                    if (Pixel == 3 || Pixel == 7 || Pixel == 11 || Pixel == 15) {\n    \n                        deltax = 2;\n                    }\n    \n                    if (Pixel == 4 || Pixel == 8 || Pixel == 12 || Pixel == 16) {\n    \n                        deltax = 3;\n                    }\n    \n                    if (Pixel == 5 || Pixel == 6 || Pixel == 7 || Pixel == 8) {\n    \n                        deltay = 1;\n                    }\n    \n                    if (Pixel == 9 || Pixel == 10 || Pixel == 11 || Pixel == 12) {\n    \n                        deltay = 2;\n                    }\n    \n                    if (Pixel == 13 || Pixel == 14 || Pixel == 15 || Pixel == 16) {\n    \n                        deltay = 3;\n                    }\n    \n                    var dx = x * this.ScaleX + deltax;\n                    var dy = y * this.ScaleY + deltay;\n    \n                    var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                    Output[dst] = this._Clip8(R);\n                    Output[dst + 1] = this._Clip8(G);\n                    Output[dst + 2] = this._Clip8(B);\n                    Output[dst + 3] = this._Clip8(A);\n                }\n            }\n    \n            static Write16RGBA(Output, sizex, sizey, x, y, Pixel, argb) {\n    \n                var R = this.Red(argb);\n                var G = this.Green(argb);\n                var B = this.Blue(argb);\n                var A = this.Alpha(argb);\n    \n                this._Write16RGBA(Output, sizex, sizey, x, y, Pixel, A, R, G, B);\n            }\n    \n            static WriteMagnify(Input, Output, sizex, sizey, x, y) {\n    \n                const Channels = 4;\n    \n                var x0 = x * this.ScaleX;\n                var y0 = y * this.ScaleY;\n    \n                for (var deltay = 0; deltay < this.ScaleY; deltay++) {\n                    for (var deltax = 0; deltax < this.ScaleX; deltax++) {\n    \n                        var dx = x0 + deltax;\n                        var dy = y0 + deltay;\n    \n                        var dst = (dy * sizex * this.ScaleX + dx) * Channels;\n    \n                        var index = (y * sizex + x) * Channels;\n    \n                        for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                            Output[dst + Channel] = Input[index + Channel];\n                        }\n                    }\n                }\n            }\n    \n            static RGBINT(r, g, b) {\n    \n                return parseInt((this._Clip8(r) << 16) + (this._Clip8(g) << 8) + this._Clip8(b));\n            }\n    \n            static ARGBINT(a, r, g, b) {\n    \n                return ((((((a) >>> 0) << 24) >>> 0) | (((r) << 16) + ((g) << 8) + ((b)))) >>> 0);\n            }\n    \n            static Truncate(color) {\n    \n                return this._Clip8(color);\n            }\n    \n            static NextPow(v, scale) {\n    \n                var dim = 1;\n    \n                for (var i = 0; i < 10; i++) {\n    \n                    if (v <= dim)\n                        break;\n    \n                    dim *= scale;\n                }\n    \n                return dim;\n            }\n        }\n    \n    // brightness control\n        class Brightness {\n    \n            static AdjustBrightness(color, level) {\n    \n                return Common.Truncate(color + level);\n            }\n        }\n    \n    // color interpolation\n        class Interpolate {\n    \n            static Interpolate3P(pixel1, pixel2, pixel3) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3)) / 3);\n                var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3)) / 3);\n                var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3)) / 3);\n                var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3)) / 3);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P(pixel1, pixel2) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) + Common.Red(pixel2)) >> 1);\n                var g = parseInt(parseInt(Common.Green(pixel1) + Common.Green(pixel2)) >> 1);\n                var b = parseInt(parseInt(Common.Blue(pixel1) + Common.Blue(pixel2)) >> 1);\n                var a = parseInt(parseInt(Common.Alpha(pixel1) + Common.Alpha(pixel2)) >> 1);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P1Q(pixel1, pixel2, quantifier) {\n    \n                var r = parseInt(parseInt(Common.Red(pixel1) * (1.0 - quantifier) + Common.Red(pixel2) * quantifier));\n                var g = parseInt(parseInt(Common.Green(pixel1) * (1.0 - quantifier) + Common.Green(pixel2) * quantifier));\n                var b = parseInt(parseInt(Common.Blue(pixel1) * (1.0 - quantifier) + Common.Blue(pixel2) * quantifier));\n                var a = parseInt(parseInt(Common.Alpha(pixel1) * (1.0 - quantifier) + Common.Alpha(pixel2) * quantifier));\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate2P2Q(pixel1, pixel2, quantifier1, quantifier2) {\n    \n                var total = (quantifier1 + quantifier2);\n    \n                var r = parseInt(((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2)) / total);\n                var g = parseInt(((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2)) / total);\n                var b = parseInt(((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2)) / total);\n                var a = parseInt(((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2)) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate3P3Q(pixel1, pixel2, pixel3, quantifier1, quantifier2, quantifier3) {\n    \n                var total = parseInt(quantifier1 + quantifier2 + quantifier3);\n    \n                var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3) / total);\n                var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3) / total);\n                var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3) / total);\n                var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate4P(pixel1, pixel2, pixel3, pixel4) {\n    \n                var r = parseInt((Common.Red(pixel1) + Common.Red(pixel2) + Common.Red(pixel3) + Common.Red(pixel4)) >> 2);\n                var g = parseInt((Common.Green(pixel1) + Common.Green(pixel2) + Common.Green(pixel3) + Common.Green(pixel4)) >> 2);\n                var b = parseInt((Common.Blue(pixel1) + Common.Blue(pixel2) + Common.Blue(pixel3) + Common.Blue(pixel4)) >> 2);\n                var a = parseInt((Common.Alpha(pixel1) + Common.Alpha(pixel2) + Common.Alpha(pixel3) + Common.Alpha(pixel4)) >> 2);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Interpolate4P4Q(pixel1, pixel2, pixel3, pixel4, quantifier1, quantifier2, quantifier3, quantifier4) {\n    \n                var total = parseInt(quantifier1 + quantifier2 + quantifier3 + quantifier4);\n    \n                var r = parseInt((Common.Red(pixel1) * quantifier1 + Common.Red(pixel2) * quantifier2 + Common.Red(pixel3) * quantifier3 + Common.Red(pixel4) * quantifier4) / total);\n                var g = parseInt((Common.Green(pixel1) * quantifier1 + Common.Green(pixel2) * quantifier2 + Common.Green(pixel3) * quantifier3 + Common.Green(pixel4) * quantifier4) / total);\n                var b = parseInt((Common.Blue(pixel1) * quantifier1 + Common.Blue(pixel2) * quantifier2 + Common.Blue(pixel3) * quantifier3 + Common.Blue(pixel4) * quantifier4) / total);\n                var a = parseInt((Common.Alpha(pixel1) * quantifier1 + Common.Alpha(pixel2) * quantifier2 + Common.Alpha(pixel3) * quantifier3 + Common.Alpha(pixel4) * quantifier4) / total);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            static Mixpal(c1, c2) {\n    \n                return (this.Interpolate2P2Q(c1, c2, 3, 1));\n            }\n    \n            static Fix(n, min, max) {\n    \n                return Math.max(Math.min(n, max), min);\n            }\n    \n            static Unmix(c1, c2) {\n    \n                /* A variant of an unsharp mask, without the blur part. */\n    \n                var ra = Common.Red(c1);\n                var ga = Common.Green(c1);\n                var ba = Common.Blue(c1);\n                var aa = Common.Alpha(c1);\n    \n                var rb = Common.Red(c2);\n                var gb = Common.Green(c2);\n                var bb = Common.Blue(c2);\n                var ab = Common.Alpha(c2);\n    \n                var r = ((this.Fix((ra + (ra - rb)), 0, 255) + rb) >> 1);\n                var g = ((this.Fix((ga + (ga - gb)), 0, 255) + gb) >> 1);\n                var b = ((this.Fix((ba + (ba - bb)), 0, 255) + bb) >> 1);\n                var a = ((this.Fix((aa + (aa - ab)), 0, 255) + ab) >> 1);\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n        }\n    \n    // image flips\n        class Flip {\n    \n            static FlipUD(src, sizex, sizey) {\n    \n                const Channels = 4;\n    \n                if (src.length > 0) {\n    \n                    for (var y = 0; y < sizey / 2; y++) {\n                        for (var x = 0; x < sizex; x++) {\n    \n                            var index = (y * sizex + x) * Channels;\n                            var rev = ((sizey - y - 1) * sizex + x) * Channels;\n    \n                            for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                                var temp = src[index + Channel];\n                                src[index + Channel] = src[rev + Channel];\n                                src[rev + Channel] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n    \n            static FlipLR(src, sizex, sizey) {\n    \n                const Channels = 4;\n    \n                if (src.length > 0) {\n    \n                    for (var y = 0; y < sizey; y++) {\n                        for (var x = 0; x < sizex / 2; x++) {\n    \n                            var index = (y * sizex + x) * Channels;\n                            var rev = (y * sizex + (sizex - x - 1)) * Channels;\n    \n                            for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                                var temp = src[index + Channel];\n                                src[index + Channel] = src[rev + Channel];\n                                src[rev + Channel] = temp;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    \n        class Rotate {\n    \n            static Transpose(dst, src, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                for (var y = 0; y < srcy; y++) {\n                    for (var x = 0; x < srcx; x++) {\n                        for (var Channel = 0; Channel < Channels; Channel++) {\n    \n                            dst[(x * srcy + y) * Channels + Channel] = src[(y * srcx + x) * Channels + Channel];\n                        }\n                    }\n                }\n            }\n    \n            static Rotate90(dst, src, srcx, srcy) {\n    \n                this.Transpose(dst, src, srcx, srcy);\n    \n                Flip.FlipUD(dst, srcy, srcx);\n            }\n    \n            static Rotate180(dst, src, srcx, srcy) {\n    \n                const Channels = 4;\n    \n                Common.Copy(dst, src, srcx * srcy * Channels);\n    \n                Flip.FlipUD(dst, srcx, srcy);\n    \n                Flip.FlipLR(dst, srcx, srcy);\n            }\n    \n            static Rotate270(dst, src, srcx, srcy) {\n    \n                Flip.FlipUD(src, srcx, srcy);\n    \n                this.Transpose(dst, src, srcx, srcy);\n            }\n        }\n    \n        class Kreed {\n    \n            static Conc2D(c00, c01, c10, c11) {\n    \n                var result = 0;\n    \n                var acAreAlike = Common.IsLike(c00, c10);\n    \n                var x = acAreAlike ? 1 : 0;\n                var y = (Common.IsLike(c01, c10) && !(acAreAlike)) ? 1 : 0;\n    \n                var adAreAlike = Common.IsLike(c00, c11);\n    \n                x += adAreAlike ? 1 : 0;\n                y += (Common.IsLike(c01, c11) && !(adAreAlike)) ? 1 : 0;\n    \n                if (x <= 1)\n                    result++;\n    \n                if (y <= 1)\n                    result--;\n    \n                return (result);\n            }\n        }\n    \n        class ReverseAA {\n    \n            static Clamp(v, min, max) {\n    \n                return parseInt(Math.min(max, Math.max(v, min)));\n            }\n    \n            static FullClamp(value) {\n    \n                return Common._Clip8(value);\n            }\n    \n            static _ReverseAntiAlias(b1, b, d, e, f, h, h5, d0, f4) {\n    \n                var n1 = b1;\n                var n2 = b;\n                var s = e;\n                var n3 = h;\n                var n4 = h5;\n                var aa = n2 - n1;\n                var bb = s - n2;\n                var cc = n3 - s;\n                var dd = n4 - n3;\n    \n                var tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                var m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var s1 = s + tilt / 2;\n                var s0 = s1 - tilt;\n    \n                n1 = d0;\n                n2 = d;\n                s = s0;\n                n3 = f;\n                n4 = f4;\n                aa = n2 - n1;\n                bb = s - n2;\n                cc = n3 - s;\n                dd = n4 - n3;\n    \n                tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var e1 = s + tilt / 2;\n                var e0 = e1 - tilt;\n    \n                s = s1;\n                bb = s - n2;\n                cc = n3 - s;\n    \n                tilt = (7 * (bb + cc) - 3 * (aa + dd)) / 16;\n    \n                m = (s < 128) ? 2 * s : 2 * (255 - s);\n    \n                m = Math.min(m, 2 * Math.abs(bb));\n                m = Math.min(m, 2 * Math.abs(cc));\n    \n                tilt = this.Clamp(tilt, -m, m);\n    \n                var e3 = s + tilt / 2;\n                var e2 = e3 - tilt;\n    \n                return { rd: this.FullClamp(e0), gn: this.FullClamp(e1), bl: this.FullClamp(e2), alpha: this.FullClamp(e3) };\n            }\n        }\n    \n    // image initialization\n        class Init {\n    \n            static Buffer(Length, c) {\n    \n                const Channels = 4;\n    \n                var buffer = new Uint8ClampedArray(Length * Channels);\n    \n                for (var i = 0; i < Length; i++) {\n    \n                    var index = i * Channels;\n    \n                    buffer[index] = parseInt(c);\n                    buffer[index + 1] = parseInt(c);\n                    buffer[index + 2] = parseInt(c);\n                    buffer[index + 3] = 255;\n                }\n    \n                return buffer;\n            }\n    \n            static New(x, y) {\n    \n                return this.Buffer(x * y, 0);\n            }\n    \n            static Init(srcx, srcy, FilterScaleX, FilterScaleY, ComparisonThreshold) {\n    \n                Common.ScaleX = FilterScaleX;\n                Common.ScaleY = FilterScaleY;\n                Common.SizeX = srcx * FilterScaleX;\n                Common.SizeY = srcy * FilterScaleY;\n                Common.Threshold = ComparisonThreshold;\n    \n                Common.ScaledImage = this.New(Common.SizeX, Common.SizeY);\n            }\n        }\n    \n    \n        // Lior Halphon's Omniscale (Modified: Uses Maxim Stepin's Color comparison routine)\n        var Filter = class {\n    \n            Apply(Input, srcx, srcy, scale, threshold) {\n    \n                var Channels = 4;\n    \n                scale = Math.max(1, scale);\n    \n                Init.Init(srcx, srcy, scale, scale, threshold);\n    \n                var total = Common.SizeY;\n                var current = 0;\n    \n                for (var y = 0; y < Common.SizeY; y++) {\n    \n                    var offset = y * Common.SizeX;\n                    var positiony = y / Common.SizeY;\n    \n                    for (var x = 0; x < Common.SizeX; x++) {\n    \n                        var argb = this.ScaleImage(Input, x / Common.SizeX, positiony, srcx, srcy, Common.SizeX, Common.SizeY);\n    \n                        Common.ScaledImage[(offset + x) * Channels] = Common.Red(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 1] = Common.Green(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 2] = Common.Blue(argb);\n                        Common.ScaledImage[(offset + x) * Channels + 3] = Common.Alpha(argb);\n                    }\n    \n                    current++;\n    \n                    //notify({ ScalingProgress: current / total });\n                }\n    \n                return new ImageData(new Uint8ClampedArray(Common.ScaledImage), srcx * scale, srcy * scale);\n            }\n    \n            is_different(a, b) {\n    \n                return Common.IsNotLike(a, b);\n            }\n    \n            mix(x, y, a) {\n    \n                return Interpolate.Interpolate2P1Q(x, y, a);\n            }\n    \n            fract(x) {\n    \n                return x - Math.floor(x);\n            }\n    \n            P(pattern, m, r) {\n    \n                return ((pattern & (m)) == (r))\n            }\n    \n            Mul(x, y) {\n    \n                var r = Common.Red(x) * y;\n                var g = Common.Green(x) * y;\n                var b = Common.Blue(x) * y;\n                var a = Common.Alpha(x) * y;\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            Add(x, y, scale) {\n    \n                var r = (Common.Red(x) + Common.Red(y)) * scale;\n                var g = (Common.Green(x) + Common.Green(y)) * scale;\n                var b = (Common.Blue(x) + Common.Blue(y)) * scale;\n                var a = (Common.Alpha(x) + Common.Alpha(y)) * scale;\n    \n                return Common.ARGBINT(a, r, g, b);\n            }\n    \n            length(a, b) {\n    \n                return Math.sqrt(a * a + b * b);\n            }\n    \n            ScaleImage(image, ppx, ppy, srcx, srcy, dstx, dsty) {\n    \n                var ox = 1.0 / srcx;\n                var oy = 1.0 / srcy;\n    \n                var px = this.fract(ppx * srcx);\n                var py = this.fract(ppy * srcy);\n    \n                if (px > 0.5) {\n    \n                    ox = -ox;\n                    px = 1.0 - px;\n                }\n    \n                if (py > 0.5) {\n    \n                    oy = -oy;\n                    py = 1.0 - py;\n                }\n    \n                // convert texture coordinates to image coordinates\n                ox = parseInt(ox * srcx);\n                oy = parseInt(oy * srcy);\n    \n                var positionx = parseInt(ppx * srcx);\n                var positiony = parseInt(ppy * srcy);\n    \n                var w0 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, -oy);\n                var w1 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, -oy);\n                var w2 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, -oy);\n                var w3 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, 0);\n                var w4 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, 0);\n                var w5 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, 0);\n                var w6 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, oy);\n                var w7 = Common.CLR(image, srcx, srcy, positionx, positiony, 0, oy);\n                var w8 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, oy);\n    \n                var pattern = 0;\n    \n                if (this.is_different(w0, w4)) pattern |= (1 << 0);\n                if (this.is_different(w1, w4)) pattern |= (1 << 1);\n                if (this.is_different(w2, w4)) pattern |= (1 << 2);\n                if (this.is_different(w3, w4)) pattern |= (1 << 3);\n                if (this.is_different(w5, w4)) pattern |= (1 << 4);\n                if (this.is_different(w6, w4)) pattern |= (1 << 5);\n                if (this.is_different(w7, w4)) pattern |= (1 << 6);\n                if (this.is_different(w8, w4)) pattern |= (1 << 7);\n    \n                if ((this.P(pattern, 0xbf, 0x37) || this.P(pattern, 0xdb, 0x13)) && this.is_different(w1, w5))\n                    return this.mix(w4, w3, 0.5 - px);\n    \n                if ((this.P(pattern, 0xdb, 0x49) || this.P(pattern, 0xef, 0x6d)) && this.is_different(w7, w3))\n                    return this.mix(w4, w1, 0.5 - py);\n    \n                if ((this.P(pattern, 0x0b, 0x0b) || this.P(pattern, 0xfe, 0x4a) || this.P(pattern, 0xfe, 0x1a)) && this.is_different(w3, w1))\n                    return w4;\n    \n                if ((this.P(pattern, 0x6f, 0x2a) || this.P(pattern, 0x5b, 0x0a) || this.P(pattern, 0xbf, 0x3a) || this.P(pattern, 0xdf, 0x5a) || this.P(pattern, 0x9f, 0x8a) || this.P(pattern, 0xcf, 0x8a) || this.P(pattern, 0xef, 0x4e) || this.P(pattern, 0x3f, 0x0e) ||\n                    this.P(pattern, 0xfb, 0x5a) || this.P(pattern, 0xbb, 0x8a) || this.P(pattern, 0x7f, 0x5a) || this.P(pattern, 0xaf, 0x8a) || this.P(pattern, 0xeb, 0x8a)) && this.is_different(w3, w1))\n                    return this.mix(w4, this.mix(w4, w0, 0.5 - px), 0.5 - py);\n    \n                if (this.P(pattern, 0x0b, 0x08))\n                    return this.mix(this.mix(this.Mul(w0, 0.375) + this.Mul(w1, 0.25) + this.Mul(w4, 0.375), this.Mul(w4, 0.5) + this.Mul(w1, 0.5), px * 2.0), w4, py * 2.0);\n    \n                if (this.P(pattern, 0x0b, 0x02))\n                    return this.mix(this.mix(this.Mul(w0, 0.375) + this.Mul(w3, 0.25) + this.Mul(w4, 0.375), this.Mul(w4, 0.5) + this.Mul(w3, 0.5), py * 2.0), w4, px * 2.0);\n    \n                var r, dist, pixel_size;\n    \n                if (this.P(pattern, 0x2f, 0x2f)) {\n    \n                    dist = this.length(px - 0.5, py - 0.5);\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist > 0.5 + pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(w4, r, (dist - 0.5 + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xbf, 0x37) || this.P(pattern, 0xdb, 0x13)) {\n    \n                    dist = px - 2.0 * py;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (dist > pixel_size / 2) {\n    \n                        return w1;\n                    }\n    \n                    r = this.mix(w3, w4, px + 0.5);\n    \n                    if (dist < -pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w1, (dist + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xdb, 0x49) || this.P(pattern, 0xef, 0x6d)) {\n    \n                    dist = py - 2.0 * px;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (py - 2.0 * px > pixel_size / 2) {\n    \n                        return w3;\n                    }\n    \n                    r = this.mix(w1, w4, px + 0.5);\n    \n                    if (dist < -pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w3, (dist + pixel_size / 2) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0xbf, 0x8f) || this.P(pattern, 0x7e, 0x0e)) {\n    \n                    dist = px + 2.0 * py;\n    \n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (dist > 1.0 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 1.0 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 1.0) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x7e, 0x2a) || this.P(pattern, 0xef, 0xab)) {\n    \n                    dist = py + 2.0 * px;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy)) * Math.sqrt(5.0);\n    \n                    if (py + 2.0 * px > 1.0 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 1.0 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 1.0) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x1b, 0x03) || this.P(pattern, 0x4f, 0x43) || this.P(pattern, 0x8b, 0x83) || this.P(pattern, 0x6b, 0x43))\n                    return this.mix(w4, w3, 0.5 - px);\n    \n                if (this.P(pattern, 0x4b, 0x09) || this.P(pattern, 0x8b, 0x89) || this.P(pattern, 0x1f, 0x19) || this.P(pattern, 0x3b, 0x19))\n                    return this.mix(w4, w1, 0.5 - py);\n    \n                if (this.P(pattern, 0xfb, 0x6a) || this.P(pattern, 0x6f, 0x6e) || this.P(pattern, 0x3f, 0x3e) || this.P(pattern, 0xfb, 0xfa) || this.P(pattern, 0xdf, 0xde) || this.P(pattern, 0xdf, 0x1e))\n                    return this.mix(w4, w0, (1.0 - px - py) / 2.0);\n    \n                if (this.P(pattern, 0x4f, 0x4b) || this.P(pattern, 0x9f, 0x1b) || this.P(pattern, 0x2f, 0x0b) || this.P(pattern, 0xbe, 0x0a) || this.P(pattern, 0xee, 0x0a) || this.P(pattern, 0x7e, 0x0a) || this.P(pattern, 0xeb, 0x4b) || this.P(pattern, 0x3b, 0x1b)) {\n    \n                    dist = px + py;\n                    pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                    if (dist > 0.5 + pixel_size / 2) {\n    \n                        return w4;\n                    }\n    \n                    if (this.is_different(w0, w1) || this.is_different(w0, w3)) {\n    \n                        r = this.mix(w1, w3, py - px + 0.5);\n    \n                    } else {\n    \n                        r = this.mix(this.mix(this.Mul(w1, 0.375) + this.Mul(w0, 0.25) + this.Mul(w3, 0.375), w3, py * 2.0), w1, px * 2.0);\n                    }\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 0.5) / pixel_size);\n                }\n    \n                if (this.P(pattern, 0x0b, 0x01))\n                    return this.mix(this.mix(w4, w3, 0.5 - px), this.mix(w1, this.Add(w1, w3, 0.5), 0.5 - px), 0.5 - py);\n    \n                if (this.P(pattern, 0x0b, 0x00))\n                    return this.mix(this.mix(w4, w3, 0.5 - px), this.mix(w1, w0, 0.5 - px), 0.5 - py);\n    \n                dist = px + py;\n                pixel_size = this.length(1.0 / (dstx / srcx), 1.0 / (dsty / srcy));\n    \n                if (dist > 0.5 + pixel_size / 2)\n                    return w4;\n    \n                /* We need more samples to \"solve\" this diagonal */\n                var x0 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, -oy);\n                var x1 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox, -oy * 2.0);\n                var x2 = Common.CLR(image, srcx, srcy, positionx, positiony, 0.0, -oy * 2.0);\n                var x3 = Common.CLR(image, srcx, srcy, positionx, positiony, ox, -oy * 2.0);\n                var x4 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, -oy);\n                var x5 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, 0.0);\n                var x6 = Common.CLR(image, srcx, srcy, positionx, positiony, -ox * 2.0, oy);\n    \n                if (this.is_different(x0, w4)) pattern |= 1 << 8;\n                if (this.is_different(x1, w4)) pattern |= 1 << 9;\n                if (this.is_different(x2, w4)) pattern |= 1 << 10;\n                if (this.is_different(x3, w4)) pattern |= 1 << 11;\n                if (this.is_different(x4, w4)) pattern |= 1 << 12;\n                if (this.is_different(x5, w4)) pattern |= 1 << 13;\n                if (this.is_different(x6, w4)) pattern |= 1 << 14;\n    \n                var diagonal_bias = -7;\n    \n                while (pattern != 0) {\n    \n                    diagonal_bias += pattern & 1;\n                    pattern >>= 1;\n                }\n    \n                if (diagonal_bias <= 0) {\n    \n                    r = this.mix(w1, w3, py - px + 0.5);\n    \n                    if (dist < 0.5 - pixel_size / 2) {\n    \n                        return r;\n                    }\n    \n                    return this.mix(r, w4, (dist + pixel_size / 2 - 0.5) / pixel_size);\n                }\n    \n                return w4;\n            }\n        }\n    \n        const fltr = new Filter();\n        return fltr.Apply(image_data.data, image_data.width, image_data.height, scale, 1);\n    }",n.exports={omniscale:function t(e,i,r){var s=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;s?s.exec(new Function(window.omniscale_process_function_string)(),[e,i]).catch(function(n){return"Pool terminated"===n?t(e,i,r,s):new Function(window.omniscale_process_function_string)()(e,i)}).then(function(n){r(n)}).timeout(36e4):new Function(window.omniscale_process_function_string)()(e,i).then(function(n){r(n)}).then()}}}}]);