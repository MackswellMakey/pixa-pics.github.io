(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{983:function(t,n,e){"use strict";var e=e(323),a=e&&e.__esModule?e:{default:e};window.image_tracer_process_function_string="return function(image_data, options){\n\n    \"use strict\";\n\tfunction ImageTracer(){\n\t\tvar _this = this;\n\n\t\tthis.versionnumber = '1.2.6',\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  API\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Loading an image from a URL, tracing when loaded,\n\t\t// then executing callback with the scaled svg string as argument\n\t\tthis.imageToSVG = function( url, callback, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// loading image, tracing and callback\n\t\t\t_this.loadImage(\n\t\t\t\turl,\n\t\t\t\tfunction(canvas){\n\t\t\t\t\tcallback(\n\t\t\t\t\t\t_this.imagedataToSVG( _this.getImgdata(canvas), options )\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\toptions\n\t\t\t);\n\t\t},// End of imageToSVG()\n\n\t\t// Tracing imagedata, then returning the scaled svg string\n\t\tthis.imagedataToSVG = function( imgd, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// tracing imagedata\n\t\t\tvar td = _this.imagedataToTracedata( imgd, options );\n\t\t\t// returning SVG string\n\t\t\treturn _this.getsvgstring(td, options);\n\t\t},// End of imagedataToSVG()\n\n\t\t// Loading an image from a URL, tracing when loaded,\n\t\t// then executing callback with tracedata as argument\n\t\tthis.imageToTracedata = function( url, callback, options ){\n\t\t\toptions = _this.checkoptions(options);\n\t\t\t// loading image, tracing and callback\n\t\t\t_this.loadImage(\n\t\t\t\t\turl,\n\t\t\t\t\tfunction(canvas){\n\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t_this.imagedataToTracedata( _this.getImgdata(canvas), options )\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\toptions\n\t\t\t);\n\t\t},// End of imageToTracedata()\n\n\t\t// Tracing imagedata, then returning tracedata (layers with paths, palette, image size)\n\t\tthis.imagedataToTracedata = function( imgd, options ){\n\t\t\toptions = _this.checkoptions(options);\n\n\t\t\t// 1. Color quantization\n\t\t\tvar ii = _this.colorquantization( imgd, options );\n\n\t\t\tif(options.layering === 0){// Sequential layering\n\n\t\t\t\t// create tracedata object\n\t\t\t\tvar tracedata = {\n\t\t\t\t\tlayers : [],\n\t\t\t\t\tpalette : ii.palette,\n\t\t\t\t\twidth : ii.array[0].length-2,\n\t\t\t\t\theight : ii.array.length-2\n\t\t\t\t};\n\n\t\t\t\t// Loop to trace each color layer\n\t\t\t\tfor(var colornum=0; colornum<ii.palette.length; colornum++){\n\n\t\t\t\t\t// layeringstep -> pathscan -> internodes -> batchtracepaths\n\t\t\t\t\tvar tracedlayer =\n\t\t\t\t\t\t_this.batchtracepaths(\n\n\t\t\t\t\t\t\t_this.internodes(\n\n\t\t\t\t\t\t\t\t_this.pathscan(\n\t\t\t\t\t\t\t\t\t_this.layeringstep( ii, colornum ),\n\t\t\t\t\t\t\t\t\toptions.pathomit\n\t\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\t\toptions\n\n\t\t\t\t\t\t\t),\n\n\t\t\t\t\t\t\toptions.ltres,\n\t\t\t\t\t\t\toptions.qtres\n\n\t\t\t\t\t\t);\n\n\t\t\t\t\t// adding traced layer\n\t\t\t\t\ttracedata.layers.push(tracedlayer);\n\n\t\t\t\t}// End of color loop\n\n\t\t\t}else{// Parallel layering\n\t\t\t\t// 2. Layer separation and edge detection\n\t\t\t\tvar ls = _this.layering( ii );\n\n\t\t\t\t// Optional edge node visualization\n\t\t\t\tif(options.layercontainerid){ _this.drawLayers( ls, _this.specpalette, options.scale, options.layercontainerid ); }\n\n\t\t\t\t// 3. Batch pathscan\n\t\t\t\tvar bps = _this.batchpathscan( ls, options.pathomit );\n\n\t\t\t\t// 4. Batch interpollation\n\t\t\t\tvar bis = _this.batchinternodes( bps, options );\n\n\t\t\t\t// 5. Batch tracing and creating tracedata object\n\t\t\t\tvar tracedata = {\n\t\t\t\t\tlayers : _this.batchtracelayers( bis, options.ltres, options.qtres ),\n\t\t\t\t\tpalette : ii.palette,\n\t\t\t\t\twidth : imgd.width,\n\t\t\t\t\theight : imgd.height\n\t\t\t\t};\n\n\t\t\t}// End of parallel layering\n\n\t\t\t// return tracedata\n\t\t\treturn tracedata;\n\n\t\t},// End of imagedataToTracedata()\n\n\t\tthis.optionpresets = {\n\t\t\t'default': {\n\n\t\t\t\t// Tracing\n\t\t\t\tcorsenabled : false,\n\t\t\t\tltres : 1,\n\t\t\t\tqtres : 1,\n\t\t\t\tpathomit : 8,\n\t\t\t\trightangleenhance : true,\n\n\t\t\t\t// Color quantization\n\t\t\t\tcolorsampling : 2,\n\t\t\t\tnumberofcolors : 16,\n\t\t\t\tmincolorratio : 0,\n\t\t\t\tcolorquantcycles : 3,\n\n\t\t\t\t// Layering method\n\t\t\t\tlayering : 0,\n\n\t\t\t\t// SVG rendering\n\t\t\t\tstrokewidth : 1,\n\t\t\t\tlinefilter : false,\n\t\t\t\tscale : 1,\n\t\t\t\troundcoords : 1,\n\t\t\t\tviewbox : false,\n\t\t\t\tdesc : false,\n\t\t\t\tlcpr : 0,\n\t\t\t\tqcpr : 0,\n\n\t\t\t\t// Blur\n\t\t\t\tblurradius : 0,\n\t\t\t\tblurdelta : 20\n\n\t\t\t},\n\t\t\t'posterized1': { colorsampling:0, numberofcolors:2 },\n\t\t\t'posterized2': { numberofcolors:4, blurradius:5 },\n\t\t\t'curvy': { ltres:0.01, linefilter:true, rightangleenhance:false },\n\t\t\t'sharp': { qtres:0.01, linefilter:false },\n\t\t\t'detailed': { pathomit:0, roundcoords:2, ltres:0.5, qtres:0.5, numberofcolors:64 },\n\t\t\t'smoothed': { blurradius:5, blurdelta: 64 },\n\t\t\t'grayscale': { colorsampling:0, colorquantcycles:1, numberofcolors:7 },\n\t\t\t'fixedpalette': { colorsampling:0, colorquantcycles:1, numberofcolors:27 },\n\t\t\t'randomsampling1': { colorsampling:1, numberofcolors:8 },\n\t\t\t'randomsampling2': { colorsampling:1, numberofcolors:64 },\n\t\t\t'artistic1': { colorsampling:0, colorquantcycles:1, pathomit:0, blurradius:5, blurdelta: 64, ltres:0.01, linefilter:true, numberofcolors:16, strokewidth:2 },\n\t\t\t'artistic2': { qtres:0.01, colorsampling:0, colorquantcycles:1, numberofcolors:4, strokewidth:0 },\n\t\t\t'artistic3': { qtres:10, ltres:10, numberofcolors:8 },\n\t\t\t'artistic4': { qtres:10, ltres:10, numberofcolors:64, blurradius:5, blurdelta: 256, strokewidth:2 },\n\t\t\t'posterized3': { ltres: 1, qtres: 1, pathomit: 20, rightangleenhance: true, colorsampling: 0, numberofcolors: 3,\n\t\t\t\tmincolorratio: 0, colorquantcycles: 3, blurradius: 3, blurdelta: 20, strokewidth: 0, linefilter: false,\n\t\t\t\troundcoords: 1, pal: [ { r: 0, g: 0, b: 100, a: 255 }, { r: 255, g: 255, b: 255, a: 255 } ] }\n\t\t},// End of optionpresets\n\n\t\t// creating options object, setting defaults for missing values\n\t\tthis.checkoptions = function(options){\n\t\t\toptions = options || {};\n\t\t\t// Option preset\n\t\t\tif(typeof options === 'string'){\n\t\t\t\toptions = options.toLowerCase();\n\t\t\t\tif( _this.optionpresets[options] ){ options = _this.optionpresets[options]; }else{ options = {}; }\n\t\t\t}\n\t\t\t// Defaults\n\t\t\tvar ok = Object.keys(_this.optionpresets['default']);\n\t\t\tfor(var k=0; k<ok.length; k++){\n\t\t\t\tif(!options.hasOwnProperty(ok[k])){ options[ok[k]] = _this.optionpresets['default'][ok[k]]; }\n\t\t\t}\n\t\t\t// options.pal is not defined here, the custom palette should be added externally: options.pal = [ { 'r':0, 'g':0, 'b':0, 'a':255 }, {...}, ... ];\n\t\t\t// options.layercontainerid is not defined here, can be added externally: options.layercontainerid = 'mydiv'; ... <div id=\"mydiv\"></div>\n\t\t\treturn options;\n\t\t},// End of checkoptions()\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  Vectorizing functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// 1. Color quantization\n\t\t// Using a form of k-means clustering repeatead options.colorquantcycles times. http://en.wikipedia.org/wiki/Color_quantization\n\t\tthis.colorquantization = function( imgd, options ){\n\t\t\tvar arr = [], idx=0, cd,cdl,ci, paletteacc = [], pixelnum = imgd.width * imgd.height, i, j, k, cnt, palette;\n\n\t\t\t// imgd.data must be RGBA, not just RGB\n\t\t\tif( imgd.data.length < pixelnum * 4 ){\n\t\t\t\tvar newimgddata = new Uint8ClampedArray(pixelnum * 4);\n\t\t\t\tfor(var pxcnt = 0; pxcnt < pixelnum ; pxcnt++){\n\t\t\t\t\tnewimgddata[pxcnt*4  ] = imgd.data[pxcnt*3  ];\n\t\t\t\t\tnewimgddata[pxcnt*4+1] = imgd.data[pxcnt*3+1];\n\t\t\t\t\tnewimgddata[pxcnt*4+2] = imgd.data[pxcnt*3+2];\n\t\t\t\t\tnewimgddata[pxcnt*4+3] = 255;\n\t\t\t\t}\n\t\t\t\timgd.data = newimgddata;\n\t\t\t}// End of RGBA imgd.data check\n\n\t\t\t// Filling arr (color index array) with -1\n\t\t\tfor( j=0; j<imgd.height+2; j++ ){ arr[j]=[]; for(i=0; i<imgd.width+2 ; i++){ arr[j][i] = -1; } }\n\n\t\t\t// Use custom palette if pal is defined or sample / generate custom length palette\n\t\t\tif(options.pal){\n\t\t\t\tpalette = options.pal;\n\t\t\t}else if(options.colorsampling === 0){\n\t\t\t\tpalette = _this.generatepalette(options.numberofcolors);\n\t\t\t}else if(options.colorsampling === 1){\n\t\t\t\tpalette = _this.samplepalette( options.numberofcolors, imgd );\n\t\t\t}else{\n\t\t\t\tpalette = _this.samplepalette2( options.numberofcolors, imgd );\n\t\t\t}\n\n\t\t\t// Selective Gaussian blur preprocessing\n\t\t\tif( options.blurradius > 0 ){ imgd = _this.blur( imgd, options.blurradius, options.blurdelta ); }\n\n\t\t\t// Repeat clustering step options.colorquantcycles times\n\t\t\tfor( cnt=0; cnt < options.colorquantcycles; cnt++ ){\n\n\t\t\t\t// Average colors from the second iteration\n\t\t\t\tif(cnt>0){\n\t\t\t\t\t// averaging paletteacc for palette\n\t\t\t\t\tfor( k=0; k < palette.length; k++ ){\n\n\t\t\t\t\t\t// averaging\n\t\t\t\t\t\tif( paletteacc[k].n > 0 ){\n\t\t\t\t\t\t\tpalette[k] = {  r: Math.floor( paletteacc[k].r / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\tg: Math.floor( paletteacc[k].g / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\tb: Math.floor( paletteacc[k].b / paletteacc[k].n ),\n\t\t\t\t\t\t\t\t\t\t\ta:  Math.floor( paletteacc[k].a / paletteacc[k].n ) };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Randomizing a color, if there are too few pixels and there will be a new cycle\n\t\t\t\t\t\tif( ( paletteacc[k].n/pixelnum < options.mincolorratio ) && ( cnt < options.colorquantcycles-1 ) ){\n\t\t\t\t\t\t\tpalette[k] = {  r: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\tg: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\tb: Math.floor(Math.random()*255),\n\t\t\t\t\t\t\t\t\t\t\ta: Math.floor(Math.random()*255) };\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}// End of palette loop\n\t\t\t\t}// End of Average colors from the second iteration\n\n\t\t\t\t// Reseting palette accumulator for averaging\n\t\t\t\tfor( i=0; i < palette.length; i++ ){ paletteacc[i] = { r:0, g:0, b:0, a:0, n:0 }; }\n\n\t\t\t\t// loop through all pixels\n\t\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\t\t// pixel index\n\t\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\n\t\t\t\t\t\t// find closest color from palette by measuring (rectilinear) color distance between this pixel and all palette colors\n\t\t\t\t\t\tci=0; cdl = 1024; // 4 * 256 is the maximum RGBA distance\n\t\t\t\t\t\tfor( k=0; k<palette.length; k++ ){\n\n\t\t\t\t\t\t\t// In my experience, https://en.wikipedia.org/wiki/Rectilinear_distance works better than https://en.wikipedia.org/wiki/Euclidean_distance\n\t\t\t\t\t\t\tcd =\n\t\t\t\t\t\t\t\t( palette[k].r > imgd.data[idx  ] ? palette[k].r - imgd.data[idx  ] : imgd.data[idx  ] - palette[k].r ) +\n\t\t\t\t\t\t\t\t( palette[k].g > imgd.data[idx+1] ? palette[k].g - imgd.data[idx+1] : imgd.data[idx+1] - palette[k].g ) +\n\t\t\t\t\t\t\t\t( palette[k].b > imgd.data[idx+2] ? palette[k].b - imgd.data[idx+2] : imgd.data[idx+2] - palette[k].b ) +\n\t\t\t\t\t\t\t\t( palette[k].a > imgd.data[idx+3] ? palette[k].a - imgd.data[idx+3] : imgd.data[idx+3] - palette[k].a );\n\n\t\t\t\t\t\t\t// Remember this color if this is the closest yet\n\t\t\t\t\t\t\tif(cd<cdl){ cdl = cd; ci = k; }\n\n\t\t\t\t\t\t}// End of palette loop\n\n\t\t\t\t\t\t// add to palettacc\n\t\t\t\t\t\tpaletteacc[ci].r += imgd.data[idx  ];\n\t\t\t\t\t\tpaletteacc[ci].g += imgd.data[idx+1];\n\t\t\t\t\t\tpaletteacc[ci].b += imgd.data[idx+2];\n\t\t\t\t\t\tpaletteacc[ci].a += imgd.data[idx+3];\n\t\t\t\t\t\tpaletteacc[ci].n++;\n\n\t\t\t\t\t\t// update the indexed color array\n\t\t\t\t\t\tarr[j+1][i+1] = ci;\n\n\t\t\t\t\t}// End of i loop\n\t\t\t\t}// End of j loop\n\n\t\t\t}// End of Repeat clustering step options.colorquantcycles times\n\n\t\t\treturn { array:arr, palette:palette };\n\n\t\t},// End of colorquantization()\n\n\t\t// Sampling a palette from imagedata\n\t\tthis.samplepalette = function( numberofcolors, imgd ){\n\t\t\tvar idx, palette=[];\n\t\t\tfor(var i=0; i<numberofcolors; i++){\n\t\t\t\tidx = Math.floor( Math.random() * imgd.data.length / 4 ) * 4;\n\t\t\t\tpalette.push({ r:imgd.data[idx  ], g:imgd.data[idx+1], b:imgd.data[idx+2], a:imgd.data[idx+3] });\n\t\t\t}\n\t\t\treturn palette;\n\t\t},// End of samplepalette()\n\n\t\t// Deterministic sampling a palette from imagedata: rectangular grid\n\t\tthis.samplepalette2 = function( numberofcolors, imgd ){\n\t\t\tvar idx, palette=[], ni = Math.ceil(Math.sqrt(numberofcolors)), nj = Math.ceil(numberofcolors/ni),\n\t\t\t\tvx = imgd.width / (ni+1), vy = imgd.height / (nj+1);\n\t\t\tfor(var j=0; j<nj; j++){\n\t\t\t\tfor(var i=0; i<ni; i++){\n\t\t\t\t\tif(palette.length === numberofcolors){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tidx = Math.floor( ((j+1)*vy) * imgd.width + ((i+1)*vx) ) * 4;\n\t\t\t\t\t\tpalette.push( { r:imgd.data[idx], g:imgd.data[idx+1], b:imgd.data[idx+2], a:imgd.data[idx+3] } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn palette;\n\t\t},// End of samplepalette2()\n\n\t\t// Generating a palette with numberofcolors\n\t\tthis.generatepalette = function(numberofcolors){\n\t\t\tvar palette = [], rcnt, gcnt, bcnt;\n\t\t\tif(numberofcolors<8){\n\n\t\t\t\t// Grayscale\n\t\t\t\tvar graystep = Math.floor(255/(numberofcolors-1));\n\t\t\t\tfor(var i=0; i<numberofcolors; i++){ palette.push({ r:i*graystep, g:i*graystep, b:i*graystep, a:255 }); }\n\n\t\t\t}else{\n\n\t\t\t\t// RGB color cube\n\t\t\t\tvar colorqnum = Math.floor(Math.pow(numberofcolors, 1/3)), // Number of points on each edge on the RGB color cube\n\t\t\t\t\tcolorstep = Math.floor(255/(colorqnum-1)), // distance between points\n\t\t\t\t\trndnum = numberofcolors - colorqnum*colorqnum*colorqnum; // number of random colors\n\n\t\t\t\tfor(rcnt=0; rcnt<colorqnum; rcnt++){\n\t\t\t\t\tfor(gcnt=0; gcnt<colorqnum; gcnt++){\n\t\t\t\t\t\tfor(bcnt=0; bcnt<colorqnum; bcnt++){\n\t\t\t\t\t\t\tpalette.push( { r:rcnt*colorstep, g:gcnt*colorstep, b:bcnt*colorstep, a:255 } );\n\t\t\t\t\t\t}// End of blue loop\n\t\t\t\t\t}// End of green loop\n\t\t\t\t}// End of red loop\n\n\t\t\t\t// Rest is random\n\t\t\t\tfor(rcnt=0; rcnt<rndnum; rcnt++){ palette.push({ r:Math.floor(Math.random()*255), g:Math.floor(Math.random()*255), b:Math.floor(Math.random()*255), a:Math.floor(Math.random()*255) }); }\n\n\t\t\t}// End of numberofcolors check\n\n\t\t\treturn palette;\n\t\t},// End of generatepalette()\n\n\t\t// 2. Layer separation and edge detection\n\t\t// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n\t\t// 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n\t\t// 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n\t\t//     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\n\t\tthis.layering = function(ii){\n\t\t\t// Creating layers for each indexed color in arr\n\t\t\tvar layers = [], val=0, ah = ii.array.length, aw = ii.array[0].length, n1,n2,n3,n4,n5,n6,n7,n8, i, j, k;\n\n\t\t\t// Create layers\n\t\t\tfor(k=0; k<ii.palette.length; k++){\n\t\t\t\tlayers[k] = [];\n\t\t\t\tfor(j=0; j<ah; j++){\n\t\t\t\t\tlayers[k][j] = [];\n\t\t\t\t\tfor(i=0; i<aw; i++){\n\t\t\t\t\t\tlayers[k][j][i]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Looping through all pixels and calculating edge node type\n\t\t\tfor(j=1; j<ah-1; j++){\n\t\t\t\tfor(i=1; i<aw-1; i++){\n\n\t\t\t\t\t// This pixel's indexed color\n\t\t\t\t\tval = ii.array[j][i];\n\n\t\t\t\t\t// Are neighbor pixel colors the same?\n\t\t\t\t\tn1 = ii.array[j-1][i-1]===val ? 1 : 0;\n\t\t\t\t\tn2 = ii.array[j-1][i  ]===val ? 1 : 0;\n\t\t\t\t\tn3 = ii.array[j-1][i+1]===val ? 1 : 0;\n\t\t\t\t\tn4 = ii.array[j  ][i-1]===val ? 1 : 0;\n\t\t\t\t\tn5 = ii.array[j  ][i+1]===val ? 1 : 0;\n\t\t\t\t\tn6 = ii.array[j+1][i-1]===val ? 1 : 0;\n\t\t\t\t\tn7 = ii.array[j+1][i  ]===val ? 1 : 0;\n\t\t\t\t\tn8 = ii.array[j+1][i+1]===val ? 1 : 0;\n\n\t\t\t\t\t// this pixel's type and looking back on previous pixels\n\t\t\t\t\tlayers[val][j+1][i+1] = 1 + n5 * 2 + n8 * 4 + n7 * 8 ;\n\t\t\t\t\tif(!n4){ layers[val][j+1][i  ] = 0 + 2 + n7 * 4 + n6 * 8 ; }\n\t\t\t\t\tif(!n2){ layers[val][j  ][i+1] = 0 + n3*2 + n5 * 4 + 8 ; }\n\t\t\t\t\tif(!n1){ layers[val][j  ][i  ] = 0 + n2*2 + 4 + n4 * 8 ; }\n\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn layers;\n\t\t},// End of layering()\n\n\t\t// 2. Layer separation and edge detection\n\t\t// Edge node types ( ▓: this layer or 1; ░: not this layer or 0 )\n\t\t// 12  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓  ░░  ▓░  ░▓  ▓▓\n\t\t// 48  ░░  ░░  ░░  ░░  ░▓  ░▓  ░▓  ░▓  ▓░  ▓░  ▓░  ▓░  ▓▓  ▓▓  ▓▓  ▓▓\n\t\t//     0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15\n\t\tthis.layeringstep = function(ii,cnum){\n\t\t\t// Creating layers for each indexed color in arr\n\t\t\tvar layer = [], val=0, ah = ii.array.length, aw = ii.array[0].length, n1,n2,n3,n4,n5,n6,n7,n8, i, j, k;\n\n\t\t\t// Create layer\n\t\t\tfor(j=0; j<ah; j++){\n\t\t\t\tlayer[j] = [];\n\t\t\t\tfor(i=0; i<aw; i++){\n\t\t\t\t\tlayer[j][i]=0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Looping through all pixels and calculating edge node type\n\t\t\tfor(j=1; j<ah; j++){\n\t\t\t\tfor(i=1; i<aw; i++){\n\t\t\t\t\tlayer[j][i] =\n\t\t\t\t\t\t( ii.array[j-1][i-1]===cnum ? 1 : 0 ) +\n\t\t\t\t\t\t( ii.array[j-1][i]===cnum ? 2 : 0 ) +\n\t\t\t\t\t\t( ii.array[j][i-1]===cnum ? 8 : 0 ) +\n\t\t\t\t\t\t( ii.array[j][i]===cnum ? 4 : 0 )\n\t\t\t\t\t;\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn layer;\n\t\t},// End of layeringstep()\n\n\t\t// Point in polygon test\n\t\tthis.pointinpoly = function( p, pa ){\n\t\t\tvar isin=false;\n\n\t\t\tfor(var i=0,j=pa.length-1; i<pa.length; j=i++){\n\t\t\t\tisin =\n\t\t\t\t\t( ((pa[i].y > p.y) !== (pa[j].y > p.y)) && (p.x < (pa[j].x - pa[i].x) * (p.y - pa[i].y) / (pa[j].y - pa[i].y) + pa[i].x) )\n\t\t\t\t\t? !isin : isin;\n\t\t\t}\n\n\t\t\treturn isin;\n\t\t},\n\n\t\t// Lookup tables for pathscan\n\t\t// pathscan_combined_lookup[ arr[py][px] ][ dir ] = [nextarrpypx, nextdir, deltapx, deltapy];\n\t\tthis.pathscan_combined_lookup = [\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1]],// arr[py][px]===0 is invalid\n\t\t\t[[ 0, 1, 0,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 1, 0,-1], [ 0, 0, 1, 0]],\n\t\t\t[[ 0, 0, 1, 0], [-1,-1,-1,-1], [ 0, 2,-1, 0], [-1,-1,-1,-1]],\n\n\t\t\t[[-1,-1,-1,-1], [ 0, 0, 1, 0], [ 0, 3, 0, 1], [-1,-1,-1,-1]],\n\t\t\t[[13, 3, 0, 1], [13, 2,-1, 0], [ 7, 1, 0,-1], [ 7, 0, 1, 0]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 1, 0,-1], [-1,-1,-1,-1], [ 0, 3, 0, 1]],\n\t\t\t[[ 0, 3, 0, 1], [ 0, 2,-1, 0], [-1,-1,-1,-1], [-1,-1,-1,-1]],\n\n\t\t\t[[ 0, 3, 0, 1], [ 0, 2,-1, 0], [-1,-1,-1,-1], [-1,-1,-1,-1]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 1, 0,-1], [-1,-1,-1,-1], [ 0, 3, 0, 1]],\n\t\t\t[[11, 1, 0,-1], [14, 0, 1, 0], [14, 3, 0, 1], [11, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [ 0, 0, 1, 0], [ 0, 3, 0, 1], [-1,-1,-1,-1]],\n\n\t\t\t[[ 0, 0, 1, 0], [-1,-1,-1,-1], [ 0, 2,-1, 0], [-1,-1,-1,-1]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 1, 0,-1], [ 0, 0, 1, 0]],\n\t\t\t[[ 0, 1, 0,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [ 0, 2,-1, 0]],\n\t\t\t[[-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1], [-1,-1,-1,-1]]// arr[py][px]===15 is invalid\n\t\t],\n\n\t\t// 3. Walking through an edge node array, discarding edge node types 0 and 15 and creating paths from the rest.\n\t\t// Walk directions (dir): 0 > ; 1 ^ ; 2 < ; 3 v\n\t\tthis.pathscan = function( arr, pathomit ){\n\t\t\tvar paths=[], pacnt=0, pcnt=0, px=0, py=0, w = arr[0].length, h = arr.length,\n\t\t\t\tdir=0, pathfinished=true, holepath=false, lookuprow;\n\n\t\t\tfor(var j=0; j<h; j++){\n\t\t\t\tfor(var i=0; i<w; i++){\n\t\t\t\t\tif( (arr[j][i] == 4) || ( arr[j][i] == 11) ){ // Other values are not valid\n\n\t\t\t\t\t\t// Init\n\t\t\t\t\t\tpx = i; py = j;\n\t\t\t\t\t\tpaths[pacnt] = {};\n\t\t\t\t\t\tpaths[pacnt].points = [];\n\t\t\t\t\t\tpaths[pacnt].boundingbox = [px,py,px,py];\n\t\t\t\t\t\tpaths[pacnt].holechildren = [];\n\t\t\t\t\t\tpathfinished = false;\n\t\t\t\t\t\tpcnt=0;\n\t\t\t\t\t\tholepath = (arr[j][i]==11);\n\t\t\t\t\t\tdir = 1;\n\n\t\t\t\t\t\t// Path points loop\n\t\t\t\t\t\twhile(!pathfinished){\n\n\t\t\t\t\t\t\t// New path point\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt] = {};\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x = px-1;\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y = py-1;\n\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].t = arr[py][px];\n\n\t\t\t\t\t\t\t// Bounding box\n\t\t\t\t\t\t\tif( (px-1) < paths[pacnt].boundingbox[0] ){ paths[pacnt].boundingbox[0] = px-1; }\n\t\t\t\t\t\t\tif( (px-1) > paths[pacnt].boundingbox[2] ){ paths[pacnt].boundingbox[2] = px-1; }\n\t\t\t\t\t\t\tif( (py-1) < paths[pacnt].boundingbox[1] ){ paths[pacnt].boundingbox[1] = py-1; }\n\t\t\t\t\t\t\tif( (py-1) > paths[pacnt].boundingbox[3] ){ paths[pacnt].boundingbox[3] = py-1; }\n\n\t\t\t\t\t\t\t// Next: look up the replacement, direction and coordinate changes = clear this cell, turn if required, walk forward\n\t\t\t\t\t\t\tlookuprow = _this.pathscan_combined_lookup[ arr[py][px] ][ dir ];\n\t\t\t\t\t\t\tarr[py][px] = lookuprow[0]; dir = lookuprow[1]; px += lookuprow[2]; py += lookuprow[3];\n\n\t\t\t\t\t\t\t// Close path\n\t\t\t\t\t\t\tif( (px-1 === paths[pacnt].points[0].x ) && ( py-1 === paths[pacnt].points[0].y ) ){\n\t\t\t\t\t\t\t\tpathfinished = true;\n\n\t\t\t\t\t\t\t\t// Discarding paths shorter than pathomit\n\t\t\t\t\t\t\t\tif( paths[pacnt].points.length < pathomit ){\n\t\t\t\t\t\t\t\t\tpaths.pop();\n\t\t\t\t\t\t\t\t}else{\n\n\t\t\t\t\t\t\t\t\tpaths[pacnt].isholepath = holepath ? true : false;\n\n\t\t\t\t\t\t\t\t\t// Finding the parent shape for this hole\n\t\t\t\t\t\t\t\t\tif(holepath){\n\n\t\t\t\t\t\t\t\t\t\tvar parentidx = 0, parentbbox = [-1,-1,w+1,h+1];\n\t\t\t\t\t\t\t\t\t\tfor(var parentcnt=0; parentcnt < pacnt; parentcnt++){\n\t\t\t\t\t\t\t\t\t\t\tif( (!paths[parentcnt].isholepath) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.boundingboxincludes( paths[parentcnt].boundingbox , paths[pacnt].boundingbox ) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.boundingboxincludes( parentbbox , paths[parentcnt].boundingbox ) &&\n\t\t\t\t\t\t\t\t\t\t\t\t_this.pointinpoly( paths[pacnt].points[0], paths[parentcnt].points )\n\t\t\t\t\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\t\t\t\t\tparentidx = parentcnt;\n\t\t\t\t\t\t\t\t\t\t\t\tparentbbox = paths[parentcnt].boundingbox;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tpaths[parentidx].holechildren.push( pacnt );\n\n\t\t\t\t\t\t\t\t\t}// End of holepath parent finding\n\n\t\t\t\t\t\t\t\t\tpacnt++;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}// End of Close path\n\n\t\t\t\t\t\t\tpcnt++;\n\n\t\t\t\t\t\t}// End of Path points loop\n\n\t\t\t\t\t}// End of Follow path\n\n\t\t\t\t}// End of i loop\n\t\t\t}// End of j loop\n\n\t\t\treturn paths;\n\t\t},// End of pathscan()\n\n\t\tthis.boundingboxincludes = function( parentbbox, childbbox ){\n\t\t\treturn ( ( parentbbox[0] < childbbox[0] ) && ( parentbbox[1] < childbbox[1] ) && ( parentbbox[2] > childbbox[2] ) && ( parentbbox[3] > childbbox[3] ) );\n\t\t},// End of boundingboxincludes()\n\n\t\t// 3. Batch pathscan\n\t\tthis.batchpathscan = function( layers, pathomit ){\n\t\t\tvar bpaths = [];\n\t\t\tfor(var k in layers){\n\t\t\t\tif(!layers.hasOwnProperty(k)){ continue; }\n\t\t\t\tbpaths[k] = _this.pathscan( layers[k], pathomit );\n\t\t\t}\n\t\t\treturn bpaths;\n\t\t},\n\n\t\t// 4. interpollating between path points for nodes with 8 directions ( East, SouthEast, S, SW, W, NW, N, NE )\n\t\tthis.internodes = function( paths, options ){\n\t\t\tvar ins = [], palen=0, nextidx=0, nextidx2=0, previdx=0, previdx2=0, pacnt, pcnt;\n\n\t\t\t// paths loop\n\t\t\tfor(pacnt=0; pacnt<paths.length; pacnt++){\n\n\t\t\t\tins[pacnt] = {};\n\t\t\t\tins[pacnt].points = [];\n\t\t\t\tins[pacnt].boundingbox = paths[pacnt].boundingbox;\n\t\t\t\tins[pacnt].holechildren = paths[pacnt].holechildren;\n\t\t\t\tins[pacnt].isholepath = paths[pacnt].isholepath;\n\t\t\t\tpalen = paths[pacnt].points.length;\n\n\t\t\t\t// pathpoints loop\n\t\t\t\tfor(pcnt=0; pcnt<palen; pcnt++){\n\n\t\t\t\t\t// next and previous point indexes\n\t\t\t\t\tnextidx = (pcnt+1)%palen; nextidx2 = (pcnt+2)%palen; previdx = (pcnt-1+palen)%palen; previdx2 = (pcnt-2+palen)%palen;\n\n\t\t\t\t\t// right angle enhance\n\t\t\t\t\tif( options.rightangleenhance && _this.testrightangle( paths[pacnt], previdx2, previdx, pcnt, nextidx, nextidx2 ) ){\n\n\t\t\t\t\t\t// Fix previous direction\n\t\t\t\t\t\tif(ins[pacnt].points.length > 0){\n\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].linesegment = _this.getdirection(\n\t\t\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].x,\n\t\t\t\t\t\t\t\t\tins[pacnt].points[ ins[pacnt].points.length-1 ].y,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// This corner point\n\t\t\t\t\t\tins[pacnt].points.push({\n\t\t\t\t\t\t\tx : paths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\ty : paths[pacnt].points[pcnt].y,\n\t\t\t\t\t\t\tlinesegment : _this.getdirection(\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].x,\n\t\t\t\t\t\t\t\t\tpaths[pacnt].points[pcnt].y,\n\t\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}// End of right angle enhance\n\n\t\t\t\t\t// interpolate between two path points\n\t\t\t\t\tins[pacnt].points.push({\n\t\t\t\t\t\tx : (( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\ty : (( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2),\n\t\t\t\t\t\tlinesegment : _this.getdirection(\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x ) /2),\n\t\t\t\t\t\t\t\t(( paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y ) /2)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t});\n\n\t\t\t\t}// End of pathpoints loop\n\n\t\t\t}// End of paths loop\n\n\t\t\treturn ins;\n\t\t},// End of internodes()\n\n\t\tthis.testrightangle = function( path, idx1, idx2, idx3, idx4, idx5 ){\n\t\t\treturn ( (( path.points[idx3].x === path.points[idx1].x) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx2].x) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx4].y) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx5].y)\n\t\t\t\t\t ) ||\n\t\t\t\t\t (( path.points[idx3].y === path.points[idx1].y) &&\n\t\t\t\t\t  ( path.points[idx3].y === path.points[idx2].y) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx4].x) &&\n\t\t\t\t\t  ( path.points[idx3].x === path.points[idx5].x)\n\t\t\t\t\t )\n\t\t\t);\n\t\t},// End of testrightangle()\n\n\t\tthis.getdirection = function( x1, y1, x2, y2 ){\n\t\t\tvar val = 8;\n\t\t\tif(x1 < x2){\n\t\t\t\tif     (y1 < y2){ val = 1; }// SouthEast\n\t\t\t\telse if(y1 > y2){ val = 7; }// NE\n\t\t\t\telse            { val = 0; }// E\n\t\t\t}else if(x1 > x2){\n\t\t\t\tif     (y1 < y2){ val = 3; }// SW\n\t\t\t\telse if(y1 > y2){ val = 5; }// NW\n\t\t\t\telse            { val = 4; }// W\n\t\t\t}else{\n\t\t\t\tif     (y1 < y2){ val = 2; }// S\n\t\t\t\telse if(y1 > y2){ val = 6; }// N\n\t\t\t\telse            { val = 8; }// center, this should not happen\n\t\t\t}\n\t\t\treturn val;\n\t\t},// End of getdirection()\n\n\t\t// 4. Batch interpollation\n\t\tthis.batchinternodes = function( bpaths, options ){\n\t\t\tvar binternodes = [];\n\t\t\tfor (var k in bpaths) {\n\t\t\t\tif(!bpaths.hasOwnProperty(k)){ continue; }\n\t\t\t\tbinternodes[k] = _this.internodes(bpaths[k], options);\n\t\t\t}\n\t\t\treturn binternodes;\n\t\t},\n\n\t\t// 5. tracepath() : recursively trying to fit straight and quadratic spline segments on the 8 direction internode path\n\n\t\t// 5.1. Find sequences of points with only 2 segment types\n\t\t// 5.2. Fit a straight line on the sequence\n\t\t// 5.3. If the straight line fails (distance error > ltres), find the point with the biggest error\n\t\t// 5.4. Fit a quadratic spline through errorpoint (project this to get controlpoint), then measure errors on every point in the sequence\n\t\t// 5.5. If the spline fails (distance error > qtres), find the point with the biggest error, set splitpoint = fitting point\n\t\t// 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\n\t\tthis.tracepath = function( path, ltres, qtres ){\n\t\t\tvar pcnt=0, segtype1, segtype2, seqend, smp = {};\n\t\t\tsmp.segments = [];\n\t\t\tsmp.boundingbox = path.boundingbox;\n\t\t\tsmp.holechildren = path.holechildren;\n\t\t\tsmp.isholepath = path.isholepath;\n\n\t\t\twhile(pcnt < path.points.length){\n\t\t\t\t// 5.1. Find sequences of points with only 2 segment types\n\t\t\t\tsegtype1 = path.points[pcnt].linesegment; segtype2 = -1; seqend=pcnt+1;\n\t\t\t\twhile(\n\t\t\t\t\t((path.points[seqend].linesegment === segtype1) || (path.points[seqend].linesegment === segtype2) || (segtype2 === -1))\n\t\t\t\t\t&& (seqend < path.points.length-1) ){\n\n\t\t\t\t\tif((path.points[seqend].linesegment!==segtype1) && (segtype2===-1)){ segtype2 = path.points[seqend].linesegment; }\n\t\t\t\t\tseqend++;\n\n\t\t\t\t}\n\t\t\t\tif(seqend === path.points.length-1){ seqend = 0; }\n\n\t\t\t\t// 5.2. - 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\t\t\t\tsmp.segments = smp.segments.concat( _this.fitseq(path, ltres, qtres, pcnt, seqend) );\n\n\t\t\t\t// forward pcnt;\n\t\t\t\tif(seqend>0){ pcnt = seqend; }else{ pcnt = path.points.length; }\n\n\t\t\t}// End of pcnt loop\n\n\t\t\treturn smp;\n\t\t},// End of tracepath()\n\n\t\t// 5.2. - 5.6. recursively fitting a straight or quadratic line segment on this sequence of path nodes,\n\t\t// called from tracepath()\n\t\tthis.fitseq = function( path, ltres, qtres, seqstart, seqend ){\n\t\t\t// return if invalid seqend\n\t\t\tif( (seqend>path.points.length) || (seqend<0) ){ return []; }\n\t\t\t// variables\n\t\t\tvar errorpoint=seqstart, errorval=0, curvepass=true, px, py, dist2;\n\t\t\tvar tl = (seqend-seqstart); if(tl<0){ tl += path.points.length; }\n\t\t\tvar vx = (path.points[seqend].x-path.points[seqstart].x) / tl,\n\t\t\t\tvy = (path.points[seqend].y-path.points[seqstart].y) / tl;\n\n\t\t\t// 5.2. Fit a straight line on the sequence\n\t\t\tvar pcnt = (seqstart+1) % path.points.length, pl;\n\t\t\twhile(pcnt != seqend){\n\t\t\t\tpl = pcnt-seqstart; if(pl<0){ pl += path.points.length; }\n\t\t\t\tpx = path.points[seqstart].x + vx * pl; py = path.points[seqstart].y + vy * pl;\n\t\t\t\tdist2 = (path.points[pcnt].x-px)*(path.points[pcnt].x-px) + (path.points[pcnt].y-py)*(path.points[pcnt].y-py);\n\t\t\t\tif(dist2>ltres){curvepass=false;}\n\t\t\t\tif(dist2>errorval){ errorpoint=pcnt; errorval=dist2; }\n\t\t\t\tpcnt = (pcnt+1)%path.points.length;\n\t\t\t}\n\t\t\t// return straight line if fits\n\t\t\tif(curvepass){ return [{ type:'L', x1:path.points[seqstart].x, y1:path.points[seqstart].y, x2:path.points[seqend].x, y2:path.points[seqend].y }]; }\n\n\t\t\t// 5.3. If the straight line fails (distance error>ltres), find the point with the biggest error\n\t\t\tvar fitpoint = errorpoint; curvepass = true; errorval = 0;\n\n\t\t\t// 5.4. Fit a quadratic spline through this point, measure errors on every point in the sequence\n\t\t\t// helpers and projecting to get control point\n\t\t\tvar t=(fitpoint-seqstart)/tl, t1=(1-t)*(1-t), t2=2*(1-t)*t, t3=t*t;\n\t\t\tvar cpx = (t1*path.points[seqstart].x + t3*path.points[seqend].x - path.points[fitpoint].x)/-t2 ,\n\t\t\t\tcpy = (t1*path.points[seqstart].y + t3*path.points[seqend].y - path.points[fitpoint].y)/-t2 ;\n\n\t\t\t// Check every point\n\t\t\tpcnt = seqstart+1;\n\t\t\twhile(pcnt != seqend){\n\t\t\t\tt=(pcnt-seqstart)/tl; t1=(1-t)*(1-t); t2=2*(1-t)*t; t3=t*t;\n\t\t\t\tpx = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x;\n\t\t\t\tpy = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y;\n\n\t\t\t\tdist2 = (path.points[pcnt].x-px)*(path.points[pcnt].x-px) + (path.points[pcnt].y-py)*(path.points[pcnt].y-py);\n\n\t\t\t\tif(dist2>qtres){curvepass=false;}\n\t\t\t\tif(dist2>errorval){ errorpoint=pcnt; errorval=dist2; }\n\t\t\t\tpcnt = (pcnt+1)%path.points.length;\n\t\t\t}\n\t\t\t// return spline if fits\n\t\t\tif(curvepass){ return [{ type:'Q', x1:path.points[seqstart].x, y1:path.points[seqstart].y, x2:cpx, y2:cpy, x3:path.points[seqend].x, y3:path.points[seqend].y }]; }\n\t\t\t// 5.5. If the spline fails (distance error>qtres), find the point with the biggest error\n\t\t\tvar splitpoint = fitpoint; // Earlier: Math.floor((fitpoint + errorpoint)/2);\n\n\t\t\t// 5.6. Split sequence and recursively apply 5.2. - 5.6. to startpoint-splitpoint and splitpoint-endpoint sequences\n\t\t\treturn _this.fitseq( path, ltres, qtres, seqstart, splitpoint ).concat(\n\t\t\t\t\t_this.fitseq( path, ltres, qtres, splitpoint, seqend ) );\n\n\t\t},// End of fitseq()\n\n\t\t// 5. Batch tracing paths\n\t\tthis.batchtracepaths = function(internodepaths,ltres,qtres){\n\t\t\tvar btracedpaths = [];\n\t\t\tfor(var k in internodepaths){\n\t\t\t\tif(!internodepaths.hasOwnProperty(k)){ continue; }\n\t\t\t\tbtracedpaths.push( _this.tracepath(internodepaths[k],ltres,qtres) );\n\t\t\t}\n\t\t\treturn btracedpaths;\n\t\t},\n\n\t\t// 5. Batch tracing layers\n\t\tthis.batchtracelayers = function(binternodes, ltres, qtres){\n\t\t\tvar btbis = [];\n\t\t\tfor(var k in binternodes){\n\t\t\t\tif(!binternodes.hasOwnProperty(k)){ continue; }\n\t\t\t\tbtbis[k] = _this.batchtracepaths(binternodes[k], ltres, qtres);\n\t\t\t}\n\t\t\treturn btbis;\n\t\t},\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  SVG Drawing functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Rounding to given decimals https://stackoverflow.com/questions/11832914/round-to-at-most-2-decimal-places-in-javascript\n\t\tthis.roundtodec = function(val,places){ return +val.toFixed(places); },\n\n\t\t// Getting SVG path element string from a traced path\n\t\tthis.svgpathstring = function( tracedata, lnum, pathnum, options ){\n\n\t\t\tvar layer = tracedata.layers[lnum], smp = layer[pathnum], str='', pcnt;\n\n\t\t\t// Line filter\n\t\t\tif(options.linefilter && (smp.segments.length < 3)){ return str; }\n\n\t\t\t// Starting path element, desc contains layer and path number\n\t\t\tstr = '<path '+\n\t\t\t\t( options.desc ? ('desc=\"l '+lnum+' p '+pathnum+'\" ') : '' ) +\n\t\t\t\t_this.tosvgcolorstr(tracedata.palette[lnum], options) +\n\t\t\t\t'd=\"';\n\n\t\t\t// Creating non-hole path string\n\t\t\tif( options.roundcoords === -1 ){\n\t\t\t\tstr += 'M '+ smp.segments[0].x1 * options.scale +' '+ smp.segments[0].y1 * options.scale +' ';\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tstr += smp.segments[pcnt].type +' '+ smp.segments[pcnt].x2 * options.scale +' '+ smp.segments[pcnt].y2 * options.scale +' ';\n\t\t\t\t\tif(smp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += smp.segments[pcnt].x3 * options.scale +' '+ smp.segments[pcnt].y3 * options.scale +' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += 'Z ';\n\t\t\t}else{\n\t\t\t\tstr += 'M '+ _this.roundtodec( smp.segments[0].x1 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[0].y1 * options.scale, options.roundcoords ) +' ';\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tstr += smp.segments[pcnt].type +' '+ _this.roundtodec( smp.segments[pcnt].x2 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[pcnt].y2 * options.scale, options.roundcoords ) +' ';\n\t\t\t\t\tif(smp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += _this.roundtodec( smp.segments[pcnt].x3 * options.scale, options.roundcoords ) +' '+ _this.roundtodec( smp.segments[pcnt].y3 * options.scale, options.roundcoords ) +' ';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstr += 'Z ';\n\t\t\t}// End of creating non-hole path string\n\n\t\t\t// Hole children\n\t\t\tfor( var hcnt=0; hcnt < smp.holechildren.length; hcnt++){\n\t\t\t\tvar hsmp = layer[ smp.holechildren[hcnt] ];\n\t\t\t\t// Creating hole path string\n\t\t\t\tif( options.roundcoords === -1 ){\n\n\t\t\t\t\tif(hsmp.segments[ hsmp.segments.length-1 ].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += 'M '+ hsmp.segments[ hsmp.segments.length-1 ].x3 * options.scale +' '+ hsmp.segments[ hsmp.segments.length-1 ].y3 * options.scale +' ';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr += 'M '+ hsmp.segments[ hsmp.segments.length-1 ].x2 * options.scale +' '+ hsmp.segments[ hsmp.segments.length-1 ].y2 * options.scale +' ';\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(pcnt = hsmp.segments.length-1; pcnt >= 0; pcnt--){\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].type +' ';\n\t\t\t\t\t\tif(hsmp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\t\tstr += hsmp.segments[pcnt].x2 * options.scale +' '+ hsmp.segments[pcnt].y2 * options.scale +' ';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].x1 * options.scale +' '+ hsmp.segments[pcnt].y1 * options.scale +' ';\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tif(hsmp.segments[ hsmp.segments.length-1 ].hasOwnProperty('x3')){\n\t\t\t\t\t\tstr += 'M '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].x3 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].y3 * options.scale ) +' ';\n\t\t\t\t\t}else{\n\t\t\t\t\t\tstr += 'M '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].x2 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[ hsmp.segments.length-1 ].y2 * options.scale ) +' ';\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(pcnt = hsmp.segments.length-1; pcnt >= 0; pcnt--){\n\t\t\t\t\t\tstr += hsmp.segments[pcnt].type +' ';\n\t\t\t\t\t\tif(hsmp.segments[pcnt].hasOwnProperty('x3')){\n\t\t\t\t\t\t\tstr += _this.roundtodec( hsmp.segments[pcnt].x2 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[pcnt].y2 * options.scale ) +' ';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstr += _this.roundtodec( hsmp.segments[pcnt].x1 * options.scale ) +' '+ _this.roundtodec( hsmp.segments[pcnt].y1 * options.scale ) +' ';\n\t\t\t\t\t}\n\n\n\t\t\t\t}// End of creating hole path string\n\n\t\t\t\tstr += 'Z '; // Close path\n\n\t\t\t}// End of holepath check\n\n\t\t\t// Closing path element\n\t\t\tstr += '\" />';\n\n\t\t\t// Rendering control points\n\t\t\tif(options.lcpr || options.qcpr){\n\t\t\t\tfor(pcnt=0; pcnt<smp.segments.length; pcnt++){\n\t\t\t\t\tif( smp.segments[pcnt].hasOwnProperty('x3') && options.qcpr ){\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"cyan\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x3 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y3 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"white\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\tstr += '<line x1=\"'+ smp.segments[pcnt].x1 * options.scale +'\" y1=\"'+ smp.segments[pcnt].y1 * options.scale +'\" x2=\"'+ smp.segments[pcnt].x2 * options.scale +'\" y2=\"'+ smp.segments[pcnt].y2 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\tstr += '<line x1=\"'+ smp.segments[pcnt].x2 * options.scale +'\" y1=\"'+ smp.segments[pcnt].y2 * options.scale +'\" x2=\"'+ smp.segments[pcnt].x3 * options.scale +'\" y2=\"'+ smp.segments[pcnt].y3 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t}\n\t\t\t\t\tif( (!smp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr){\n\t\t\t\t\t\tstr += '<circle cx=\"'+ smp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ smp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.lcpr +'\" fill=\"white\" stroke-width=\"'+ options.lcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Hole children control points\n\t\t\t\tfor( var hcnt=0; hcnt < smp.holechildren.length; hcnt++){\n\t\t\t\t\tvar hsmp = layer[ smp.holechildren[hcnt] ];\n\t\t\t\t\tfor(pcnt=0; pcnt<hsmp.segments.length; pcnt++){\n\t\t\t\t\t\tif( hsmp.segments[pcnt].hasOwnProperty('x3') && options.qcpr ){\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"cyan\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x3 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y3 * options.scale +'\" r=\"'+ options.qcpr +'\" fill=\"white\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t\tstr += '<line x1=\"'+ hsmp.segments[pcnt].x1 * options.scale +'\" y1=\"'+ hsmp.segments[pcnt].y1 * options.scale +'\" x2=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" y2=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\t\tstr += '<line x1=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" y1=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" x2=\"'+ hsmp.segments[pcnt].x3 * options.scale +'\" y2=\"'+ hsmp.segments[pcnt].y3 * options.scale +'\" stroke-width=\"'+ options.qcpr * 0.2 +'\" stroke=\"cyan\" />';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( (!hsmp.segments[pcnt].hasOwnProperty('x3')) && options.lcpr){\n\t\t\t\t\t\t\tstr += '<circle cx=\"'+ hsmp.segments[pcnt].x2 * options.scale +'\" cy=\"'+ hsmp.segments[pcnt].y2 * options.scale +'\" r=\"'+ options.lcpr +'\" fill=\"white\" stroke-width=\"'+ options.lcpr * 0.2 +'\" stroke=\"black\" />';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}// End of Rendering control points\n\n\t\t\treturn str;\n\n\t\t},// End of svgpathstring()\n\n\t\t// Converting tracedata to an SVG string\n\t\tthis.getsvgstring = function( tracedata, options ){\n\n\t\t\toptions = _this.checkoptions(options);\n\n\t\t\tvar w = tracedata.width * options.scale, h = tracedata.height * options.scale;\n\n\t\t\t// SVG start\n\t\t\tvar svgstr = '<svg ' + (options.viewbox ? ('viewBox=\"0 0 '+w+' '+h+'\" ') : ('width=\"'+w+'\" height=\"'+h+'\" ')) +\n\t\t\t\t'version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" desc=\"Created with image_tracer.js version '+_this.versionnumber+'\" >';\n\n\t\t\t// Drawing: Layers and Paths loops\n\t\t\tfor(var lcnt=0; lcnt < tracedata.layers.length; lcnt++){\n\t\t\t\tfor(var pcnt=0; pcnt < tracedata.layers[lcnt].length; pcnt++){\n\n\t\t\t\t\t// Adding SVG <path> string\n\t\t\t\t\tif( !tracedata.layers[lcnt][pcnt].isholepath ){\n\t\t\t\t\t\tsvgstr += _this.svgpathstring( tracedata, lcnt, pcnt, options );\n\t\t\t\t\t}\n\n\t\t\t\t}// End of paths loop\n\t\t\t}// End of layers loop\n\n\t\t\t// SVG End\n\t\t\tsvgstr+='</svg>';\n\n\t\t\treturn svgstr;\n\n\t\t},// End of getsvgstring()\n\n\t\t// Comparator for numeric Array.sort\n\t\tthis.compareNumbers = function(a,b){ return a - b; },\n\n\t\t// Convert color object to rgba string\n\t\tthis.torgbastr = function(c){ return 'rgba('+c.r+','+c.g+','+c.b+','+c.a+')'; },\n\n\t\t// Convert color object to SVG color string\n\t\tthis.tosvgcolorstr = function(c, options){\n\t\t\treturn 'fill=\"rgb('+c.r+','+c.g+','+c.b+')\" stroke=\"rgb('+c.r+','+c.g+','+c.b+')\" stroke-width=\"'+options.strokewidth+'\" opacity=\"'+c.a/255.0+'\" ';\n\t\t},\n\n\t\t// Helper function: Appending an <svg> element to a container from an svgstring\n\t\tthis.appendSVGString = function(svgstr,parentid){\n\t\t\tvar div;\n\t\t\tif(parentid){\n\t\t\t\tdiv = document.getElementById(parentid);\n\t\t\t\tif(!div){\n\t\t\t\t\tdiv = document.createElement('div');\n\t\t\t\t\tdiv.id = parentid;\n\t\t\t\t\tdocument.body.appendChild(div);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdiv = document.createElement('div');\n\t\t\t\tdocument.body.appendChild(div);\n\t\t\t}\n\t\t\tdiv.innerHTML += svgstr;\n\t\t},\n\n\t\t////////////////////////////////////////////////////////////\n\t\t//\n\t\t//  Canvas functions\n\t\t//\n\t\t////////////////////////////////////////////////////////////\n\n\t\t// Gaussian kernels for blur\n\t\tthis.gks = [ [0.27901,0.44198,0.27901], [0.135336,0.228569,0.272192,0.228569,0.135336], [0.086776,0.136394,0.178908,0.195843,0.178908,0.136394,0.086776],\n\t\t\t\t\t [0.063327,0.093095,0.122589,0.144599,0.152781,0.144599,0.122589,0.093095,0.063327], [0.049692,0.069304,0.089767,0.107988,0.120651,0.125194,0.120651,0.107988,0.089767,0.069304,0.049692] ],\n\n\t\t// Selective Gaussian blur for preprocessing\n\t\tthis.blur = function(imgd,radius,delta){\n\t\t\tvar i,j,k,d,idx,racc,gacc,bacc,aacc,wacc;\n\n\t\t\t// new ImageData\n\t\t\tvar imgd2 = { width:imgd.width, height:imgd.height, data:[] };\n\n\t\t\t// radius and delta limits, this kernel\n\t\t\tradius = Math.floor(radius); if(radius<1){ return imgd; } if(radius>5){ radius = 5; } delta = Math.abs( delta ); if(delta>1024){ delta = 1024; }\n\t\t\tvar thisgk = _this.gks[radius-1];\n\n\t\t\t// loop through all pixels, horizontal blur\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tracc = 0; gacc = 0; bacc = 0; aacc = 0; wacc = 0;\n\t\t\t\t\t// gauss kernel loop\n\t\t\t\t\tfor( k = -radius; k < radius+1; k++){\n\t\t\t\t\t\t// add weighted color values\n\t\t\t\t\t\tif( (i+k > 0) && (i+k < imgd.width) ){\n\t\t\t\t\t\t\tidx = (j*imgd.width+i+k)*4;\n\t\t\t\t\t\t\tracc += imgd.data[idx  ] * thisgk[k+radius];\n\t\t\t\t\t\t\tgacc += imgd.data[idx+1] * thisgk[k+radius];\n\t\t\t\t\t\t\tbacc += imgd.data[idx+2] * thisgk[k+radius];\n\t\t\t\t\t\t\taacc += imgd.data[idx+3] * thisgk[k+radius];\n\t\t\t\t\t\t\twacc += thisgk[k+radius];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// The new pixel\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\timgd2.data[idx  ] = Math.floor(racc / wacc);\n\t\t\t\t\timgd2.data[idx+1] = Math.floor(gacc / wacc);\n\t\t\t\t\timgd2.data[idx+2] = Math.floor(bacc / wacc);\n\t\t\t\t\timgd2.data[idx+3] = Math.floor(aacc / wacc);\n\n\t\t\t\t}// End of width loop\n\t\t\t}// End of horizontal blur\n\n\t\t\t// copying the half blurred imgd2\n\t\t\tvar himgd = new Uint8ClampedArray(imgd2.data);\n\n\t\t\t// loop through all pixels, vertical blur\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tracc = 0; gacc = 0; bacc = 0; aacc = 0; wacc = 0;\n\t\t\t\t\t// gauss kernel loop\n\t\t\t\t\tfor( k = -radius; k < radius+1; k++){\n\t\t\t\t\t\t// add weighted color values\n\t\t\t\t\t\tif( (j+k > 0) && (j+k < imgd.height) ){\n\t\t\t\t\t\t\tidx = ((j+k)*imgd.width+i)*4;\n\t\t\t\t\t\t\tracc += himgd[idx  ] * thisgk[k+radius];\n\t\t\t\t\t\t\tgacc += himgd[idx+1] * thisgk[k+radius];\n\t\t\t\t\t\t\tbacc += himgd[idx+2] * thisgk[k+radius];\n\t\t\t\t\t\t\taacc += himgd[idx+3] * thisgk[k+radius];\n\t\t\t\t\t\t\twacc += thisgk[k+radius];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// The new pixel\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\timgd2.data[idx  ] = Math.floor(racc / wacc);\n\t\t\t\t\timgd2.data[idx+1] = Math.floor(gacc / wacc);\n\t\t\t\t\timgd2.data[idx+2] = Math.floor(bacc / wacc);\n\t\t\t\t\timgd2.data[idx+3] = Math.floor(aacc / wacc);\n\n\t\t\t\t}// End of width loop\n\t\t\t}// End of vertical blur\n\n\t\t\t// Selective blur: loop through all pixels\n\t\t\tfor( j=0; j < imgd.height; j++ ){\n\t\t\t\tfor( i=0; i < imgd.width; i++ ){\n\n\t\t\t\t\tidx = (j*imgd.width+i)*4;\n\t\t\t\t\t// d is the difference between the blurred and the original pixel\n\t\t\t\t\td = Math.abs(imgd2.data[idx  ] - imgd.data[idx  ]) + Math.abs(imgd2.data[idx+1] - imgd.data[idx+1]) +\n\t\t\t\t\t\tMath.abs(imgd2.data[idx+2] - imgd.data[idx+2]) + Math.abs(imgd2.data[idx+3] - imgd.data[idx+3]);\n\t\t\t\t\t// selective blur: if d>delta, put the original pixel back\n\t\t\t\t\tif(d>delta){\n\t\t\t\t\t\timgd2.data[idx  ] = imgd.data[idx  ];\n\t\t\t\t\t\timgd2.data[idx+1] = imgd.data[idx+1];\n\t\t\t\t\t\timgd2.data[idx+2] = imgd.data[idx+2];\n\t\t\t\t\t\timgd2.data[idx+3] = imgd.data[idx+3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}// End of Selective blur\n\n\t\t\treturn imgd2;\n\n\t\t},// End of blur()\n\n\t\t// Helper function: loading an image from a URL, then executing callback with canvas as argument\n\t\tthis.loadImage = function(url,callback,options){\n\t\t\tvar img = new Image();\n\t\t\tif(options && options.corsenabled){ img.crossOrigin = 'Anonymous'; }\n\t\t\timg.onload = function(){\n\t\t\t\tvar canvas = null;\n\t\t\t\ttry {\n\t\t\t\t\n\t\t\t\t\tif (typeof OffscreenCanvas === \"undefined\") {\n\t\t\t\t\t\tthrow new Error(\"Impossible to create OffscreenCanvas in this web environment.\");\n\t\t\t\t\t}\n                \n\t\t\t\t    canvas = new OffscreenCanvas(img.width, img.height);\n\t\t\t\t} catch (e) {\n\t\t\t\t    \n\t\t\t\t    canvas = document.createElement('canvas');\n\t\t\t\t    canvas.width = img.width;\n\t\t\t\t\tcanvas.height = img.height;\n\t\t\t\t}\n\t\t\t\tvar context = canvas.getContext('2d');\n\t\t\t\tcontext.drawImage(img,0,0);\n\t\t\t\tcallback(canvas);\n\t\t\t};\n\t\t\timg.src = url;\n\t\t},\n\n\t\t// Helper function: getting ImageData from a canvas\n\t\tthis.getImgdata = function(canvas){\n\t\t\tvar context = canvas.getContext('2d');\n\t\t\treturn context.getImageData(0,0,canvas.width,canvas.height);\n\t\t},\n\n\t\t// Special palette to use with drawlayers()\n\t\tthis.specpalette = [\n\t\t\t{r:0,g:0,b:0,a:255}, {r:128,g:128,b:128,a:255}, {r:0,g:0,b:128,a:255}, {r:64,g:64,b:128,a:255},\n\t\t\t{r:192,g:192,b:192,a:255}, {r:255,g:255,b:255,a:255}, {r:128,g:128,b:192,a:255}, {r:0,g:0,b:192,a:255},\n\t\t\t{r:128,g:0,b:0,a:255}, {r:128,g:64,b:64,a:255}, {r:128,g:0,b:128,a:255}, {r:168,g:168,b:168,a:255},\n\t\t\t{r:192,g:128,b:128,a:255}, {r:192,g:0,b:0,a:255}, {r:255,g:255,b:255,a:255}, {r:0,g:128,b:0,a:255}\n\t\t]\n\n\t\t// Helper function: Drawing all edge node layers into a container\n\t\t;// End of function list\n\n\t\t}// End of ImageTracer object\n\n\t\n\t\tvar imgtrc = new ImageTracer();\n\t\treturn imgtrc.imagedataToSVG(image_data, options);\n}",t.exports={image_tracer:function(n,e,i){a.default.exec(window.image_tracer_process_function_string,[n,e]).catch(function(t){return new Function(window.image_tracer_process_function_string)()(n,e)}).then(function(t){i(t)}).timeout(72e3)}}}}]);